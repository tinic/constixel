<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>constixel: constixel::image&lt; T, W, H, GRAYSCALE, USE_SPAN &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">constixel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classconstixel_1_1image.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classconstixel_1_1image-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">constixel::image&lt; T, W, H, GRAYSCALE, USE_SPAN &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Core class of constixel. Holds a buffer of an image width a certain size and format. Typical use:  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="constixel_8hpp_source.html">constixel.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac0b51b87a63b6e025df0b69221a88e01" id="r_ac0b51b87a63b6e025df0b69221a88e01"><td class="memItemLeft" align="right" valign="top"><a id="ac0b51b87a63b6e025df0b69221a88e01" name="ac0b51b87a63b6e025df0b69221a88e01"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>image</b> ()=default</td></tr>
<tr class="memdesc:ac0b51b87a63b6e025df0b69221a88e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new image with internal storage. <br /></td></tr>
<tr class="separator:ac0b51b87a63b6e025df0b69221a88e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35bac64f3bada9d16609df12b6e794a" id="r_af35bac64f3bada9d16609df12b6e794a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af35bac64f3bada9d16609df12b6e794a">image</a> (const std::span&lt; uint8_t, T&lt; W, H, GRAYSCALE, USE_SPAN &gt;::image_size &gt; &amp;other)</td></tr>
<tr class="memdesc:af35bac64f3bada9d16609df12b6e794a"><td class="mdescLeft">&#160;</td><td class="mdescRight">When USE_SPAN=true creates a new image with external storage based existing std::span.  <br /></td></tr>
<tr class="separator:af35bac64f3bada9d16609df12b6e794a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812a13d7a089bc6bdf1f136bc8b3c96c" id="r_a812a13d7a089bc6bdf1f136bc8b3c96c"><td class="memItemLeft" align="right" valign="top"><a id="a812a13d7a089bc6bdf1f136bc8b3c96c" name="a812a13d7a089bc6bdf1f136bc8b3c96c"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:a812a13d7a089bc6bdf1f136bc8b3c96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the image by setting everything to zero. <br /></td></tr>
<tr class="separator:a812a13d7a089bc6bdf1f136bc8b3c96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986e5d23fedbcab99733bbf9b665d526" id="r_a986e5d23fedbcab99733bbf9b665d526"><td class="memItemLeft" align="right" valign="top">constexpr std::array&lt; uint8_t, T&lt; W, H, GRAYSCALE, USE_SPAN &gt;::image_size &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a986e5d23fedbcab99733bbf9b665d526">data_ref</a> ()</td></tr>
<tr class="memdesc:a986e5d23fedbcab99733bbf9b665d526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the underlying raw data of the image.  <br /></td></tr>
<tr class="separator:a986e5d23fedbcab99733bbf9b665d526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956e60f6964dc64b275671b0c3ce3c02" id="r_a956e60f6964dc64b275671b0c3ce3c02"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classconstixel_1_1image.html">image</a>&lt; T, W, H, GRAYSCALE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a956e60f6964dc64b275671b0c3ce3c02">clone</a> () const</td></tr>
<tr class="memdesc:a956e60f6964dc64b275671b0c3ce3c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a clone of this image. Data is copied.  <br /></td></tr>
<tr class="separator:a956e60f6964dc64b275671b0c3ce3c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fd1c527031ee660b0f3e63ee0479cc" id="r_a82fd1c527031ee660b0f3e63ee0479cc"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82fd1c527031ee660b0f3e63ee0479cc">copy</a> (const <a class="el" href="classconstixel_1_1image.html">image</a>&lt; T, W, H, GRAYSCALE &gt; &amp;src)</td></tr>
<tr class="memdesc:a82fd1c527031ee660b0f3e63ee0479cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy source image into this instance. No compositing occurs, replaces current content.  <br /></td></tr>
<tr class="separator:a82fd1c527031ee660b0f3e63ee0479cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230722191fdafba39b649776d2598f51" id="r_a230722191fdafba39b649776d2598f51"><td class="memTemplParams" colspan="2">template&lt;size_t BYTE_SIZE&gt; </td></tr>
<tr class="memitem:a230722191fdafba39b649776d2598f51"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a230722191fdafba39b649776d2598f51">copy</a> (const uint8_t *src)</td></tr>
<tr class="memdesc:a230722191fdafba39b649776d2598f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy raw source data into this instance. No compositing occurs.  <br /></td></tr>
<tr class="separator:a230722191fdafba39b649776d2598f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ec91b659f6dd98ec2faf2d02685b49" id="r_ab4ec91b659f6dd98ec2faf2d02685b49"><td class="memItemLeft" align="right" valign="top">constexpr uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4ec91b659f6dd98ec2faf2d02685b49">get_nearest_color</a> (uint8_t r, uint8_t g, uint8_t b) const</td></tr>
<tr class="memdesc:ab4ec91b659f6dd98ec2faf2d02685b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return closest match in the color palette based on the supplied red, green and blue values.  <br /></td></tr>
<tr class="separator:ab4ec91b659f6dd98ec2faf2d02685b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac471aaf3c7fdb56059b20a58c5d6f596" id="r_ac471aaf3c7fdb56059b20a58c5d6f596"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac471aaf3c7fdb56059b20a58c5d6f596">plot</a> (int32_t x, int32_t y, uint8_t col)</td></tr>
<tr class="memdesc:ac471aaf3c7fdb56059b20a58c5d6f596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plot a single pixel at the specified coordinates using the supplied color.  <br /></td></tr>
<tr class="separator:ac471aaf3c7fdb56059b20a58c5d6f596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704e5b47bb1d888a675027dc28575474" id="r_a704e5b47bb1d888a675027dc28575474"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a704e5b47bb1d888a675027dc28575474">plot</a> (const struct <a class="el" href="structconstixel_1_1plot.html">plot</a> &amp;p)</td></tr>
<tr class="memdesc:a704e5b47bb1d888a675027dc28575474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plot a single pixel at the specified coordinates using the supplied color.  <br /></td></tr>
<tr class="separator:a704e5b47bb1d888a675027dc28575474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f881c7e78dbd6dad951c2aaa80fbd0" id="r_a61f881c7e78dbd6dad951c2aaa80fbd0"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61f881c7e78dbd6dad951c2aaa80fbd0">draw_line</a> (int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint8_t col, int32_t stroke_width=1)</td></tr>
<tr class="memdesc:a61f881c7e78dbd6dad951c2aaa80fbd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a line with the specified color and thickness. Example:  <br /></td></tr>
<tr class="separator:a61f881c7e78dbd6dad951c2aaa80fbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6606d2b3f571e9c0568240d749799bbd" id="r_a6606d2b3f571e9c0568240d749799bbd"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6606d2b3f571e9c0568240d749799bbd">draw_line</a> (const struct <a class="el" href="structconstixel_1_1draw__line.html">draw_line</a> &amp;d)</td></tr>
<tr class="memdesc:a6606d2b3f571e9c0568240d749799bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a line with the specified color and thickness. Example:  <br /></td></tr>
<tr class="separator:a6606d2b3f571e9c0568240d749799bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e01279744eeb4269f160ec86986fe77" id="r_a0e01279744eeb4269f160ec86986fe77"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e01279744eeb4269f160ec86986fe77">draw_line_aa</a> (int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint8_t col, float stroke_width=1.0f)</td></tr>
<tr class="memdesc:a0e01279744eeb4269f160ec86986fe77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw an antialiased line with variable stroke width. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. Example:  <br /></td></tr>
<tr class="separator:a0e01279744eeb4269f160ec86986fe77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70321c25bf15a7e0e0759c6da599778a" id="r_a70321c25bf15a7e0e0759c6da599778a"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70321c25bf15a7e0e0759c6da599778a">draw_line_aa</a> (const struct <a class="el" href="structconstixel_1_1draw__line.html">draw_line</a> &amp;d)</td></tr>
<tr class="memdesc:a70321c25bf15a7e0e0759c6da599778a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a 1-pixel wide antialiased line with the specified color. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. Example:  <br /></td></tr>
<tr class="separator:a70321c25bf15a7e0e0759c6da599778a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091247becd0db982163215506223cbb5" id="r_a091247becd0db982163215506223cbb5"><td class="memTemplParams" colspan="2">template&lt;typename FONT, bool KERNING = false&gt; </td></tr>
<tr class="memitem:a091247becd0db982163215506223cbb5"><td class="memTemplItemLeft" align="right" valign="top">constexpr int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a091247becd0db982163215506223cbb5">string_width</a> (const char *str, size_t character_count=std::numeric_limits&lt; size_t &gt;::max(), size_t *character_actual=nullptr)</td></tr>
<tr class="memdesc:a091247becd0db982163215506223cbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the width of a string using the specified font in the template parameter. Typical use:  <br /></td></tr>
<tr class="separator:a091247becd0db982163215506223cbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d22da933c2402e72fa3972e156b5a9a" id="r_a9d22da933c2402e72fa3972e156b5a9a"><td class="memTemplParams" colspan="2">template&lt;typename FONT, bool KERNING = false, text_rotation ROTATION = DEGREE_0&gt; </td></tr>
<tr class="memitem:a9d22da933c2402e72fa3972e156b5a9a"><td class="memTemplItemLeft" align="right" valign="top">constexpr int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9d22da933c2402e72fa3972e156b5a9a">draw_string_mono</a> (int32_t x, int32_t y, const char *str, uint8_t col, size_t character_count=std::numeric_limits&lt; size_t &gt;::max(), size_t *character_actual=nullptr)</td></tr>
<tr class="memdesc:a9d22da933c2402e72fa3972e156b5a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw text at the specified coordinate. The template parameter selects which mono font to use. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported.  <br /></td></tr>
<tr class="separator:a9d22da933c2402e72fa3972e156b5a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae4f1f098da15436a1b6afee296957f" id="r_afae4f1f098da15436a1b6afee296957f"><td class="memTemplParams" colspan="2">template&lt;typename FONT, bool KERNING = false, text_rotation ROTATION = DEGREE_0&gt; </td></tr>
<tr class="memitem:afae4f1f098da15436a1b6afee296957f"><td class="memTemplItemLeft" align="right" valign="top">constexpr int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afae4f1f098da15436a1b6afee296957f">draw_string_mono</a> (const struct <a class="el" href="structconstixel_1_1draw__string.html">draw_string</a> &amp;d, size_t character_count=std::numeric_limits&lt; size_t &gt;::max(), size_t *character_actual=nullptr)</td></tr>
<tr class="memdesc:afae4f1f098da15436a1b6afee296957f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw text at the specified coordinate. The template parameter selects which mono font to use. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported.  <br /></td></tr>
<tr class="separator:afae4f1f098da15436a1b6afee296957f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4328c1f5ae437305b827edbe102c39b" id="r_ac4328c1f5ae437305b827edbe102c39b"><td class="memTemplParams" colspan="2">template&lt;typename FONT, bool KERNING = false, text_rotation ROTATION = DEGREE_0&gt; </td></tr>
<tr class="memitem:ac4328c1f5ae437305b827edbe102c39b"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac4328c1f5ae437305b827edbe102c39b">draw_string_centered_mono</a> (int32_t x, int32_t y, const char *str, uint8_t col)</td></tr>
<tr class="memdesc:ac4328c1f5ae437305b827edbe102c39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw text centered at the specified coordinate. The template parameter selects which mono font to use. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported.  <br /></td></tr>
<tr class="separator:ac4328c1f5ae437305b827edbe102c39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aad41bd0f3533c054a7eed71770b032" id="r_a2aad41bd0f3533c054a7eed71770b032"><td class="memTemplParams" colspan="2">template&lt;typename FONT, bool KERNING = false, text_rotation ROTATION = DEGREE_0&gt; </td></tr>
<tr class="memitem:a2aad41bd0f3533c054a7eed71770b032"><td class="memTemplItemLeft" align="right" valign="top">constexpr int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2aad41bd0f3533c054a7eed71770b032">draw_string_aa</a> (int32_t x, int32_t y, const char *str, uint8_t col, size_t character_count=std::numeric_limits&lt; size_t &gt;::max(), size_t *character_actual=nullptr)</td></tr>
<tr class="memdesc:a2aad41bd0f3533c054a7eed71770b032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw antialiased text at the specified coordinate. The template parameter selects which antialiased font to use. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. Typical use:  <br /></td></tr>
<tr class="separator:a2aad41bd0f3533c054a7eed71770b032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8631ba50f2616a6643ddfcc5b2654f95" id="r_a8631ba50f2616a6643ddfcc5b2654f95"><td class="memTemplParams" colspan="2">template&lt;typename FONT, bool KERNING = false, text_rotation ROTATION = DEGREE_0&gt; </td></tr>
<tr class="memitem:a8631ba50f2616a6643ddfcc5b2654f95"><td class="memTemplItemLeft" align="right" valign="top">constexpr int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8631ba50f2616a6643ddfcc5b2654f95">draw_string_aa</a> (const struct <a class="el" href="structconstixel_1_1draw__string.html">draw_string</a> &amp;d, size_t character_count=std::numeric_limits&lt; size_t &gt;::max(), size_t *character_actual=nullptr)</td></tr>
<tr class="memdesc:a8631ba50f2616a6643ddfcc5b2654f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw antialiased text at the specified coordinate. The template parameter selects which antialiased font to use. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. Typical use:  <br /></td></tr>
<tr class="separator:a8631ba50f2616a6643ddfcc5b2654f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfee593adfd9f5823b78be94464355ea" id="r_adfee593adfd9f5823b78be94464355ea"><td class="memTemplParams" colspan="2">template&lt;typename FONT, bool KERNING = false, text_rotation ROTATION = DEGREE_0&gt; </td></tr>
<tr class="memitem:adfee593adfd9f5823b78be94464355ea"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adfee593adfd9f5823b78be94464355ea">draw_string_centered_aa</a> (int32_t x, int32_t y, const char *str, uint8_t col)</td></tr>
<tr class="memdesc:adfee593adfd9f5823b78be94464355ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw antialiased text centered at the specified coordinate. The template parameter selects which antialiased font to use. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. Typical use.  <br /></td></tr>
<tr class="separator:adfee593adfd9f5823b78be94464355ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8471a044d374d78ee28c6e92db9c810" id="r_ac8471a044d374d78ee28c6e92db9c810"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8471a044d374d78ee28c6e92db9c810">fill_rect</a> (int32_t x, int32_t y, int32_t w, int32_t h, uint8_t col)</td></tr>
<tr class="memdesc:ac8471a044d374d78ee28c6e92db9c810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a rectangle with the specified color. Example:  <br /></td></tr>
<tr class="separator:ac8471a044d374d78ee28c6e92db9c810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e11fd05c71f1d708fc7c9694da42cb4" id="r_a8e11fd05c71f1d708fc7c9694da42cb4"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e11fd05c71f1d708fc7c9694da42cb4">fill_rect</a> (const struct <a class="el" href="structconstixel_1_1draw__rect.html">draw_rect</a> &amp;d)</td></tr>
<tr class="memdesc:a8e11fd05c71f1d708fc7c9694da42cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a rectangle with the specified color. Example:  <br /></td></tr>
<tr class="separator:a8e11fd05c71f1d708fc7c9694da42cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdfd85b872f8751a759659d4eff25a8" id="r_a8bdfd85b872f8751a759659d4eff25a8"><td class="memTemplParams" colspan="2">template&lt;typename shader_func&gt; <br />
requires std::is_invocable_r_v&lt;std::array&lt;float, 4&gt;, shader_func, float, float, int32_t, int32_t&gt;</td></tr>
<tr class="memitem:a8bdfd85b872f8751a759659d4eff25a8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8bdfd85b872f8751a759659d4eff25a8">fill_rect</a> (int32_t x, int32_t y, int32_t w, int32_t h, const shader_func &amp;shader) -&gt; void</td></tr>
<tr class="memdesc:a8bdfd85b872f8751a759659d4eff25a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a rectangle with a shader function that generates colors per pixel.  <br /></td></tr>
<tr class="separator:a8bdfd85b872f8751a759659d4eff25a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af693d6d18d59a5021009b7cb8f2c2df2" id="r_af693d6d18d59a5021009b7cb8f2c2df2"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af693d6d18d59a5021009b7cb8f2c2df2">stroke_rect</a> (int32_t x, int32_t y, int32_t w, int32_t h, uint8_t col, int32_t stroke_width=1)</td></tr>
<tr class="memdesc:af693d6d18d59a5021009b7cb8f2c2df2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a stroked rectangle with the specified color and stroke width. Example:  <br /></td></tr>
<tr class="separator:af693d6d18d59a5021009b7cb8f2c2df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7002b66880a9fb7ee1850cd248dbab" id="r_afd7002b66880a9fb7ee1850cd248dbab"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd7002b66880a9fb7ee1850cd248dbab">stroke_rect</a> (const struct <a class="el" href="structconstixel_1_1draw__rect.html">draw_rect</a> &amp;d)</td></tr>
<tr class="memdesc:afd7002b66880a9fb7ee1850cd248dbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw a stroked rectangle with the specified color and stroke width. Example:  <br /></td></tr>
<tr class="separator:afd7002b66880a9fb7ee1850cd248dbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28511dcf861e017c6f5fd5177fc41eea" id="r_a28511dcf861e017c6f5fd5177fc41eea"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28511dcf861e017c6f5fd5177fc41eea">fill_circle</a> (int32_t cx, int32_t cy, int32_t radius, uint8_t col)</td></tr>
<tr class="memdesc:a28511dcf861e017c6f5fd5177fc41eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a circle with the specified radius and color. Example:  <br /></td></tr>
<tr class="separator:a28511dcf861e017c6f5fd5177fc41eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a87723887cdf6ee391dc105ae909b74" id="r_a0a87723887cdf6ee391dc105ae909b74"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a87723887cdf6ee391dc105ae909b74">fill_circle</a> (const struct <a class="el" href="structconstixel_1_1draw__circle.html">draw_circle</a> &amp;d)</td></tr>
<tr class="memdesc:a0a87723887cdf6ee391dc105ae909b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a circle with the specified radius and color. Example:  <br /></td></tr>
<tr class="separator:a0a87723887cdf6ee391dc105ae909b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4708978ac33d52768e792ac9a2598950" id="r_a4708978ac33d52768e792ac9a2598950"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4708978ac33d52768e792ac9a2598950">stroke_circle</a> (int32_t cx, int32_t cy, int32_t radius, uint8_t col, int32_t stroke_width=1)</td></tr>
<tr class="memdesc:a4708978ac33d52768e792ac9a2598950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stroke a circle with the specified radius and color. Example:  <br /></td></tr>
<tr class="separator:a4708978ac33d52768e792ac9a2598950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287bed8285be9c69e4d31c949108ecdc" id="r_a287bed8285be9c69e4d31c949108ecdc"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a287bed8285be9c69e4d31c949108ecdc">stroke_circle</a> (const struct <a class="el" href="structconstixel_1_1draw__circle.html">draw_circle</a> &amp;d)</td></tr>
<tr class="memdesc:a287bed8285be9c69e4d31c949108ecdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stroke a circle with the specified radius and color. Example:  <br /></td></tr>
<tr class="separator:a287bed8285be9c69e4d31c949108ecdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850a0605678f7f83f90e3c88a36182a1" id="r_a850a0605678f7f83f90e3c88a36182a1"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a850a0605678f7f83f90e3c88a36182a1">stroke_circle_aa</a> (int32_t cx, int32_t cy, int32_t radius, uint8_t col, int32_t stroke_width=1)</td></tr>
<tr class="memdesc:a850a0605678f7f83f90e3c88a36182a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stroke a circle using antialiasing with the specified radius and color. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. Example:  <br /></td></tr>
<tr class="separator:a850a0605678f7f83f90e3c88a36182a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93aaff1ac1622010279e853869b9caed" id="r_a93aaff1ac1622010279e853869b9caed"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93aaff1ac1622010279e853869b9caed">stroke_circle_aa</a> (const struct <a class="el" href="structconstixel_1_1draw__circle.html">draw_circle</a> &amp;d)</td></tr>
<tr class="memdesc:a93aaff1ac1622010279e853869b9caed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stroke a circle using antialiasing with the specified radius and color. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. Example:  <br /></td></tr>
<tr class="separator:a93aaff1ac1622010279e853869b9caed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab208f46ba3fe196604efcd80a893037d" id="r_ab208f46ba3fe196604efcd80a893037d"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab208f46ba3fe196604efcd80a893037d">fill_circle_aa</a> (int32_t cx, int32_t cy, int32_t radius, uint8_t col)</td></tr>
<tr class="memdesc:ab208f46ba3fe196604efcd80a893037d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a circle using antialiasing with the specified radius and color. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. Example:  <br /></td></tr>
<tr class="separator:ab208f46ba3fe196604efcd80a893037d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704567ae39b38f2a151e72bf15446aaa" id="r_a704567ae39b38f2a151e72bf15446aaa"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a704567ae39b38f2a151e72bf15446aaa">fill_circle_aa</a> (const struct <a class="el" href="structconstixel_1_1draw__circle.html">draw_circle</a> &amp;d)</td></tr>
<tr class="memdesc:a704567ae39b38f2a151e72bf15446aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a circle using antialiasing with the specified radius and color. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. Example:  <br /></td></tr>
<tr class="separator:a704567ae39b38f2a151e72bf15446aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4768718b467fd140bea5dd9cba3a9bde" id="r_a4768718b467fd140bea5dd9cba3a9bde"><td class="memTemplParams" colspan="2">template&lt;typename shader_func&gt; <br />
requires std::is_invocable_r_v&lt;std::array&lt;float, 4&gt;, shader_func, float, float, int32_t, int32_t&gt;</td></tr>
<tr class="memitem:a4768718b467fd140bea5dd9cba3a9bde"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4768718b467fd140bea5dd9cba3a9bde">fill_circle_aa</a> (int32_t cx, int32_t cy, int32_t radius, const shader_func &amp;shader) -&gt; void</td></tr>
<tr class="memdesc:a4768718b467fd140bea5dd9cba3a9bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a circle using antialiasing with a shader function that generates colors per pixel.  <br /></td></tr>
<tr class="separator:a4768718b467fd140bea5dd9cba3a9bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4278b16aff84e29e63be021734e689a" id="r_ab4278b16aff84e29e63be021734e689a"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4278b16aff84e29e63be021734e689a">stroke_round_rect</a> (int32_t x, int32_t y, int32_t w, int32_t h, int32_t radius, uint8_t col, int32_t stroke_width=1)</td></tr>
<tr class="memdesc:ab4278b16aff84e29e63be021734e689a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stroke a rounded rectangle with the specified color. Example:  <br /></td></tr>
<tr class="separator:ab4278b16aff84e29e63be021734e689a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2189b7423ab1299b612e9e9cd784f107" id="r_a2189b7423ab1299b612e9e9cd784f107"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2189b7423ab1299b612e9e9cd784f107">stroke_round_rect</a> (const struct <a class="el" href="structconstixel_1_1draw__round__rect.html">draw_round_rect</a> &amp;d)</td></tr>
<tr class="memdesc:a2189b7423ab1299b612e9e9cd784f107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stroke a rounded rectangle with the specified color. Example:  <br /></td></tr>
<tr class="separator:a2189b7423ab1299b612e9e9cd784f107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5844cba937476b93dfe6c51340fcb981" id="r_a5844cba937476b93dfe6c51340fcb981"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5844cba937476b93dfe6c51340fcb981">fill_round_rect</a> (int32_t x, int32_t y, int32_t w, int32_t h, int32_t radius, uint8_t col)</td></tr>
<tr class="memdesc:a5844cba937476b93dfe6c51340fcb981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a rounded rectangle with the specified color. Example:  <br /></td></tr>
<tr class="separator:a5844cba937476b93dfe6c51340fcb981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089674f6110bd2585a3f60ff0ef68902" id="r_a089674f6110bd2585a3f60ff0ef68902"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a089674f6110bd2585a3f60ff0ef68902">fill_round_rect</a> (const struct <a class="el" href="structconstixel_1_1draw__round__rect.html">draw_round_rect</a> &amp;d)</td></tr>
<tr class="memdesc:a089674f6110bd2585a3f60ff0ef68902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a rounded rectangle with the specified color. Example:  <br /></td></tr>
<tr class="separator:a089674f6110bd2585a3f60ff0ef68902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30759a93b9c30a313294435880a67cd3" id="r_a30759a93b9c30a313294435880a67cd3"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30759a93b9c30a313294435880a67cd3">fill_round_rect_aa</a> (int32_t x, int32_t y, int32_t w, int32_t h, int32_t radius, uint8_t col)</td></tr>
<tr class="memdesc:a30759a93b9c30a313294435880a67cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a rounded rectangle using antialiasing with the specified color. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. Example:  <br /></td></tr>
<tr class="separator:a30759a93b9c30a313294435880a67cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb2f2c51431c5cb701544cf650bd222" id="r_adbb2f2c51431c5cb701544cf650bd222"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbb2f2c51431c5cb701544cf650bd222">fill_round_rect_aa</a> (const struct <a class="el" href="structconstixel_1_1draw__round__rect.html">draw_round_rect</a> &amp;d)</td></tr>
<tr class="memdesc:adbb2f2c51431c5cb701544cf650bd222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a rounded rectangle using antialiasing with the specified color. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported.  <br /></td></tr>
<tr class="separator:adbb2f2c51431c5cb701544cf650bd222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1f475b57ae52a6d8810748f459bef2" id="r_abf1f475b57ae52a6d8810748f459bef2"><td class="memTemplParams" colspan="2">template&lt;typename shader_func&gt; <br />
requires std::is_invocable_r_v&lt;std::array&lt;float, 4&gt;, shader_func, float, float, int32_t, int32_t&gt;</td></tr>
<tr class="memitem:abf1f475b57ae52a6d8810748f459bef2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf1f475b57ae52a6d8810748f459bef2">fill_round_rect_aa</a> (int32_t x, int32_t y, int32_t w, int32_t h, int32_t radius, const shader_func &amp;shader) -&gt; void</td></tr>
<tr class="memdesc:abf1f475b57ae52a6d8810748f459bef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a rounded rectangle using antialiasing with a shader function that generates colors per pixel.  <br /></td></tr>
<tr class="separator:abf1f475b57ae52a6d8810748f459bef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6ad4928abcd3a15b2c6f1ba3a1df8e" id="r_aeb6ad4928abcd3a15b2c6f1ba3a1df8e"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb6ad4928abcd3a15b2c6f1ba3a1df8e">stroke_round_rect_aa</a> (int32_t x, int32_t y, int32_t w, int32_t h, int32_t radius, uint8_t col, int32_t stroke_width=1)</td></tr>
<tr class="memdesc:aeb6ad4928abcd3a15b2c6f1ba3a1df8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stroke a rounded rectangle using antialiasing with the specified color. Example:  <br /></td></tr>
<tr class="separator:aeb6ad4928abcd3a15b2c6f1ba3a1df8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e44342138f69aac7082c2d853898cc8" id="r_a2e44342138f69aac7082c2d853898cc8"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e44342138f69aac7082c2d853898cc8">stroke_round_rect_aa</a> (const struct <a class="el" href="structconstixel_1_1draw__round__rect.html">draw_round_rect</a> &amp;d)</td></tr>
<tr class="memdesc:a2e44342138f69aac7082c2d853898cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stroke a rounded rectangle using antialiasing with the specified color. Example:  <br /></td></tr>
<tr class="separator:a2e44342138f69aac7082c2d853898cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fa55bda11819a8a7d5d4ecf93e467c" id="r_a93fa55bda11819a8a7d5d4ecf93e467c"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93fa55bda11819a8a7d5d4ecf93e467c">RGBA_uint32</a> (std::array&lt; uint32_t, W *H &gt; &amp;dst) const</td></tr>
<tr class="memdesc:a93fa55bda11819a8a7d5d4ecf93e467c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this instance to an equivalent RGBA8 data array.  <br /></td></tr>
<tr class="separator:a93fa55bda11819a8a7d5d4ecf93e467c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d84e2cd6d6ce5d34d8a187258182ddb" id="r_a3d84e2cd6d6ce5d34d8a187258182ddb"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d84e2cd6d6ce5d34d8a187258182ddb">RGBA_uint8</a> (std::array&lt; uint8_t, W *H *4 &gt; &amp;dst) const</td></tr>
<tr class="memdesc:a3d84e2cd6d6ce5d34d8a187258182ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this instance to an equivalent RGBA8 data array.  <br /></td></tr>
<tr class="separator:a3d84e2cd6d6ce5d34d8a187258182ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3d5744bb12458c6ab9241c34d36686" id="r_a0e3d5744bb12458c6ab9241c34d36686"><td class="memItemLeft" align="right" valign="top"><a id="a0e3d5744bb12458c6ab9241c34d36686" name="a0e3d5744bb12458c6ab9241c34d36686"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>flip_h</b> ()</td></tr>
<tr class="memdesc:a0e3d5744bb12458c6ab9241c34d36686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip the contents of this image horizontally. <br /></td></tr>
<tr class="separator:a0e3d5744bb12458c6ab9241c34d36686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dda05afda2d2e544d93e40486dbae60" id="r_a5dda05afda2d2e544d93e40486dbae60"><td class="memItemLeft" align="right" valign="top"><a id="a5dda05afda2d2e544d93e40486dbae60" name="a5dda05afda2d2e544d93e40486dbae60"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>flip_v</b> ()</td></tr>
<tr class="memdesc:a5dda05afda2d2e544d93e40486dbae60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip the contents of this image vertically. <br /></td></tr>
<tr class="separator:a5dda05afda2d2e544d93e40486dbae60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6334c76a690e5e3d4c4f70336f0987f7" id="r_a6334c76a690e5e3d4c4f70336f0987f7"><td class="memItemLeft" align="right" valign="top"><a id="a6334c76a690e5e3d4c4f70336f0987f7" name="a6334c76a690e5e3d4c4f70336f0987f7"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><b>flip_hv</b> ()</td></tr>
<tr class="memdesc:a6334c76a690e5e3d4c4f70336f0987f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip the contents of this image horizontally &amp; vertically. <br /></td></tr>
<tr class="separator:a6334c76a690e5e3d4c4f70336f0987f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ad81fbc0feb78c7f8857d42a685475" id="r_a32ad81fbc0feb78c7f8857d42a685475"><td class="memTemplParams" colspan="2">template&lt;bool FLIP_H = false, bool FLIP_V = false&gt; </td></tr>
<tr class="memitem:a32ad81fbc0feb78c7f8857d42a685475"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classconstixel_1_1image.html">image</a>&lt; T, H, W, GRAYSCALE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a32ad81fbc0feb78c7f8857d42a685475">transpose</a> () const</td></tr>
<tr class="memdesc:a32ad81fbc0feb78c7f8857d42a685475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a transposed version of this image.  <br /></td></tr>
<tr class="separator:a32ad81fbc0feb78c7f8857d42a685475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b8105e648df632543064a798b0405e" id="r_ab0b8105e648df632543064a798b0405e"><td class="memTemplParams" colspan="2">template&lt;bool FLIP_H = false, bool FLIP_V = false&gt; </td></tr>
<tr class="memitem:ab0b8105e648df632543064a798b0405e"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab0b8105e648df632543064a798b0405e">transpose</a> (<a class="el" href="classconstixel_1_1image.html">image</a>&lt; T, H, W, GRAYSCALE &gt; &amp;dst) const</td></tr>
<tr class="memdesc:ab0b8105e648df632543064a798b0405e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose this image into another.  <br /></td></tr>
<tr class="separator:ab0b8105e648df632543064a798b0405e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e65313720883055bbe80c39a0034634" id="r_a9e65313720883055bbe80c39a0034634"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e65313720883055bbe80c39a0034634">blit_RGBA</a> (int32_t x, int32_t y, int32_t w, int32_t h, const uint8_t *ptr, int32_t iw, int32_t ih, int32_t stride)</td></tr>
<tr class="memdesc:a9e65313720883055bbe80c39a0034634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blit an RGBA8 buffer into this instance using brute force color mapping.  <br /></td></tr>
<tr class="separator:a9e65313720883055bbe80c39a0034634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96d81246d9905c085df39e594da63ef" id="r_ad96d81246d9905c085df39e594da63ef"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad96d81246d9905c085df39e594da63ef">blit_RGBA</a> (const <a class="el" href="structconstixel_1_1rect.html">rect</a>&lt; int32_t &gt; &amp;dstrect, const uint8_t *ptr, int32_t iw, int32_t ih, int32_t stride)</td></tr>
<tr class="memdesc:ad96d81246d9905c085df39e594da63ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blit an RGBA8 buffer into this instance using brute force color mapping.  <br /></td></tr>
<tr class="separator:ad96d81246d9905c085df39e594da63ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5731069489a04dc9884f48bd4f3237" id="r_abb5731069489a04dc9884f48bd4f3237"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb5731069489a04dc9884f48bd4f3237">blit_RGBA_diffused</a> (int32_t x, int32_t y, int32_t w, int32_t h, const uint8_t *ptr, int32_t iw, int32_t ih, int32_t stride)</td></tr>
<tr class="memdesc:abb5731069489a04dc9884f48bd4f3237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blit an RGBA8 buffer into this instance using brute force color mapping. Simple integer based diffusion is applied.  <br /></td></tr>
<tr class="separator:abb5731069489a04dc9884f48bd4f3237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd52f2de04f0d8ae760328d9e8bcbd6" id="r_a0fd52f2de04f0d8ae760328d9e8bcbd6"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fd52f2de04f0d8ae760328d9e8bcbd6">blit_RGBA_diffused</a> (const <a class="el" href="structconstixel_1_1rect.html">rect</a>&lt; int32_t &gt; &amp;dstrect, const uint8_t *ptr, int32_t iw, int32_t ih, int32_t stride)</td></tr>
<tr class="memdesc:a0fd52f2de04f0d8ae760328d9e8bcbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blit an RGBA8 buffer into this instance using brute force color mapping. Simple integer based diffusion is applied.  <br /></td></tr>
<tr class="separator:a0fd52f2de04f0d8ae760328d9e8bcbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7529255a5c29e6997010224a8223d54" id="r_af7529255a5c29e6997010224a8223d54"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7529255a5c29e6997010224a8223d54">blit_RGBA_diffused_linear</a> (int32_t x, int32_t y, int32_t w, int32_t h, const uint8_t *ptr, int32_t iw, int32_t ih, int32_t stride)</td></tr>
<tr class="memdesc:af7529255a5c29e6997010224a8223d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blit an RGBA8 buffer into this instance using brute force color mapping. Diffusion in linear color space is applied.  <br /></td></tr>
<tr class="separator:af7529255a5c29e6997010224a8223d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5200785d2a1c73bb6dd0be482e1a291e" id="r_a5200785d2a1c73bb6dd0be482e1a291e"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5200785d2a1c73bb6dd0be482e1a291e">blit_RGBA_diffused_linear</a> (const <a class="el" href="structconstixel_1_1rect.html">rect</a>&lt; int32_t &gt; &amp;dstrect, const uint8_t *ptr, int32_t iw, int32_t ih, int32_t stride)</td></tr>
<tr class="memdesc:a5200785d2a1c73bb6dd0be482e1a291e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blit an RGBA8 buffer into this instance using brute force color mapping. Diffusion in linear color space is applied.  <br /></td></tr>
<tr class="separator:a5200785d2a1c73bb6dd0be482e1a291e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a5c4af0baf26d096b2f056249fa327" id="r_a76a5c4af0baf26d096b2f056249fa327"><td class="memTemplParams" colspan="2">template&lt;typename F&gt; </td></tr>
<tr class="memitem:a76a5c4af0baf26d096b2f056249fa327"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a76a5c4af0baf26d096b2f056249fa327">png</a> (F &amp;&amp;char_out) const</td></tr>
<tr class="memdesc:a76a5c4af0baf26d096b2f056249fa327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the current instance into a png image. Typically an implementation looks like this:  <br /></td></tr>
<tr class="separator:a76a5c4af0baf26d096b2f056249fa327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5861d809e14823b71640b0104bdd46d1" id="r_a5861d809e14823b71640b0104bdd46d1"><td class="memTemplParams" colspan="2">template&lt;size_t S = 1, typename F&gt; </td></tr>
<tr class="memitem:a5861d809e14823b71640b0104bdd46d1"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5861d809e14823b71640b0104bdd46d1">sixel</a> (F &amp;&amp;char_out) const</td></tr>
<tr class="memdesc:a5861d809e14823b71640b0104bdd46d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the current instance into a sixel stream. Typically an implementation looks like this:  <br /></td></tr>
<tr class="separator:a5861d809e14823b71640b0104bdd46d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07774a298459b7ec3e457ec4df27869e" id="r_a07774a298459b7ec3e457ec4df27869e"><td class="memTemplParams" colspan="2">template&lt;size_t S = 1, typename F&gt; </td></tr>
<tr class="memitem:a07774a298459b7ec3e457ec4df27869e"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a07774a298459b7ec3e457ec4df27869e">sixel</a> (F &amp;&amp;char_out, const <a class="el" href="structconstixel_1_1rect.html">rect</a>&lt; int32_t &gt; &amp;<a class="el" href="structconstixel_1_1rect.html">rect</a>) const</td></tr>
<tr class="memdesc:a07774a298459b7ec3e457ec4df27869e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the current instance into a sixel stream. Typically an implementation looks like this:  <br /></td></tr>
<tr class="separator:a07774a298459b7ec3e457ec4df27869e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518612cc47067c27654de327cd9cb6b3" id="r_a518612cc47067c27654de327cd9cb6b3"><td class="memTemplParams" colspan="2">template&lt;size_t S = 1&gt; </td></tr>
<tr class="memitem:a518612cc47067c27654de327cd9cb6b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a518612cc47067c27654de327cd9cb6b3">sixel_to_cout</a> () const</td></tr>
<tr class="memdesc:a518612cc47067c27654de327cd9cb6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the current instance into a sixel stream and output it to std::cout.  <br /></td></tr>
<tr class="separator:a518612cc47067c27654de327cd9cb6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea8bbc3dd0c803544319949c5c399d8" id="r_a5ea8bbc3dd0c803544319949c5c399d8"><td class="memItemLeft" align="right" valign="top"><a id="a5ea8bbc3dd0c803544319949c5c399d8" name="a5ea8bbc3dd0c803544319949c5c399d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>vt100_clear</b> () const</td></tr>
<tr class="memdesc:a5ea8bbc3dd0c803544319949c5c399d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a escape command to std::cout to clear the screen and scroll buffer of a vt100 compatible terminal. <br /></td></tr>
<tr class="separator:a5ea8bbc3dd0c803544319949c5c399d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5209c6ba107273f2b4c3652247995ba1" id="r_a5209c6ba107273f2b4c3652247995ba1"><td class="memItemLeft" align="right" valign="top"><a id="a5209c6ba107273f2b4c3652247995ba1" name="a5209c6ba107273f2b4c3652247995ba1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>vt100_clear_scrollback</b> () const</td></tr>
<tr class="memdesc:a5209c6ba107273f2b4c3652247995ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a escape command to std::cout to clear the screen and scroll buffer of a vt100 compatible terminal. <br /></td></tr>
<tr class="separator:a5209c6ba107273f2b4c3652247995ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0eb1cdfc6da67497e6f0fac437ff1f6" id="r_ae0eb1cdfc6da67497e6f0fac437ff1f6"><td class="memItemLeft" align="right" valign="top"><a id="ae0eb1cdfc6da67497e6f0fac437ff1f6" name="ae0eb1cdfc6da67497e6f0fac437ff1f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>vt100_home</b> () const</td></tr>
<tr class="memdesc:ae0eb1cdfc6da67497e6f0fac437ff1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a escape command to std::cout to home the cursor of a vt100 compatible terminal. <br /></td></tr>
<tr class="separator:ae0eb1cdfc6da67497e6f0fac437ff1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797f9b4c797bb28fd0b74d5e728b7c5a" id="r_a797f9b4c797bb28fd0b74d5e728b7c5a"><td class="memItemLeft" align="right" valign="top"><a id="a797f9b4c797bb28fd0b74d5e728b7c5a" name="a797f9b4c797bb28fd0b74d5e728b7c5a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>png_to_iterm</b> () const</td></tr>
<tr class="memdesc:a797f9b4c797bb28fd0b74d5e728b7c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the current instance into a png and display it in iTerm. <br /></td></tr>
<tr class="separator:a797f9b4c797bb28fd0b74d5e728b7c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41974f6652f2f27aaafb99ec114db86" id="r_ab41974f6652f2f27aaafb99ec114db86"><td class="memItemLeft" align="right" valign="top"><a id="ab41974f6652f2f27aaafb99ec114db86" name="ab41974f6652f2f27aaafb99ec114db86"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>png_to_kitty</b> () const</td></tr>
<tr class="memdesc:ab41974f6652f2f27aaafb99ec114db86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the current instance into a png and display it in a terminal with kitty graphics support. <br /></td></tr>
<tr class="separator:ab41974f6652f2f27aaafb99ec114db86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486a02413b3ff900c69ec43b85c9ea70" id="r_a486a02413b3ff900c69ec43b85c9ea70"><td class="memTemplParams" colspan="2">template&lt;device_format dst_format, typename F&gt; </td></tr>
<tr class="memitem:a486a02413b3ff900c69ec43b85c9ea70"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a486a02413b3ff900c69ec43b85c9ea70">convert</a> (F &amp;&amp;uint8_out)</td></tr>
<tr class="memdesc:a486a02413b3ff900c69ec43b85c9ea70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the current instance into a byte stream formatted for embedded displays.  <br /></td></tr>
<tr class="separator:a486a02413b3ff900c69ec43b85c9ea70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb97c591957e1a59abc04e7c88c220bd" id="r_aeb97c591957e1a59abc04e7c88c220bd"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb97c591957e1a59abc04e7c88c220bd">rect</a> (int32_t x, int32_t y, int32_t w, int32_t h)</td></tr>
<tr class="memdesc:aeb97c591957e1a59abc04e7c88c220bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fluent shape API methods for method chaining These provide a more expressive way to create shapes compared to struct-based calls.  <br /></td></tr>
<tr class="separator:aeb97c591957e1a59abc04e7c88c220bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbdb10f079b3ee0581a628dc9476c5d" id="r_a0cbdb10f079b3ee0581a628dc9476c5d"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cbdb10f079b3ee0581a628dc9476c5d">circle</a> (int32_t cx, int32_t cy, int32_t r)</td></tr>
<tr class="memdesc:a0cbdb10f079b3ee0581a628dc9476c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a circle shape for fluent method chaining.  <br /></td></tr>
<tr class="separator:a0cbdb10f079b3ee0581a628dc9476c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bf53b99f37c6e47bfcc799dbb57a75" id="r_ac3bf53b99f37c6e47bfcc799dbb57a75"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3bf53b99f37c6e47bfcc799dbb57a75">circle_aa</a> (int32_t cx, int32_t cy, int32_t r)</td></tr>
<tr class="memdesc:ac3bf53b99f37c6e47bfcc799dbb57a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an antialiased circle shape for fluent method chaining. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported.  <br /></td></tr>
<tr class="separator:ac3bf53b99f37c6e47bfcc799dbb57a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2ab33c429c26a6dd7e8c5bcb4555f9" id="r_a9d2ab33c429c26a6dd7e8c5bcb4555f9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d2ab33c429c26a6dd7e8c5bcb4555f9">round_rect</a> (int32_t x, int32_t y, int32_t w, int32_t h, int32_t radius)</td></tr>
<tr class="memdesc:a9d2ab33c429c26a6dd7e8c5bcb4555f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rounded rectangle shape for fluent method chaining.  <br /></td></tr>
<tr class="separator:a9d2ab33c429c26a6dd7e8c5bcb4555f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fad144cfc9932aafb1875814ad7c27" id="r_a35fad144cfc9932aafb1875814ad7c27"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35fad144cfc9932aafb1875814ad7c27">round_rect_aa</a> (int32_t x, int32_t y, int32_t w, int32_t h, int32_t radius)</td></tr>
<tr class="memdesc:a35fad144cfc9932aafb1875814ad7c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an antialiased rounded rectangle shape for fluent method chaining. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported.  <br /></td></tr>
<tr class="separator:a35fad144cfc9932aafb1875814ad7c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51a0777b177a683063de0d3eb7f5432" id="r_ab51a0777b177a683063de0d3eb7f5432"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab51a0777b177a683063de0d3eb7f5432">line</a> (int32_t x0, int32_t y0, int32_t x1, int32_t y1)</td></tr>
<tr class="memdesc:ab51a0777b177a683063de0d3eb7f5432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a line shape for fluent method chaining.  <br /></td></tr>
<tr class="separator:ab51a0777b177a683063de0d3eb7f5432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e1dd7fa89b3f77fc08a6c579888517" id="r_a02e1dd7fa89b3f77fc08a6c579888517"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02e1dd7fa89b3f77fc08a6c579888517">line_aa</a> (int32_t x0, int32_t y0, int32_t x1, int32_t y1)</td></tr>
<tr class="memdesc:a02e1dd7fa89b3f77fc08a6c579888517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an antialiased line shape for fluent method chaining. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported.  <br /></td></tr>
<tr class="separator:a02e1dd7fa89b3f77fc08a6c579888517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9a4bc386268bfda228712d06974858" id="r_ace9a4bc386268bfda228712d06974858"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace9a4bc386268bfda228712d06974858">point</a> (int32_t x, int32_t y)</td></tr>
<tr class="memdesc:ace9a4bc386268bfda228712d06974858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a point shape for fluent method chaining.  <br /></td></tr>
<tr class="separator:ace9a4bc386268bfda228712d06974858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a73f0719efdcd7d467531ded4bd2104" id="r_a5a73f0719efdcd7d467531ded4bd2104"><td class="memTemplParams" colspan="2">template&lt;typename FONT, bool KERNING = false, text_rotation ROTATION = DEGREE_0&gt; </td></tr>
<tr class="memitem:a5a73f0719efdcd7d467531ded4bd2104"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5a73f0719efdcd7d467531ded4bd2104">text_mono</a> (int32_t x, int32_t y, const char *str)</td></tr>
<tr class="memdesc:a5a73f0719efdcd7d467531ded4bd2104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a text shape for fluent monospace string drawing with method chaining.  <br /></td></tr>
<tr class="separator:a5a73f0719efdcd7d467531ded4bd2104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658bd0f0123994ca7b5ff4b2a154cac2" id="r_a658bd0f0123994ca7b5ff4b2a154cac2"><td class="memTemplParams" colspan="2">template&lt;typename FONT, bool KERNING = false, text_rotation ROTATION = DEGREE_0&gt; </td></tr>
<tr class="memitem:a658bd0f0123994ca7b5ff4b2a154cac2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a658bd0f0123994ca7b5ff4b2a154cac2">text_aa</a> (int32_t x, int32_t y, const char *str)</td></tr>
<tr class="memdesc:a658bd0f0123994ca7b5ff4b2a154cac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a text shape for fluent antialiased string drawing with method chaining. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported.  <br /></td></tr>
<tr class="separator:a658bd0f0123994ca7b5ff4b2a154cac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9e638c38059337f75611e458a4ec99" id="r_a3a9e638c38059337f75611e458a4ec99"><td class="memTemplParams" colspan="2">template&lt;typename FONT, bool KERNING = false, text_rotation ROTATION = DEGREE_0&gt; </td></tr>
<tr class="memitem:a3a9e638c38059337f75611e458a4ec99"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3a9e638c38059337f75611e458a4ec99">text_centered_mono</a> (int32_t x, int32_t y, const char *str)</td></tr>
<tr class="memdesc:a3a9e638c38059337f75611e458a4ec99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a text shape for fluent centered monospace string drawing with method chaining.  <br /></td></tr>
<tr class="separator:a3a9e638c38059337f75611e458a4ec99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb9d0db246e5f4b7514e0acb1617d73" id="r_a3bb9d0db246e5f4b7514e0acb1617d73"><td class="memTemplParams" colspan="2">template&lt;typename FONT, bool KERNING = false, text_rotation ROTATION = DEGREE_0&gt; </td></tr>
<tr class="memitem:a3bb9d0db246e5f4b7514e0acb1617d73"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3bb9d0db246e5f4b7514e0acb1617d73">text_centered_aa</a> (int32_t x, int32_t y, const char *str)</td></tr>
<tr class="memdesc:a3bb9d0db246e5f4b7514e0acb1617d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a text shape for fluent centered antialiased string drawing with method chaining. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported.  <br /></td></tr>
<tr class="separator:a3bb9d0db246e5f4b7514e0acb1617d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac70cd7b8050c46e68c4bc604978a9e0f" id="r_ac70cd7b8050c46e68c4bc604978a9e0f"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac70cd7b8050c46e68c4bc604978a9e0f">grayscale</a> ()</td></tr>
<tr class="memdesc:ac70cd7b8050c46e68c4bc604978a9e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean indicating that the palette is grayscale instead of color.  <br /></td></tr>
<tr class="separator:ac70cd7b8050c46e68c4bc604978a9e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ce343069ebf0cdcee275d5a8d061c2" id="r_ac8ce343069ebf0cdcee275d5a8d061c2"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8ce343069ebf0cdcee275d5a8d061c2">bit_depth</a> ()</td></tr>
<tr class="memdesc:ac8ce343069ebf0cdcee275d5a8d061c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit depth of the image.  <br /></td></tr>
<tr class="separator:ac8ce343069ebf0cdcee275d5a8d061c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a1147a9eb41bce05235d3f06c35415" id="r_a90a1147a9eb41bce05235d3f06c35415"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90a1147a9eb41bce05235d3f06c35415">size</a> ()</td></tr>
<tr class="memdesc:a90a1147a9eb41bce05235d3f06c35415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes of the image data. This does not include the image instance size.  <br /></td></tr>
<tr class="separator:a90a1147a9eb41bce05235d3f06c35415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd481f6ad62e0e7acf0f23b7f9484b4" id="r_adbd481f6ad62e0e7acf0f23b7f9484b4"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbd481f6ad62e0e7acf0f23b7f9484b4">bytes_per_line</a> ()</td></tr>
<tr class="memdesc:adbd481f6ad62e0e7acf0f23b7f9484b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bytes per line in the image data. Also called stride.  <br /></td></tr>
<tr class="separator:adbd481f6ad62e0e7acf0f23b7f9484b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a20e73412dc283ed908959a31ebca6" id="r_a13a20e73412dc283ed908959a31ebca6"><td class="memItemLeft" align="right" valign="top">static constexpr int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13a20e73412dc283ed908959a31ebca6">width</a> ()</td></tr>
<tr class="memdesc:a13a20e73412dc283ed908959a31ebca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Width in pixels of the image.  <br /></td></tr>
<tr class="separator:a13a20e73412dc283ed908959a31ebca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac369f6e16d8a6d48a03aa309d7de199b" id="r_ac369f6e16d8a6d48a03aa309d7de199b"><td class="memItemLeft" align="right" valign="top">static constexpr int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac369f6e16d8a6d48a03aa309d7de199b">height</a> ()</td></tr>
<tr class="memdesc:ac369f6e16d8a6d48a03aa309d7de199b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Height in pixels of the image.  <br /></td></tr>
<tr class="separator:ac369f6e16d8a6d48a03aa309d7de199b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt;<br />
class constixel::image&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;</div><p>Core class of constixel. Holds a buffer of an image width a certain size and format. Typical use: </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classconstixel_1_1image.html">constixel::image&lt;constixel::format_8bit, 640, 480&gt;</a> <a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>;</div>
<div class="ttc" id="aclassconstixel_1_1image_html"><div class="ttname"><a href="classconstixel_1_1image.html">constixel::image</a></div><div class="ttdoc">Core class of constixel. Holds a buffer of an image width a certain size and format....</div><div class="ttdef"><b>Definition</b> constixel.hpp:3535</div></div>
<div class="ttc" id="aclassconstixel_1_1image_html_ac0b51b87a63b6e025df0b69221a88e01"><div class="ttname"><a href="#ac0b51b87a63b6e025df0b69221a88e01">constixel::image::image</a></div><div class="ttdeci">image()=default</div><div class="ttdoc">Creates a new image with internal storage.</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the image buffer. One of <a class="el" href="classconstixel_1_1format__1bit.html" title="1-bit format, just b/w. Use as template parameter for image. Example:">format_1bit</a>, <a class="el" href="classconstixel_1_1format__2bit.html" title="2-bit color format, 4 colors total. Use as template parameter for image.">format_2bit</a>, <a class="el" href="classconstixel_1_1format__4bit.html" title="4-bit color format, 16 colors total. Use as template parameter for image.">format_4bit</a>, <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a>, <a class="el" href="classconstixel_1_1format__24bit.html" title="24-bit format. Use as template parameter for image. Example:">format_24bit</a> or <a class="el" href="classconstixel_1_1format__32bit.html" title="32-bit format. Use as template parameter for image. Example:">format_32bit</a>. </td></tr>
    <tr><td class="paramname">W</td><td>Width in pixels. </td></tr>
    <tr><td class="paramname">H</td><td>Height in pixels. </td></tr>
    <tr><td class="paramname">GRAYSCALE</td><td>boolean to indicate if palette should be grayscale. Otherwise a colored palette will be used. </td></tr>
    <tr><td class="paramname">USE_SPAN</td><td>Pass in your own std::span in the constructor to be used as a back buffer. Defaults to false. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af35bac64f3bada9d16609df12b6e794a" name="af35bac64f3bada9d16609df12b6e794a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35bac64f3bada9d16609df12b6e794a">&#9670;&#160;</a></span>image()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::image </td>
          <td>(</td>
          <td class="paramtype">const std::span&lt; uint8_t, T&lt; W, H, GRAYSCALE, USE_SPAN &gt;::image_size &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>When USE_SPAN=true creates a new image with external storage based existing std::span. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>If USE_SPAN=true this constructor will accept a std::span. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac8ce343069ebf0cdcee275d5a8d061c2" name="ac8ce343069ebf0cdcee275d5a8d061c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ce343069ebf0cdcee275d5a8d061c2">&#9670;&#160;</a></span>bit_depth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_t <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::bit_depth </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bit depth of the image. </p>
<dl class="section return"><dt>Returns</dt><dd>Bit depth of the image. 1 == 2 colors, 2 == 4 colors, 4 == 16 colors, 8 == 256 colors. </dd></dl>

</div>
</div>
<a id="ad96d81246d9905c085df39e594da63ef" name="ad96d81246d9905c085df39e594da63ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96d81246d9905c085df39e594da63ef">&#9670;&#160;</a></span>blit_RGBA() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::blit_RGBA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structconstixel_1_1rect.html">rect</a>&lt; int32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dstrect</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>iw</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>ih</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>stride</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blit an RGBA8 buffer into this instance using brute force color mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstrect</td><td>Rectangular area in the target buffer to blit into. If the rectangle is smaller than the RGBA8 buffer, clipping occurs. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to the RGBA8 buffer. </td></tr>
    <tr><td class="paramname">iw</td><td>Width in pixels of the RGBA8 buffer. </td></tr>
    <tr><td class="paramname">ih</td><td>Weight in pixels of the RGBA8 buffer. </td></tr>
    <tr><td class="paramname">stride</td><td>Bytes per line of pixels of the RGBA8 buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e65313720883055bbe80c39a0034634" name="a9e65313720883055bbe80c39a0034634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e65313720883055bbe80c39a0034634">&#9670;&#160;</a></span>blit_RGBA() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::blit_RGBA </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>iw</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>ih</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>stride</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blit an RGBA8 buffer into this instance using brute force color mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Starting X-coordinate position in the target instance in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Starting Y-coordinate position in the target instance in pixels. </td></tr>
    <tr><td class="paramname">w</td><td>Width of the rectangle. If the width is smaller than the RGBA8 buffer content will be clipped. </td></tr>
    <tr><td class="paramname">h</td><td>Weight of the rectangle. If the height is smaller than the RGBA8 buffer content will be clipped. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to the RGBA8 buffer. </td></tr>
    <tr><td class="paramname">iw</td><td>Width in pixels of the RGBA8 buffer. </td></tr>
    <tr><td class="paramname">ih</td><td>Height in pixels of the RGBA8 buffer. </td></tr>
    <tr><td class="paramname">stride</td><td>Bytes per line of pixels of the RGBA8 buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fd52f2de04f0d8ae760328d9e8bcbd6" name="a0fd52f2de04f0d8ae760328d9e8bcbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd52f2de04f0d8ae760328d9e8bcbd6">&#9670;&#160;</a></span>blit_RGBA_diffused() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::blit_RGBA_diffused </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structconstixel_1_1rect.html">rect</a>&lt; int32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dstrect</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>iw</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>ih</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>stride</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blit an RGBA8 buffer into this instance using brute force color mapping. Simple integer based diffusion is applied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstrect</td><td>Rectangular area in the target buffer to blit into. If the rectangle is smaller than the RGBA8 buffer, clipping occurs. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to the RGBA8 buffer. </td></tr>
    <tr><td class="paramname">iw</td><td>Width in pixels of the RGBA8 buffer. </td></tr>
    <tr><td class="paramname">ih</td><td>Weight in pixels of the RGBA8 buffer. </td></tr>
    <tr><td class="paramname">stride</td><td>Bytes per line of pixels of the RGBA8 buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb5731069489a04dc9884f48bd4f3237" name="abb5731069489a04dc9884f48bd4f3237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5731069489a04dc9884f48bd4f3237">&#9670;&#160;</a></span>blit_RGBA_diffused() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::blit_RGBA_diffused </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>iw</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>ih</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>stride</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blit an RGBA8 buffer into this instance using brute force color mapping. Simple integer based diffusion is applied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Starting X-coordinate position in the target instance in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Starting Y-coordinate position in the target instance in pixels. </td></tr>
    <tr><td class="paramname">w</td><td>Width of the rectangle. If the width is smaller than the RGBA8 buffer content will be clipped. </td></tr>
    <tr><td class="paramname">h</td><td>Weight of the rectangle. If the height is smaller than the RGBA8 buffer content will be clipped. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to the RGBA8 buffer. </td></tr>
    <tr><td class="paramname">iw</td><td>Width in pixels of the RGBA8 buffer. </td></tr>
    <tr><td class="paramname">ih</td><td>Height in pixels of the RGBA8 buffer. </td></tr>
    <tr><td class="paramname">stride</td><td>Bytes per line of pixels of the RGBA8 buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5200785d2a1c73bb6dd0be482e1a291e" name="a5200785d2a1c73bb6dd0be482e1a291e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5200785d2a1c73bb6dd0be482e1a291e">&#9670;&#160;</a></span>blit_RGBA_diffused_linear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::blit_RGBA_diffused_linear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structconstixel_1_1rect.html">rect</a>&lt; int32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dstrect</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>iw</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>ih</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>stride</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blit an RGBA8 buffer into this instance using brute force color mapping. Diffusion in linear color space is applied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstrect</td><td>Rectangular area in the target buffer to blit into. If the rectangle is smaller than the RGBA8 buffer, clipping occurs. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to the RGBA8 buffer. </td></tr>
    <tr><td class="paramname">iw</td><td>Width in pixels of the RGBA8 buffer. </td></tr>
    <tr><td class="paramname">ih</td><td>Weight in pixels of the RGBA8 buffer. </td></tr>
    <tr><td class="paramname">stride</td><td>Bytes per line of pixels of the RGBA8 buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7529255a5c29e6997010224a8223d54" name="af7529255a5c29e6997010224a8223d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7529255a5c29e6997010224a8223d54">&#9670;&#160;</a></span>blit_RGBA_diffused_linear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::blit_RGBA_diffused_linear </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>iw</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>ih</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>stride</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blit an RGBA8 buffer into this instance using brute force color mapping. Diffusion in linear color space is applied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Starting X-coordinate position in the target instance in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Starting Y-coordinate position in the target instance in pixels. </td></tr>
    <tr><td class="paramname">w</td><td>Width of the rectangle. If the width is smaller than the RGBA8 buffer content will be clipped. </td></tr>
    <tr><td class="paramname">h</td><td>Weight of the rectangle. If the height is smaller than the RGBA8 buffer content will be clipped. </td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to the RGBA8 buffer. </td></tr>
    <tr><td class="paramname">iw</td><td>Width in pixels of the RGBA8 buffer. </td></tr>
    <tr><td class="paramname">ih</td><td>Height in pixels of the RGBA8 buffer. </td></tr>
    <tr><td class="paramname">stride</td><td>Bytes per line of pixels of the RGBA8 buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbd481f6ad62e0e7acf0f23b7f9484b4" name="adbd481f6ad62e0e7acf0f23b7f9484b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd481f6ad62e0e7acf0f23b7f9484b4">&#9670;&#160;</a></span>bytes_per_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_t <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::bytes_per_line </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bytes per line in the image data. Also called stride. </p>
<dl class="section return"><dt>Returns</dt><dd>Bytes per line in the image data. </dd></dl>

</div>
</div>
<a id="a0cbdb10f079b3ee0581a628dc9476c5d" name="a0cbdb10f079b3ee0581a628dc9476c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cbdb10f079b3ee0581a628dc9476c5d">&#9670;&#160;</a></span>circle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::circle </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>cx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>cy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a circle shape for fluent method chaining. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cx</td><td>Center X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">cy</td><td>Center Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">r</td><td>Radius of the circle in pixels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A circle shape object that supports .fill() and .stroke() methods. </dd></dl>

</div>
</div>
<a id="ac3bf53b99f37c6e47bfcc799dbb57a75" name="ac3bf53b99f37c6e47bfcc799dbb57a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bf53b99f37c6e47bfcc799dbb57a75">&#9670;&#160;</a></span>circle_aa()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::circle_aa </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>cx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>cy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an antialiased circle shape for fluent method chaining. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cx</td><td>Center X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">cy</td><td>Center Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">r</td><td>Radius of the circle in pixels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A circle_aa shape object that supports .fill() and .stroke() methods. </dd></dl>

</div>
</div>
<a id="a956e60f6964dc64b275671b0c3ce3c02" name="a956e60f6964dc64b275671b0c3ce3c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956e60f6964dc64b275671b0c3ce3c02">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconstixel_1_1image.html">image</a>&lt; T, W, H, GRAYSCALE &gt; <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::clone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a clone of this image. Data is copied. </p>
<dl class="section return"><dt>Returns</dt><dd>Cloned image instance. </dd></dl>

</div>
</div>
<a id="a486a02413b3ff900c69ec43b85c9ea70" name="a486a02413b3ff900c69ec43b85c9ea70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486a02413b3ff900c69ec43b85c9ea70">&#9670;&#160;</a></span>convert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;device_format dst_format, typename F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::convert </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>uint8_out</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the current instance into a byte stream formatted for embedded displays. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dst_format</td><td>The desired data format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint8_out</td><td>A lambda function which consumes the data stream one byte at a time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82fd1c527031ee660b0f3e63ee0479cc" name="a82fd1c527031ee660b0f3e63ee0479cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82fd1c527031ee660b0f3e63ee0479cc">&#9670;&#160;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classconstixel_1_1image.html">image</a>&lt; T, W, H, GRAYSCALE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy source image into this instance. No compositing occurs, replaces current content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a230722191fdafba39b649776d2598f51" name="a230722191fdafba39b649776d2598f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230722191fdafba39b649776d2598f51">&#9670;&#160;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;size_t BYTE_SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy raw source data into this instance. No compositing occurs. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BYTE_SIZE</td><td>Amount data in the source data. Typically a sizeof() of an array. Must match <a class="el" href="#a90a1147a9eb41bce05235d3f06c35415" title="Size in bytes of the image data. This does not include the image instance size.">image::size()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a986e5d23fedbcab99733bbf9b665d526" name="a986e5d23fedbcab99733bbf9b665d526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a986e5d23fedbcab99733bbf9b665d526">&#9670;&#160;</a></span>data_ref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; uint8_t, T&lt; W, H, GRAYSCALE, USE_SPAN &gt;::image_size &gt; &amp; <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::data_ref </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the underlying raw data of the image. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the data array which contains the raw image data. </dd></dl>

</div>
</div>
<a id="a6606d2b3f571e9c0568240d749799bbd" name="a6606d2b3f571e9c0568240d749799bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6606d2b3f571e9c0568240d749799bbd">&#9670;&#160;</a></span>draw_line() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::draw_line </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structconstixel_1_1draw__line.html">draw_line</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a line with the specified color and thickness. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.draw_line({.x0=0, .y0=0, .x1=200, .y1=100, .col=color::WHITE, .sw=2});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td><a class="el" href="structconstixel_1_1draw__line.html">draw_line</a> initializer struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61f881c7e78dbd6dad951c2aaa80fbd0" name="a61f881c7e78dbd6dad951c2aaa80fbd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f881c7e78dbd6dad951c2aaa80fbd0">&#9670;&#160;</a></span>draw_line() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::draw_line </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>stroke_width</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a line with the specified color and thickness. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.draw_line(0, 0, 200, 100, constixel::color::WHITE, 2);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x0</td><td>Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y0</td><td>Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">x1</td><td>Ending X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y1</td><td>Ending Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">col</td><td>Color palette index to use. </td></tr>
    <tr><td class="paramname">stroke_width</td><td>Width of the stroke in pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70321c25bf15a7e0e0759c6da599778a" name="a70321c25bf15a7e0e0759c6da599778a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70321c25bf15a7e0e0759c6da599778a">&#9670;&#160;</a></span>draw_line_aa() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::draw_line_aa </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structconstixel_1_1draw__line.html">draw_line</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a 1-pixel wide antialiased line with the specified color. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.draw_line_aa({.x0=0, .y0=0, .x1=200, .y1=100, .col=color::WHITE, .sw=2.5f});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td><a class="el" href="structconstixel_1_1draw__line.html">draw_line</a> initializer struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e01279744eeb4269f160ec86986fe77" name="a0e01279744eeb4269f160ec86986fe77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e01279744eeb4269f160ec86986fe77">&#9670;&#160;</a></span>draw_line_aa() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::draw_line_aa </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>stroke_width</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0f</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw an antialiased line with variable stroke width. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.draw_line_aa(0, 0, 200, 100, constixel::color::WHITE, 3.0f);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x0</td><td>Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y0</td><td>Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">x1</td><td>Ending X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y1</td><td>Ending Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">col</td><td>Color palette index to use. </td></tr>
    <tr><td class="paramname">stroke_width</td><td>Width of the line in pixels (can be fractional). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8631ba50f2616a6643ddfcc5b2654f95" name="a8631ba50f2616a6643ddfcc5b2654f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8631ba50f2616a6643ddfcc5b2654f95">&#9670;&#160;</a></span>draw_string_aa() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;typename FONT, bool KERNING = false, text_rotation ROTATION = DEGREE_0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::draw_string_aa </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structconstixel_1_1draw__string.html">draw_string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>character_count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;size_t&gt;::max()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>character_actual</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw antialiased text at the specified coordinate. The template parameter selects which antialiased font to use. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. Typical use: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;some_font_aa.h&quot;</span></div>
<div class="line">...</div>
<div class="line">    <a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.draw_string_aa&lt;constixel::some_font_aa&gt;({.x=0, .y=0, .str=<span class="stringliteral">&quot;MyText&quot;</span>, .col=constixel::color::WHITE});</div>
<div class="line">...</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FONT</td><td>The font struct name. </td></tr>
    <tr><td class="paramname">KERNING</td><td>Boolean, use kerning information if available. Default to false. </td></tr>
    <tr><td class="paramname">ROTATION</td><td>Rotation around the x/y coordinate. Can be text_rotation::DEGREE_0, text_rotation::DEGREE_90, text_rotation::DEGREE_180 or text_rotation::DEGREE_270 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td><a class="el" href="structconstixel_1_1draw__string.html">draw_string</a> initializer struct. </td></tr>
    <tr><td class="paramname">character_count</td><td>How many utf32 characters in the string should be drawn. </td></tr>
    <tr><td class="paramname">character_actual</td><td>How many utf32 characters in the string were drawn. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the new caret X-coordinate position. Pass this value to the next <a class="el" href="structconstixel_1_1draw__string.html">draw_string</a> call to get continious text. </dd></dl>

</div>
</div>
<a id="a2aad41bd0f3533c054a7eed71770b032" name="a2aad41bd0f3533c054a7eed71770b032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aad41bd0f3533c054a7eed71770b032">&#9670;&#160;</a></span>draw_string_aa() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;typename FONT, bool KERNING = false, text_rotation ROTATION = DEGREE_0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::draw_string_aa </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>character_count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;size_t&gt;::max()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>character_actual</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw antialiased text at the specified coordinate. The template parameter selects which antialiased font to use. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. Typical use: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;some_font_aa.h&quot;</span></div>
<div class="line">...</div>
<div class="line">    <a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.draw_string_aa&lt;constixel::some_font_aa&gt;(0, 0, <span class="stringliteral">&quot;MyText&quot;</span>, constixel::color::WHITE);</div>
<div class="line">...</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FONT</td><td>The font struct name. </td></tr>
    <tr><td class="paramname">KERNING</td><td>Boolean, use kerning information if available. Default to false. </td></tr>
    <tr><td class="paramname">ROTATION</td><td>Rotation around the x/y coordinate. Can be text_rotation::DEGREE_0, text_rotation::DEGREE_90, text_rotation::DEGREE_180 or text_rotation::DEGREE_270 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">str</td><td>UTF-8 string. </td></tr>
    <tr><td class="paramname">col</td><td>Color palette index to use. </td></tr>
    <tr><td class="paramname">character_count</td><td>How many utf32 characters in the string should be drawn. </td></tr>
    <tr><td class="paramname">character_actual</td><td>How many utf32 characters in the string were drawn. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the new caret X-coordinate position. Pass this value to the next <a class="el" href="structconstixel_1_1draw__string.html">draw_string</a> call to get continious text. </dd></dl>

</div>
</div>
<a id="adfee593adfd9f5823b78be94464355ea" name="adfee593adfd9f5823b78be94464355ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfee593adfd9f5823b78be94464355ea">&#9670;&#160;</a></span>draw_string_centered_aa()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;typename FONT, bool KERNING = false, text_rotation ROTATION = DEGREE_0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::draw_string_centered_aa </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw antialiased text centered at the specified coordinate. The template parameter selects which antialiased font to use. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. Typical use. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FONT</td><td>The font struct name. </td></tr>
    <tr><td class="paramname">KERNING</td><td>Boolean, use kerning information if available. Default to false. </td></tr>
    <tr><td class="paramname">ROTATION</td><td>Rotation around the x/y coordinate. Can be text_rotation::DEGREE_0, text_rotation::DEGREE_90, text_rotation::DEGREE_180 or text_rotation::DEGREE_270 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Center/Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Center/Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">str</td><td>UTF-8 string. </td></tr>
    <tr><td class="paramname">col</td><td>Color palette index to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4328c1f5ae437305b827edbe102c39b" name="ac4328c1f5ae437305b827edbe102c39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4328c1f5ae437305b827edbe102c39b">&#9670;&#160;</a></span>draw_string_centered_mono()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;typename FONT, bool KERNING = false, text_rotation ROTATION = DEGREE_0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::draw_string_centered_mono </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw text centered at the specified coordinate. The template parameter selects which mono font to use. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FONT</td><td>The font struct name. </td></tr>
    <tr><td class="paramname">KERNING</td><td>Boolean, use kerning information if available. Default to false. </td></tr>
    <tr><td class="paramname">ROTATION</td><td>Rotation around the x/y coordinate. Can be text_rotation::DEGREE_0, text_rotation::DEGREE_90, text_rotation::DEGREE_180 or text_rotation::DEGREE_270 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Center/Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Center/Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">str</td><td>UTF-8 string. </td></tr>
    <tr><td class="paramname">col</td><td>Color palette index to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afae4f1f098da15436a1b6afee296957f" name="afae4f1f098da15436a1b6afee296957f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae4f1f098da15436a1b6afee296957f">&#9670;&#160;</a></span>draw_string_mono() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;typename FONT, bool KERNING = false, text_rotation ROTATION = DEGREE_0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::draw_string_mono </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structconstixel_1_1draw__string.html">draw_string</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>character_count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;size_t&gt;::max()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>character_actual</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw text at the specified coordinate. The template parameter selects which mono font to use. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;some_font_mono.h&quot;</span></div>
<div class="line">...</div>
<div class="line">    <a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.draw_string_mono&lt;constixel::some_font_mono&gt;({.x=0, .y=0, .str=<span class="stringliteral">&quot;MyText&quot;</span>, .col=constixel::color::WHITE});</div>
<div class="line">...</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FONT</td><td>The font struct name. </td></tr>
    <tr><td class="paramname">KERNING</td><td>Boolean, use kerning information if available. Default to false. </td></tr>
    <tr><td class="paramname">ROTATION</td><td>Rotation around the x/y coordinate. Defaults to text_rotation::DEGREE_0. Can be text_rotation::DEGREE_0, text_rotation::DEGREE_90, text_rotation::DEGREE_180 or text_rotation::DEGREE_270 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td><a class="el" href="structconstixel_1_1draw__string.html">draw_string</a> initializer struct. </td></tr>
    <tr><td class="paramname">character_count</td><td>How many utf32 characters in the string should be drawn. </td></tr>
    <tr><td class="paramname">character_actual</td><td>How many utf32 characters in the string were drawn. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the new caret X-coordinate position. Pass this value to the next <a class="el" href="structconstixel_1_1draw__string.html">draw_string</a> call to get continious text. </dd></dl>

</div>
</div>
<a id="a9d22da933c2402e72fa3972e156b5a9a" name="a9d22da933c2402e72fa3972e156b5a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d22da933c2402e72fa3972e156b5a9a">&#9670;&#160;</a></span>draw_string_mono() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;typename FONT, bool KERNING = false, text_rotation ROTATION = DEGREE_0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::draw_string_mono </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>character_count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;size_t&gt;::max()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>character_actual</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw text at the specified coordinate. The template parameter selects which mono font to use. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;some_font_mono.h&quot;</span></div>
<div class="line">...</div>
<div class="line">    <a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.draw_string_mono&lt;constixel::some_font_mono&gt;(0, 0, <span class="stringliteral">&quot;MyText&quot;</span>, constixel::color::WHITE);</div>
<div class="line">...</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FONT</td><td>The font struct name. </td></tr>
    <tr><td class="paramname">KERNING</td><td>Boolean, use kerning information if available. Default to false. </td></tr>
    <tr><td class="paramname">ROTATION</td><td>Rotation around the x/y coordinate. Defaults to text_rotation::DEGREE_0. Can be text_rotation::DEGREE_0, text_rotation::DEGREE_90, text_rotation::DEGREE_180 or text_rotation::DEGREE_270 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">str</td><td>UTF-8 string. </td></tr>
    <tr><td class="paramname">col</td><td>Color palette index to use. </td></tr>
    <tr><td class="paramname">character_count</td><td>How many utf32 characters in the string should be drawn. </td></tr>
    <tr><td class="paramname">character_actual</td><td>How many utf32 characters in the string were drawn. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the new caret X-coordinate position. Pass this value to the next <a class="el" href="structconstixel_1_1draw__string.html">draw_string</a> call to get continious text. </dd></dl>

</div>
</div>
<a id="a0a87723887cdf6ee391dc105ae909b74" name="a0a87723887cdf6ee391dc105ae909b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a87723887cdf6ee391dc105ae909b74">&#9670;&#160;</a></span>fill_circle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::fill_circle </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structconstixel_1_1draw__circle.html">draw_circle</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a circle with the specified radius and color. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.fill_circle({.cx=64, .cy=64, .r=32, .col=constixel::color::WHITE});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td><a class="el" href="structconstixel_1_1draw__circle.html">draw_circle</a> initializer struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28511dcf861e017c6f5fd5177fc41eea" name="a28511dcf861e017c6f5fd5177fc41eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28511dcf861e017c6f5fd5177fc41eea">&#9670;&#160;</a></span>fill_circle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::fill_circle </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>cx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>cy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a circle with the specified radius and color. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.fill_circle(64, 64, 32, constixel::color::WHITE);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cx</td><td>Center X-coordinate of the circle in pixels. </td></tr>
    <tr><td class="paramname">cy</td><td>Center Y-coordinate of the circle in pixels. </td></tr>
    <tr><td class="paramname">radius</td><td>radius of the circle in pixels. </td></tr>
    <tr><td class="paramname">col</td><td>Color palette index to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a704567ae39b38f2a151e72bf15446aaa" name="a704567ae39b38f2a151e72bf15446aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704567ae39b38f2a151e72bf15446aaa">&#9670;&#160;</a></span>fill_circle_aa() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::fill_circle_aa </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structconstixel_1_1draw__circle.html">draw_circle</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a circle using antialiasing with the specified radius and color. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.fill_circle_aa({.cx=64, .cy=64, .r=32, .col=constixel::color::WHITE});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td><a class="el" href="structconstixel_1_1draw__circle.html">draw_circle</a> initializer struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4768718b467fd140bea5dd9cba3a9bde" name="a4768718b467fd140bea5dd9cba3a9bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4768718b467fd140bea5dd9cba3a9bde">&#9670;&#160;</a></span>fill_circle_aa() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;typename shader_func&gt; <br />
requires std::is_invocable_r_v&lt;std::array&lt;float, 4&gt;, shader_func, float, float, int32_t, int32_t&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::fill_circle_aa </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>cx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>cy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shader_func &amp;</td>          <td class="paramname"><span class="paramname"><em>shader</em></span>&#160;) -&gt; void
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a circle using antialiasing with a shader function that generates colors per pixel. </p>
<div class="fragment"><div class="line"><span class="comment">// Radial gradient circle</span></div>
<div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.fill_circle_aa(100, 100, 50, [](<span class="keywordtype">float</span> u, <span class="keywordtype">float</span> v, <span class="keywordtype">float</span> au, <span class="keywordtype">float</span> av) -&gt; std::array&lt;float, 4&gt; {</div>
<div class="line">    <span class="keywordtype">float</span> dist = std::sqrt((u - 0.5f) * (u - 0.5f) + (v - 0.5f) * (v - 0.5f)) * 2.0f;</div>
<div class="line">    <span class="keywordtype">float</span> intensity = 1.0f - std::clamp(dist, 0.0f, 1.0f);</div>
<div class="line">    <span class="keywordflow">return</span> {intensity, intensity * 0.8f, 1.0f, 1.0f}; <span class="comment">// R, G, B, A</span></div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cx</td><td>Center X-coordinate of the circle in pixels. </td></tr>
    <tr><td class="paramname">cy</td><td>Center Y-coordinate of the circle in pixels. </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the circle in pixels. </td></tr>
    <tr><td class="paramname">shader</td><td>Lambda function taking (u, v, x, y) normalized coordinates and returning RGBA color as std::array&lt;float, 4&gt; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab208f46ba3fe196604efcd80a893037d" name="ab208f46ba3fe196604efcd80a893037d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab208f46ba3fe196604efcd80a893037d">&#9670;&#160;</a></span>fill_circle_aa() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::fill_circle_aa </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>cx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>cy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a circle using antialiasing with the specified radius and color. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.fill_circle_aa(64, 64, 32, constixel::color::WHITE);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cx</td><td>Center X-coordinate of the circle in pixels. </td></tr>
    <tr><td class="paramname">cy</td><td>Center Y-coordinate of the circle in pixels. </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the circle in pixels. </td></tr>
    <tr><td class="paramname">col</td><td>Color palette index to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e11fd05c71f1d708fc7c9694da42cb4" name="a8e11fd05c71f1d708fc7c9694da42cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e11fd05c71f1d708fc7c9694da42cb4">&#9670;&#160;</a></span>fill_rect() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::fill_rect </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structconstixel_1_1draw__rect.html">draw_rect</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a rectangle with the specified color. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.fill_rect({.x=0, .y=0, .w=320, .h=240, .col=constixel::color::WHITE});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td><a class="el" href="structconstixel_1_1draw__rect.html">draw_rect</a> initializer struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bdfd85b872f8751a759659d4eff25a8" name="a8bdfd85b872f8751a759659d4eff25a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bdfd85b872f8751a759659d4eff25a8">&#9670;&#160;</a></span>fill_rect() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;typename shader_func&gt; <br />
requires std::is_invocable_r_v&lt;std::array&lt;float, 4&gt;, shader_func, float, float, int32_t, int32_t&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::fill_rect </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shader_func &amp;</td>          <td class="paramname"><span class="paramname"><em>shader</em></span>&#160;) -&gt; void
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a rectangle with a shader function that generates colors per pixel. </p>
<div class="fragment"><div class="line"><span class="comment">// Linear gradient from red to blue</span></div>
<div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.fill_rect(0, 0, 320, 240, [](<span class="keywordtype">float</span> u, <span class="keywordtype">float</span> v, <span class="keywordtype">float</span> au, <span class="keywordtype">float</span> av) -&gt; std::array&lt;float, 4&gt; {</div>
<div class="line">    <span class="keywordflow">return</span> {1.0f - u, 0.0f, u, 1.0f}; <span class="comment">// R, G, B, A</span></div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">w</td><td>Width of the rectangle in pixels. </td></tr>
    <tr><td class="paramname">h</td><td>Height of the rectangle in pixels. </td></tr>
    <tr><td class="paramname">shader</td><td>Lambda function taking (u, v, x, y) normalized coordinates and returning RGBA color as std::array&lt;float, 4&gt; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8471a044d374d78ee28c6e92db9c810" name="ac8471a044d374d78ee28c6e92db9c810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8471a044d374d78ee28c6e92db9c810">&#9670;&#160;</a></span>fill_rect() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::fill_rect </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a rectangle with the specified color. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.fill_rect(0, 0, 320, 240, constixel::color::WHITE);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">w</td><td>Width of the rectangle in pixels. </td></tr>
    <tr><td class="paramname">h</td><td>Height of the rectangle in pixels. </td></tr>
    <tr><td class="paramname">col</td><td>Color palette index to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a089674f6110bd2585a3f60ff0ef68902" name="a089674f6110bd2585a3f60ff0ef68902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089674f6110bd2585a3f60ff0ef68902">&#9670;&#160;</a></span>fill_round_rect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::fill_round_rect </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structconstixel_1_1draw__round__rect.html">draw_round_rect</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a rounded rectangle with the specified color. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.fill_round_rect({.x=0, .y=0, .w=200, .h=100, .r=15, .col=constixel::color::WHITE});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td><a class="el" href="structconstixel_1_1draw__round__rect.html">draw_round_rect</a> initializer struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5844cba937476b93dfe6c51340fcb981" name="a5844cba937476b93dfe6c51340fcb981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5844cba937476b93dfe6c51340fcb981">&#9670;&#160;</a></span>fill_round_rect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::fill_round_rect </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a rounded rectangle with the specified color. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.fill_round_rect(0, 0, 200, 100, 15, constixel::color::WHITE);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">w</td><td>Width of the rectangle in pixels. </td></tr>
    <tr><td class="paramname">h</td><td>Height of the rectangle in pixels. </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the rounded corners in pixels. </td></tr>
    <tr><td class="paramname">col</td><td>Color palette index to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbb2f2c51431c5cb701544cf650bd222" name="adbb2f2c51431c5cb701544cf650bd222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb2f2c51431c5cb701544cf650bd222">&#9670;&#160;</a></span>fill_round_rect_aa() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::fill_round_rect_aa </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structconstixel_1_1draw__round__rect.html">draw_round_rect</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a rounded rectangle using antialiasing with the specified color. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.fill_round_rect_aa({.x=0, .y=0, .w=200, .h=100, .r=15, .col=constixel::color::WHITE, .sw=8});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td><a class="el" href="structconstixel_1_1draw__round__rect.html">draw_round_rect</a> initializer struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf1f475b57ae52a6d8810748f459bef2" name="abf1f475b57ae52a6d8810748f459bef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf1f475b57ae52a6d8810748f459bef2">&#9670;&#160;</a></span>fill_round_rect_aa() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;typename shader_func&gt; <br />
requires std::is_invocable_r_v&lt;std::array&lt;float, 4&gt;, shader_func, float, float, int32_t, int32_t&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::fill_round_rect_aa </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const shader_func &amp;</td>          <td class="paramname"><span class="paramname"><em>shader</em></span>&#160;) -&gt; void
        </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a rounded rectangle using antialiasing with a shader function that generates colors per pixel. </p>
<div class="fragment"><div class="line"><span class="comment">// Gradient rounded rectangle</span></div>
<div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.fill_round_rect_aa(10, 10, 200, 100, 15, [](<span class="keywordtype">float</span> u, <span class="keywordtype">float</span> v, <span class="keywordtype">float</span> au, <span class="keywordtype">float</span> av) -&gt; std::array&lt;float, 4&gt; {</div>
<div class="line">    <span class="keywordflow">return</span> {u, v, 1.0f - u, 1.0f}; <span class="comment">// Corner-to-corner gradient</span></div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">w</td><td>Width of the rectangle in pixels. </td></tr>
    <tr><td class="paramname">h</td><td>Height of the rectangle in pixels. </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the rounded corners in pixels. </td></tr>
    <tr><td class="paramname">shader</td><td>Lambda function taking (u, v, x, y) normalized coordinates and returning RGBA color as std::array&lt;float, 4&gt; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30759a93b9c30a313294435880a67cd3" name="a30759a93b9c30a313294435880a67cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30759a93b9c30a313294435880a67cd3">&#9670;&#160;</a></span>fill_round_rect_aa() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::fill_round_rect_aa </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill a rounded rectangle using antialiasing with the specified color. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.fill_round_rect_aa(0, 0, 200, 100, 15, constixel::color::WHITE);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">w</td><td>Width of the rectangle. </td></tr>
    <tr><td class="paramname">h</td><td>Height of the rectangle. </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the rounded corners. </td></tr>
    <tr><td class="paramname">col</td><td>Color palette index to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4ec91b659f6dd98ec2faf2d02685b49" name="ab4ec91b659f6dd98ec2faf2d02685b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ec91b659f6dd98ec2faf2d02685b49">&#9670;&#160;</a></span>get_nearest_color()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::get_nearest_color </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return closest match in the color palette based on the supplied red, green and blue values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Red value (0-255) </td></tr>
    <tr><td class="paramname">g</td><td>Green value (0-255) </td></tr>
    <tr><td class="paramname">b</td><td>Blue value (0-255) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The closest matching color palette index. </dd></dl>

</div>
</div>
<a id="ac70cd7b8050c46e68c4bc604978a9e0f" name="ac70cd7b8050c46e68c4bc604978a9e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70cd7b8050c46e68c4bc604978a9e0f">&#9670;&#160;</a></span>grayscale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::grayscale </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boolean indicating that the palette is grayscale instead of color. </p>
<dl class="section return"><dt>Returns</dt><dd>If true, the palette is grayscale. If false a colored palette is used. </dd></dl>

</div>
</div>
<a id="ac369f6e16d8a6d48a03aa309d7de199b" name="ac369f6e16d8a6d48a03aa309d7de199b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac369f6e16d8a6d48a03aa309d7de199b">&#9670;&#160;</a></span>height()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int32_t <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::height </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Height in pixels of the image. </p>
<dl class="section return"><dt>Returns</dt><dd>Height in pixels of the image. </dd></dl>

</div>
</div>
<a id="ab51a0777b177a683063de0d3eb7f5432" name="ab51a0777b177a683063de0d3eb7f5432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51a0777b177a683063de0d3eb7f5432">&#9670;&#160;</a></span>line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::line </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a line shape for fluent method chaining. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x0</td><td>Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y0</td><td>Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">x1</td><td>Ending X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y1</td><td>Ending Y-coordinate in pixels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A line shape object that supports .stroke() method. </dd></dl>

</div>
</div>
<a id="a02e1dd7fa89b3f77fc08a6c579888517" name="a02e1dd7fa89b3f77fc08a6c579888517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e1dd7fa89b3f77fc08a6c579888517">&#9670;&#160;</a></span>line_aa()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::line_aa </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an antialiased line shape for fluent method chaining. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x0</td><td>Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y0</td><td>Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">x1</td><td>Ending X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y1</td><td>Ending Y-coordinate in pixels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A line_aa shape object that supports .stroke() method. </dd></dl>

</div>
</div>
<a id="a704e5b47bb1d888a675027dc28575474" name="a704e5b47bb1d888a675027dc28575474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704e5b47bb1d888a675027dc28575474">&#9670;&#160;</a></span>plot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::plot </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structconstixel_1_1plot.html">plot</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Plot a single pixel at the specified coordinates using the supplied color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td><a class="el" href="structconstixel_1_1plot.html">plot</a> initializer struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac471aaf3c7fdb56059b20a58c5d6f596" name="ac471aaf3c7fdb56059b20a58c5d6f596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac471aaf3c7fdb56059b20a58c5d6f596">&#9670;&#160;</a></span>plot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::plot </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Plot a single pixel at the specified coordinates using the supplied color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">col</td><td>Color palette index to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76a5c4af0baf26d096b2f056249fa327" name="a76a5c4af0baf26d096b2f056249fa327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a5c4af0baf26d096b2f056249fa327">&#9670;&#160;</a></span>png()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;typename F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::png </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>char_out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the current instance into a png image. Typically an implementation looks like this: </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> some_container;</div>
<div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.png([=](<span class="keywordtype">char</span> ch) <span class="keyword">mutable</span> {</div>
<div class="line">   some_container.push_back(ch);</div>
<div class="line">});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">char_out</td><td>A lambda function which consumes the png image data one byte at a time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace9a4bc386268bfda228712d06974858" name="ace9a4bc386268bfda228712d06974858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9a4bc386268bfda228712d06974858">&#9670;&#160;</a></span>point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::point </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a point shape for fluent method chaining. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Y-coordinate in pixels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A point shape object that supports .<a class="el" href="#ac471aaf3c7fdb56059b20a58c5d6f596" title="Plot a single pixel at the specified coordinates using the supplied color.">plot()</a> method. </dd></dl>

</div>
</div>
<a id="aeb97c591957e1a59abc04e7c88c220bd" name="aeb97c591957e1a59abc04e7c88c220bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb97c591957e1a59abc04e7c88c220bd">&#9670;&#160;</a></span>rect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::rect </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>h</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fluent shape API methods for method chaining These provide a more expressive way to create shapes compared to struct-based calls. </p>
<p>Example usage: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.rect(10, 10, 50, 30).fill(constixel::color::RED).stroke(constixel::color::BLACK, 2);</div>
<div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.circle(100, 100, 20).fill(constixel::color::BLUE);</div>
<div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.line(0, 0, 100, 100).stroke(constixel::color::WHITE, 3);</div>
</div><!-- fragment --><p>Create a rectangle shape for fluent method chaining. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">w</td><td>Width of the rectangle in pixels. </td></tr>
    <tr><td class="paramname">h</td><td>Height of the rectangle in pixels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A rect shape object that supports .fill() and .stroke() methods. </dd></dl>

</div>
</div>
<a id="a93fa55bda11819a8a7d5d4ecf93e467c" name="a93fa55bda11819a8a7d5d4ecf93e467c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93fa55bda11819a8a7d5d4ecf93e467c">&#9670;&#160;</a></span>RGBA_uint32()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::RGBA_uint32 </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; uint32_t, W *H &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert this instance to an equivalent RGBA8 data array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>RGBA8 array made of <a class="el" href="#a13a20e73412dc283ed908959a31ebca6" title="Width in pixels of the image.">image::width()</a> * img::height() * uint32_t values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d84e2cd6d6ce5d34d8a187258182ddb" name="a3d84e2cd6d6ce5d34d8a187258182ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d84e2cd6d6ce5d34d8a187258182ddb">&#9670;&#160;</a></span>RGBA_uint8()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::RGBA_uint8 </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; uint8_t, W *H *4 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert this instance to an equivalent RGBA8 data array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>RGBA8 array made of <a class="el" href="#a13a20e73412dc283ed908959a31ebca6" title="Width in pixels of the image.">image::width()</a> * img::height() * 4 * uint8_t values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d2ab33c429c26a6dd7e8c5bcb4555f9" name="a9d2ab33c429c26a6dd7e8c5bcb4555f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2ab33c429c26a6dd7e8c5bcb4555f9">&#9670;&#160;</a></span>round_rect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::round_rect </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a rounded rectangle shape for fluent method chaining. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">w</td><td>Width of the rectangle in pixels. </td></tr>
    <tr><td class="paramname">h</td><td>Height of the rectangle in pixels. </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the rounded corners in pixels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A round_rect shape object that supports .fill() and .stroke() methods. </dd></dl>

</div>
</div>
<a id="a35fad144cfc9932aafb1875814ad7c27" name="a35fad144cfc9932aafb1875814ad7c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35fad144cfc9932aafb1875814ad7c27">&#9670;&#160;</a></span>round_rect_aa()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::round_rect_aa </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an antialiased rounded rectangle shape for fluent method chaining. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">w</td><td>Width of the rectangle in pixels. </td></tr>
    <tr><td class="paramname">h</td><td>Height of the rectangle in pixels. </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the rounded corners in pixels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A round_rect_aa shape object that supports .fill() and .stroke() methods. </dd></dl>

</div>
</div>
<a id="a5861d809e14823b71640b0104bdd46d1" name="a5861d809e14823b71640b0104bdd46d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5861d809e14823b71640b0104bdd46d1">&#9670;&#160;</a></span>sixel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;size_t S = 1, typename F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::sixel </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>char_out</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the current instance into a sixel stream. Typically an implementation looks like this: </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> some_container;</div>
<div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.sixel([=](<span class="keywordtype">char</span> ch) <span class="keyword">mutable</span> {</div>
<div class="line">   some_container.push_back(ch);</div>
<div class="line">});</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>scale of sixel output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">char_out</td><td>A lambda function which consumes the sixel stream data one byte at a time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07774a298459b7ec3e457ec4df27869e" name="a07774a298459b7ec3e457ec4df27869e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07774a298459b7ec3e457ec4df27869e">&#9670;&#160;</a></span>sixel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;size_t S = 1, typename F&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::sixel </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>char_out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structconstixel_1_1rect.html">rect</a>&lt; int32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rect</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the current instance into a sixel stream. Typically an implementation looks like this: </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> some_container;</div>
<div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.sixel({.x=0,.y=0,.w=100,.h=100},[=](<span class="keywordtype">char</span> ch) <span class="keyword">mutable</span> {</div>
<div class="line">   some_container.push_back(ch);</div>
<div class="line">});</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>scale of sixel output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">char_out</td><td>A lambda function which consumes the sixel stream data one byte at a time </td></tr>
    <tr><td class="paramname">rect</td><td>Clipping rectangle; to only show a portion of the image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a518612cc47067c27654de327cd9cb6b3" name="a518612cc47067c27654de327cd9cb6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518612cc47067c27654de327cd9cb6b3">&#9670;&#160;</a></span>sixel_to_cout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;size_t S = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::sixel_to_cout </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the current instance into a sixel stream and output it to std::cout. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">S</td><td>scale of sixel output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90a1147a9eb41bce05235d3f06c35415" name="a90a1147a9eb41bce05235d3f06c35415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a1147a9eb41bce05235d3f06c35415">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_t <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size in bytes of the image data. This does not include the image instance size. </p>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes of the image data. </dd></dl>

</div>
</div>
<a id="a091247becd0db982163215506223cbb5" name="a091247becd0db982163215506223cbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091247becd0db982163215506223cbb5">&#9670;&#160;</a></span>string_width()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;typename FONT, bool KERNING = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::string_width </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>character_count</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;size_t&gt;::max()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>character_actual</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the width of a string using the specified font in the template parameter. Typical use: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;some_font_aa.h&quot;</span></div>
<div class="line">...</div>
<div class="line">    int32_t <a class="code hl_function" href="#a13a20e73412dc283ed908959a31ebca6">width</a> = <a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.string_width&lt;constixel::some_font_aa&gt;();</div>
<div class="line">...</div>
<div class="ttc" id="aclassconstixel_1_1image_html_a13a20e73412dc283ed908959a31ebca6"><div class="ttname"><a href="#a13a20e73412dc283ed908959a31ebca6">constixel::image::width</a></div><div class="ttdeci">static constexpr int32_t width()</div><div class="ttdoc">Width in pixels of the image.</div><div class="ttdef"><b>Definition</b> constixel.hpp:3605</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FONT</td><td>The font struct name. </td></tr>
    <tr><td class="paramname">KERNING</td><td>Boolean, use kerning information if available. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>UTF-8 string. </td></tr>
    <tr><td class="paramname">character_count</td><td>How many utf32 characters in the string should be measured. </td></tr>
    <tr><td class="paramname">character_actual</td><td>How many utf32 characters in the string were measured. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Width of the string in pixels. </dd></dl>

</div>
</div>
<a id="a287bed8285be9c69e4d31c949108ecdc" name="a287bed8285be9c69e4d31c949108ecdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287bed8285be9c69e4d31c949108ecdc">&#9670;&#160;</a></span>stroke_circle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::stroke_circle </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structconstixel_1_1draw__circle.html">draw_circle</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stroke a circle with the specified radius and color. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.stroke_circle({.cx=64, .cy=64, .r=32, .col=constixel::color::WHITE, .sw=2});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td><a class="el" href="structconstixel_1_1draw__circle.html">draw_circle</a> initializer struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4708978ac33d52768e792ac9a2598950" name="a4708978ac33d52768e792ac9a2598950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4708978ac33d52768e792ac9a2598950">&#9670;&#160;</a></span>stroke_circle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::stroke_circle </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>cx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>cy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>stroke_width</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stroke a circle with the specified radius and color. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.stroke_circle(64, 64, 32, 4, constixel::color::WHITE);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cx</td><td>Center X-coordinate of the circle in pixels. </td></tr>
    <tr><td class="paramname">cy</td><td>Center Y-coordinate of the circle in pixels. </td></tr>
    <tr><td class="paramname">radius</td><td>radius of the circle in pixels. </td></tr>
    <tr><td class="paramname">col</td><td>Color palette index to use. </td></tr>
    <tr><td class="paramname">stroke_width</td><td>Width of the stroke in pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93aaff1ac1622010279e853869b9caed" name="a93aaff1ac1622010279e853869b9caed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93aaff1ac1622010279e853869b9caed">&#9670;&#160;</a></span>stroke_circle_aa() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::stroke_circle_aa </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structconstixel_1_1draw__circle.html">draw_circle</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stroke a circle using antialiasing with the specified radius and color. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.stroke_circle_aa({.cx=64, .cy=64, .r=32, .col=constixel::color::WHITE, .sw=2});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td><a class="el" href="structconstixel_1_1draw__circle.html">draw_circle</a> initializer struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a850a0605678f7f83f90e3c88a36182a1" name="a850a0605678f7f83f90e3c88a36182a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850a0605678f7f83f90e3c88a36182a1">&#9670;&#160;</a></span>stroke_circle_aa() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::stroke_circle_aa </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>cx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>cy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>stroke_width</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stroke a circle using antialiasing with the specified radius and color. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.stroke_circle_aa(64, 64, 32, constixel::color::WHITE, 2);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cx</td><td>Center X-coordinate of the circle in pixels. </td></tr>
    <tr><td class="paramname">cy</td><td>Center Y-coordinate of the circle in pixels. </td></tr>
    <tr><td class="paramname">radius</td><td>radius of the circle in pixels. </td></tr>
    <tr><td class="paramname">col</td><td>Color palette index to use. </td></tr>
    <tr><td class="paramname">stroke_width</td><td>Width of the stroke in pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd7002b66880a9fb7ee1850cd248dbab" name="afd7002b66880a9fb7ee1850cd248dbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7002b66880a9fb7ee1850cd248dbab">&#9670;&#160;</a></span>stroke_rect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::stroke_rect </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structconstixel_1_1draw__rect.html">draw_rect</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a stroked rectangle with the specified color and stroke width. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.stroke_rect({.x=0, .y=0, .w=320, .h=240, .col=constixel::color::WHITE, .sw=2});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td><a class="el" href="structconstixel_1_1draw__rect.html">draw_rect</a> initializer struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af693d6d18d59a5021009b7cb8f2c2df2" name="af693d6d18d59a5021009b7cb8f2c2df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af693d6d18d59a5021009b7cb8f2c2df2">&#9670;&#160;</a></span>stroke_rect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::stroke_rect </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>stroke_width</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draw a stroked rectangle with the specified color and stroke width. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.stroke_rect(0, 0, 320, 240, constixel::color::WHITE);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">w</td><td>Width of the rectangle in pixels. </td></tr>
    <tr><td class="paramname">h</td><td>Height of the rectangle in pixels. </td></tr>
    <tr><td class="paramname">col</td><td>Color palette index to use. </td></tr>
    <tr><td class="paramname">stroke_width</td><td>Width of the stroke in pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2189b7423ab1299b612e9e9cd784f107" name="a2189b7423ab1299b612e9e9cd784f107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2189b7423ab1299b612e9e9cd784f107">&#9670;&#160;</a></span>stroke_round_rect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::stroke_round_rect </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structconstixel_1_1draw__round__rect.html">draw_round_rect</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stroke a rounded rectangle with the specified color. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.stroke_round_rect({.x=0, .y=0, .w=200, .h=100, .r=15, .col=constixel::color::WHITE, .sw=8});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td><a class="el" href="structconstixel_1_1draw__round__rect.html">draw_round_rect</a> initializer struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4278b16aff84e29e63be021734e689a" name="ab4278b16aff84e29e63be021734e689a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4278b16aff84e29e63be021734e689a">&#9670;&#160;</a></span>stroke_round_rect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::stroke_round_rect </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>stroke_width</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stroke a rounded rectangle with the specified color. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.stroke_round_rect(0, 0, 200, 100, 15, constixel::color::WHITE);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">w</td><td>Width of the rectangle in pixels. </td></tr>
    <tr><td class="paramname">h</td><td>Height of the rectangle in pixels. </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the rounded corners in pixels. </td></tr>
    <tr><td class="paramname">col</td><td>Color palette index to use. </td></tr>
    <tr><td class="paramname">stroke_width</td><td>Width of the stroke in pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e44342138f69aac7082c2d853898cc8" name="a2e44342138f69aac7082c2d853898cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e44342138f69aac7082c2d853898cc8">&#9670;&#160;</a></span>stroke_round_rect_aa() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::stroke_round_rect_aa </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structconstixel_1_1draw__round__rect.html">draw_round_rect</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stroke a rounded rectangle using antialiasing with the specified color. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.stroke_round_rect_aa({.x=0, .y=0, .w=200, .h=100, .r=15, .col=constixel::color::WHITE, .sw=8});</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td><a class="el" href="structconstixel_1_1draw__round__rect.html">draw_round_rect</a> initializer struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb6ad4928abcd3a15b2c6f1ba3a1df8e" name="aeb6ad4928abcd3a15b2c6f1ba3a1df8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6ad4928abcd3a15b2c6f1ba3a1df8e">&#9670;&#160;</a></span>stroke_round_rect_aa() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::stroke_round_rect_aa </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>w</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>h</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>radius</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>stroke_width</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stroke a rounded rectangle using antialiasing with the specified color. Example: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac0b51b87a63b6e025df0b69221a88e01">image</a>.stroke_round_rect_aa(0, 0, 200, 100, 15, constixel::color::WHITE);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">w</td><td>Width of the rectangle in pixels. </td></tr>
    <tr><td class="paramname">h</td><td>Height of the rectangle in pixels. </td></tr>
    <tr><td class="paramname">radius</td><td>Radius of the rounded corners in pixels. </td></tr>
    <tr><td class="paramname">col</td><td>Color palette index to use. </td></tr>
    <tr><td class="paramname">stroke_width</td><td>Width of the stroke in pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a658bd0f0123994ca7b5ff4b2a154cac2" name="a658bd0f0123994ca7b5ff4b2a154cac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658bd0f0123994ca7b5ff4b2a154cac2">&#9670;&#160;</a></span>text_aa()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;typename FONT, bool KERNING = false, text_rotation ROTATION = DEGREE_0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::text_aa </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a text shape for fluent antialiased string drawing with method chaining. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FONT</td><td>The font type to use for rendering. </td></tr>
    <tr><td class="paramname">KERNING</td><td>Enable kerning if true (default: false). </td></tr>
    <tr><td class="paramname">ROTATION</td><td>Text rotation (default: DEGREE_0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">str</td><td>The string to draw. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A text_aa shape object that supports .color() and .draw() methods.</dd></dl>
<p>Example usage: </p><div class="fragment"><div class="line">img.text_aa&lt;constixel::ibmplexmono_regular_12_aa&gt;(10, 20, <span class="stringliteral">&quot;Hello&quot;</span>).color(constixel::color::WHITE);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3bb9d0db246e5f4b7514e0acb1617d73" name="a3bb9d0db246e5f4b7514e0acb1617d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb9d0db246e5f4b7514e0acb1617d73">&#9670;&#160;</a></span>text_centered_aa()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;typename FONT, bool KERNING = false, text_rotation ROTATION = DEGREE_0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::text_centered_aa </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a text shape for fluent centered antialiased string drawing with method chaining. Only <a class="el" href="classconstixel_1_1format__8bit.html" title="8-bit format, 256 colors total. Use as template parameter for image. Example:">format_8bit</a> targets are supported. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FONT</td><td>The font type to use for rendering. </td></tr>
    <tr><td class="paramname">KERNING</td><td>Enable kerning if true (default: false). </td></tr>
    <tr><td class="paramname">ROTATION</td><td>Text rotation (default: DEGREE_0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Center X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Center Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">str</td><td>The string to draw. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A text_centered_aa shape object that supports .color() method.</dd></dl>
<p>Example usage: </p><div class="fragment"><div class="line">img.text_centered_aa&lt;constixel::ibmplexmono_regular_12_aa&gt;(100, 50, <span class="stringliteral">&quot;Centered&quot;</span>).color(constixel::color::WHITE);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3a9e638c38059337f75611e458a4ec99" name="a3a9e638c38059337f75611e458a4ec99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9e638c38059337f75611e458a4ec99">&#9670;&#160;</a></span>text_centered_mono()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;typename FONT, bool KERNING = false, text_rotation ROTATION = DEGREE_0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::text_centered_mono </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a text shape for fluent centered monospace string drawing with method chaining. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FONT</td><td>The font type to use for rendering. </td></tr>
    <tr><td class="paramname">KERNING</td><td>Enable kerning if true (default: false). </td></tr>
    <tr><td class="paramname">ROTATION</td><td>Text rotation (default: DEGREE_0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Center X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Center Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">str</td><td>The string to draw. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A text_centered_mono shape object that supports .color() method.</dd></dl>
<p>Example usage: </p><div class="fragment"><div class="line">img.text_centered_mono&lt;constixel::ibmplexmono_regular_12_mono&gt;(100, 50,</div>
<div class="line"><span class="stringliteral">&quot;Centered&quot;</span>).color(constixel::color::WHITE);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5a73f0719efdcd7d467531ded4bd2104" name="a5a73f0719efdcd7d467531ded4bd2104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a73f0719efdcd7d467531ded4bd2104">&#9670;&#160;</a></span>text_mono()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;typename FONT, bool KERNING = false, text_rotation ROTATION = DEGREE_0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::text_mono </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a text shape for fluent monospace string drawing with method chaining. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FONT</td><td>The font type to use for rendering. </td></tr>
    <tr><td class="paramname">KERNING</td><td>Enable kerning if true (default: false). </td></tr>
    <tr><td class="paramname">ROTATION</td><td>Text rotation (default: DEGREE_0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Starting X-coordinate in pixels. </td></tr>
    <tr><td class="paramname">y</td><td>Starting Y-coordinate in pixels. </td></tr>
    <tr><td class="paramname">str</td><td>The string to draw. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A text_mono shape object that supports .color() and .draw() methods.</dd></dl>
<p>Example usage: </p><div class="fragment"><div class="line">img.text_mono&lt;constixel::ibmplexmono_regular_12_mono&gt;(10, 20, <span class="stringliteral">&quot;Hello&quot;</span>).color(constixel::color::WHITE);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a32ad81fbc0feb78c7f8857d42a685475" name="a32ad81fbc0feb78c7f8857d42a685475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ad81fbc0feb78c7f8857d42a685475">&#9670;&#160;</a></span>transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;bool FLIP_H = false, bool FLIP_V = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classconstixel_1_1image.html">image</a>&lt; T, H, W, GRAYSCALE &gt; <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a transposed version of this image. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FLIP_H</td><td>Flip image horizontally </td></tr>
    <tr><td class="paramname">FLIP_V</td><td>Flip image vertically </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0b8105e648df632543064a798b0405e" name="ab0b8105e648df632543064a798b0405e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b8105e648df632543064a798b0405e">&#9670;&#160;</a></span>transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<div class="memtemplate">
template&lt;bool FLIP_H = false, bool FLIP_V = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classconstixel_1_1image.html">image</a>&lt; T, H, W, GRAYSCALE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose this image into another. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FLIP_H</td><td>Flip image horizontally </td></tr>
    <tr><td class="paramname">FLIP_V</td><td>Flip image vertically </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13a20e73412dc283ed908959a31ebca6" name="a13a20e73412dc283ed908959a31ebca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a20e73412dc283ed908959a31ebca6">&#9670;&#160;</a></span>width()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; size_t, size_t, bool, bool &gt; class T, size_t W, size_t H, bool GRAYSCALE = false, bool USE_SPAN = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr int32_t <a class="el" href="classconstixel_1_1image.html">constixel::image</a>&lt; T, W, H, GRAYSCALE, USE_SPAN &gt;::width </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span><span class="mlabel nodiscard">nodiscard</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Width in pixels of the image. </p>
<dl class="section return"><dt>Returns</dt><dd>Width in pixels of the image. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="constixel_8hpp_source.html">constixel.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>constixel</b></li><li class="navelem"><a class="el" href="classconstixel_1_1image.html">image</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
