<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>constixel: /Users/turo/constixel/constixel.h</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">constixel
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('_2_users_2turo_2constixel_2constixel_8h-example.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">/Users/turo/constixel/constixel.h</div></div>
</div><!--header-->
<div class="contents">
<p>Fill a circle with the specified radius and color.</p>
<p>Fill a circle with the specified radius and color.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cx</td><td>Center x-coordinate of the circle in pixels. </td></tr>
    <tr><td class="paramname">cy</td><td>Center y-coordinate of the circle in pixels. </td></tr>
    <tr><td class="paramname">radius</td><td>radius of the circle in pixels. </td></tr>
    <tr><td class="paramname">col</td><td>Color palette index to use.</td></tr>
  </table>
  </dd>
</dl>
<p>image.fill_circle(100, 100, 50, colors::RED)</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment">MIT License</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">Copyright (c) 2025 Tinic Uro</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">Permission is hereby granted, free of charge, to any person obtaining a copy</span></div>
<div class="line"><span class="comment">of this software and associated documentation files (the &quot;Software&quot;), to deal</span></div>
<div class="line"><span class="comment">in the Software without restriction, including without limitation the rights</span></div>
<div class="line"><span class="comment">to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span></div>
<div class="line"><span class="comment">copies of the Software, and to permit persons to whom the Software is</span></div>
<div class="line"><span class="comment">furnished to do so, subject to the following conditions:</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">The above copyright notice and this permission notice shall be included in all</span></div>
<div class="line"><span class="comment">copies or substantial portions of the Software.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span></div>
<div class="line"><span class="comment">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span></div>
<div class="line"><span class="comment">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span></div>
<div class="line"><span class="comment">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span></div>
<div class="line"><span class="comment">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span></div>
<div class="line"><span class="comment">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span></div>
<div class="line"><span class="comment">SOFTWARE.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="preprocessor">#ifndef CONSTIXEL_H_</span></div>
<div class="line"><span class="preprocessor">#define CONSTIXEL_H_</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;array&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;bit&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;ctime&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;random&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;utility&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>constixel {</div>
<div class="line"></div>
<div class="line">[[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">float</span> fast_exp2(<span class="keyword">const</span> <span class="keywordtype">float</span> p) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> offset = (p &lt; 0) ? 1.0f : 0.0f;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> clipp = (p &lt; -126) ? -126.0f : p;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> z = clipp - <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(clipp)) + offset;</div>
<div class="line">    <span class="keywordflow">return</span> std::bit_cast&lt;float&gt;(<span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>((1 &lt;&lt; 23) * (clipp + 121.2740575f + 27.7280233f / (4.84252568f - z) - 1.49012907f * z)));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">[[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">float</span> fast_log2(<span class="keyword">const</span> <span class="keywordtype">float</span> x) {</div>
<div class="line">    uint32_t xi = std::bit_cast&lt;uint32_t&gt;(x);</div>
<div class="line">    <span class="keywordtype">float</span> xf = std::bit_cast&lt;float&gt;((xi &amp; 0x007FFFFF) | 0x3f000000);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> y = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(xi) * 1.1920928955078125e-7f;</div>
<div class="line">    <span class="keywordflow">return</span> y - 124.22551499f - 1.498030302f * xf - 1.72587999f / (0.3520887068f + xf);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">float</span> fast_sqrtf(<span class="keyword">const</span> <span class="keywordtype">float</span> x) {</div>
<div class="line">    int32_t i = std::bit_cast&lt;int&gt;(x);</div>
<div class="line">    <span class="keywordtype">int</span> k = i &amp; 0x00800000;</div>
<div class="line">    <span class="keywordtype">float</span> y;</div>
<div class="line">    <span class="keywordflow">if</span> (k != 0) {</div>
<div class="line">        i = 0x5ed9d098 - (i &gt;&gt; 1);</div>
<div class="line">        y = std::bit_cast&lt;float&gt;(i);</div>
<div class="line">        y = 2.33139729f * y * ((-x * y * y) + 1.07492042f);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        i = 0x5f19d352 - (i &gt;&gt; 1);</div>
<div class="line">        y = std::bit_cast&lt;float&gt;(i);</div>
<div class="line">        y = 0.82420468f * y * ((-x * y * y) + 2.14996147f);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">float</span> c = x * y;</div>
<div class="line">    <span class="keywordtype">float</span> r = ((y * -c) + 1.0f);</div>
<div class="line">    y = ((0.5f * c * r) + c);</div>
<div class="line">    <span class="keywordflow">return</span> y;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">[[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">float</span> fast_pow(<span class="keyword">const</span> <span class="keywordtype">float</span> x, <span class="keyword">const</span> <span class="keywordtype">float</span> p) {</div>
<div class="line">    <span class="keywordflow">return</span> fast_exp2(p * fast_log2(x));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">double</span> m_pi_d = 3.14159265358979323846;</div>
<div class="line"> </div>
<div class="line">[[nodiscard]] <span class="keyword">static</span> <span class="keyword">consteval</span> <span class="keywordtype">double</span> cos(<span class="keywordtype">double</span> x, int32_t terms = 10) {</div>
<div class="line">    x = x - 6.283185307179586 * <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(x / 6.283185307179586);  <span class="comment">// wrap x to [0, 2π)</span></div>
<div class="line">    <span class="keywordtype">double</span> res = 1.0, term = 1.0;</div>
<div class="line">    <span class="keywordtype">double</span> x2 = x * x;</div>
<div class="line">    <span class="keywordflow">for</span> (int32_t i = 1; i &lt; terms; ++i) {</div>
<div class="line">        term *= -x2 / ((2 * i - 1) * (2 * i));</div>
<div class="line">        res += term;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">[[nodiscard]] <span class="keyword">static</span> <span class="keyword">consteval</span> <span class="keywordtype">double</span> sin(<span class="keywordtype">double</span> x, int32_t terms = 10) {</div>
<div class="line">    x = x - 6.283185307179586 * <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(x / 6.283185307179586);  <span class="comment">// wrap x to [0, 2π)</span></div>
<div class="line">    <span class="keywordtype">double</span> res = x, term = x;</div>
<div class="line">    <span class="keywordtype">double</span> x2 = x * x;</div>
<div class="line">    <span class="keywordflow">for</span> (int32_t i = 1; i &lt; terms; ++i) {</div>
<div class="line">        term *= -x2 / ((2 * i) * (2 * i + 1));</div>
<div class="line">        res += term;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">[[nodiscard]] <span class="keyword">static</span> <span class="keyword">consteval</span> <span class="keywordtype">double</span> pow(<span class="keywordtype">double</span> base, <span class="keywordtype">double</span> exp, int32_t terms = 10) {</div>
<div class="line">    <span class="keywordflow">if</span> (base &lt;= 0.0)</div>
<div class="line">        <span class="keywordflow">return</span> (base == 0.0) ? 0.0 : 0.0 / 0.0;  <span class="comment">// NaN for negative base</span></div>
<div class="line">    <span class="keywordtype">double</span> ln = 0.0, y = (base - 1) / (base + 1);</div>
<div class="line">    <span class="keywordtype">double</span> y2 = y * y, num = y;</div>
<div class="line">    <span class="keywordflow">for</span> (int32_t i = 1; i &lt;= terms; ++i) {</div>
<div class="line">        ln += num / (2 * i - 1);</div>
<div class="line">        num *= y2;</div>
<div class="line">    }</div>
<div class="line">    ln *= 2;</div>
<div class="line">    <span class="keywordtype">double</span> res = 1.0, term = 1.0, x = exp * ln;</div>
<div class="line">    <span class="keywordflow">for</span> (int32_t i = 1; i &lt; terms; ++i) {</div>
<div class="line">        term *= x / i;</div>
<div class="line">        res += term;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>oklch {</div>
<div class="line">    <span class="keywordtype">double</span> l, c, h;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>oklab {</div>
<div class="line">    <span class="keywordtype">double</span> l, a, b;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>srgb {</div>
<div class="line">    <span class="keywordtype">double</span> r, g, b;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">[[nodiscard]] <span class="keyword">static</span> <span class="keyword">consteval</span> <span class="keywordtype">double</span> linear_to_srgb(<span class="keywordtype">double</span> c) {</div>
<div class="line">    <span class="keywordflow">if</span> (c &lt;= 0.0031308) {</div>
<div class="line">        <span class="keywordflow">return</span> 12.92 * c;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> 1.055 * pow(c, 1.0 / 2.4) - 0.055;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">[[nodiscard]] <span class="keyword">static</span> <span class="keyword">consteval</span> <span class="keywordtype">double</span> srgb_to_linear(<span class="keywordtype">double</span> s) {</div>
<div class="line">    <span class="keywordflow">if</span> (s &lt;= 0.040449936) {</div>
<div class="line">        <span class="keywordflow">return</span> s / 12.92;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> pow((s + 0.055) / 1.055, 2.4);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">[[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">float</span> linear_to_srgb(<span class="keywordtype">float</span> c) {</div>
<div class="line">    <span class="keywordflow">if</span> (c &lt;= 0.0031308f) {</div>
<div class="line">        <span class="keywordflow">return</span> 12.92f * c;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> 1.055f * fast_pow(c, 1.0f / 2.4f) - 0.055f;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">[[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">float</span> srgb_to_linear(<span class="keywordtype">float</span> s) {</div>
<div class="line">    <span class="keywordflow">if</span> (s &lt;= 0.040449936f) {</div>
<div class="line">        <span class="keywordflow">return</span> s / 12.92f;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> fast_pow((s + 0.055f) / 1.055f, 2.4f);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">[[nodiscard]] <span class="keyword">static</span> <span class="keyword">consteval</span> srgb oklab_to_srgb(<span class="keyword">const</span> oklab &amp;oklab) {</div>
<div class="line">    <span class="keywordtype">double</span> l = oklab.l;</div>
<div class="line">    <span class="keywordtype">double</span> a = oklab.a;</div>
<div class="line">    <span class="keywordtype">double</span> b = oklab.b;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> l_ = l + 0.3963377774 * a + 0.2158037573 * b;</div>
<div class="line">    <span class="keywordtype">double</span> m_ = l - 0.1055613458 * a - 0.0638541728 * b;</div>
<div class="line">    <span class="keywordtype">double</span> s_ = l - 0.0894841775 * a - 1.2914855480 * b;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> r = 4.0767416621 * l_ - 3.3077115913 * m_ + 0.2309699292 * s_;</div>
<div class="line">    <span class="keywordtype">double</span> g = -1.2684380046 * l_ + 2.6097574011 * m_ - 0.3413193965 * s_;</div>
<div class="line">    <span class="keywordtype">double</span> bl = -0.0041960863 * l_ - 0.7034186168 * m_ + 1.7076147031 * s_;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> {linear_to_srgb(std::max(0.0, std::min(1.0, r))), linear_to_srgb(std::max(0.0, std::min(1.0, g))), linear_to_srgb(std::max(0.0, std::min(1.0, bl)))};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">[[nodiscard]] <span class="keyword">static</span> <span class="keyword">consteval</span> oklab oklch_to_oklab(<span class="keyword">const</span> oklch &amp;oklch) {</div>
<div class="line">    <span class="keywordflow">return</span> {oklch.l, oklch.c * cos(oklch.h * m_pi_d / 180.0), oklch.c * sin(oklch.h * m_pi_d / 180.0)};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">float</span> epsilon_low = srgb_to_linear(0.5f / 255.f);</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">float</span> epsilon_high = srgb_to_linear(254.5f / 255.f);</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> S&gt;</div>
<div class="line"><span class="keyword">class </span>quantize {</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> palette_size = S;</div>
<div class="line">    <span class="keyword">const</span> std::array&lt;uint32_t, palette_size&gt; &amp;pal;</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> <span class="keyword">constexpr</span> quantize(<span class="keyword">const</span> std::array&lt;uint32_t, palette_size&gt; &amp;palette) : pal(palette) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; pal.size(); ++i) {</div>
<div class="line">            linearpal.at(i * 3 + 0) = srgb_to_linear(<span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>((pal[i] &gt;&gt; 16) &amp; 0xFF) * (1.0f / 255.0f));</div>
<div class="line">            linearpal.at(i * 3 + 1) = srgb_to_linear(<span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>((pal[i] &gt;&gt; 8) &amp; 0xFF) * (1.0f / 255.0f));</div>
<div class="line">            linearpal.at(i * 3 + 2) = srgb_to_linear(<span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>((pal[i] &gt;&gt; 0) &amp; 0xFF) * (1.0f / 255.0f));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] <span class="keyword">constexpr</span> uint8_t nearest(int32_t r, int32_t g, int32_t b)<span class="keyword"> const </span>{</div>
<div class="line">        int32_t best = 0, bestd = 1UL &lt;&lt; 30;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; pal.size(); ++i) {</div>
<div class="line">            int32_t dr = r - <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>((pal[i] &gt;&gt; 16) &amp; 0xFF);</div>
<div class="line">            int32_t dg = g - <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>((pal[i] &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line">            int32_t db = b - <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>((pal[i] &gt;&gt; 0) &amp; 0xFF);</div>
<div class="line">            int32_t d = dr * dr + dg * dg + db * db;</div>
<div class="line">            <span class="keywordflow">if</span> (d &lt; bestd) {</div>
<div class="line">                bestd = d;</div>
<div class="line">                best = <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(i);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(best);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::array&lt;float, palette_size * 3&gt; linearpal{};</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] <span class="keyword">constexpr</span> uint8_t nearest_linear(<span class="keywordtype">float</span> r, <span class="keywordtype">float</span> g, <span class="keywordtype">float</span> b)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordtype">size_t</span> best = 0;</div>
<div class="line">        <span class="keywordtype">float</span> bestd = 100.0f;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; pal.size(); ++i) {</div>
<div class="line">            <span class="keywordtype">float</span> dr = r - linearpal.at(i * 3 + 0);</div>
<div class="line">            <span class="keywordtype">float</span> dg = g - linearpal.at(i * 3 + 1);</div>
<div class="line">            <span class="keywordtype">float</span> db = b - linearpal.at(i * 3 + 2);</div>
<div class="line">            <span class="keywordtype">float</span> d = dr * dr + dg * dg + db * db;</div>
<div class="line">            <span class="keywordflow">if</span> (d &lt; bestd) {</div>
<div class="line">                bestd = d;</div>
<div class="line">                best = i;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(best);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> N, <span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>hextree {</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> T bitslices = ((<span class="keyword">sizeof</span>(T) * 8) / 4) - 1;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> child_nodes_n = 1UL &lt;&lt; 4;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> child_nodes_n_mask = child_nodes_n - 1;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span>node {</div>
<div class="line">        T child[child_nodes_n]{};</div>
<div class="line">        <span class="keyword">constexpr</span> node() {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;c : child) {</div>
<div class="line">                c = invalid;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> T invalid = std::numeric_limits&lt;T&gt;::max();</div>
<div class="line">    std::array&lt;node, N&gt; nodes{};</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] <span class="keyword">consteval</span> <span class="keywordtype">size_t</span> byte_size()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(node) * nodes.size();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    hextree(<span class="keyword">const</span> hextree &amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    hextree &amp;operator=(<span class="keyword">const</span> hextree &amp;) = <span class="keyword">delete</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">explicit</span> <span class="keyword">consteval</span> hextree() {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> NS&gt;</div>
<div class="line">    <span class="keyword">explicit</span> <span class="keyword">consteval</span> hextree(<span class="keyword">const</span> std::array&lt;std::pair&lt;T, T&gt;, NS&gt; &amp;in) {</div>
<div class="line">        nodes[0] = node{};</div>
<div class="line">        T node_cnt = 1;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> [key, val] : in) {</div>
<div class="line">            T idx = 0;</div>
<div class="line">            <span class="keywordflow">for</span> (T d = 0; d &lt; bitslices; d++) {</div>
<div class="line">                T nib = (key &gt;&gt; ((bitslices - d) * 4)) &amp; child_nodes_n_mask;</div>
<div class="line">                T next = nodes.at(idx).child[nib];</div>
<div class="line">                <span class="keywordflow">if</span> (next == invalid) {</div>
<div class="line">                    next = node_cnt;</div>
<div class="line">                    nodes.at(idx).child[nib] = next;</div>
<div class="line">                    node_cnt++;</div>
<div class="line">                }</div>
<div class="line">                idx = next;</div>
<div class="line">            }</div>
<div class="line">            nodes.at(idx).child[key &amp; child_nodes_n_mask] = val;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;std::<span class="keywordtype">size_t</span> NS&gt;</div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">consteval</span> T size(<span class="keyword">const</span> std::array&lt;std::pair&lt;T, T&gt;, NS&gt; &amp;in) {</div>
<div class="line">        std::vector&lt;node&gt; vnodes{1};</div>
<div class="line">        vnodes.assign(1, node{});</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> [key, val] : in) {</div>
<div class="line">            T idx = 0;</div>
<div class="line">            <span class="keywordflow">for</span> (T d = 0; d &lt; bitslices; d++) {</div>
<div class="line">                T nib = (key &gt;&gt; ((bitslices - d) * 4)) &amp; child_nodes_n_mask;</div>
<div class="line">                T next = vnodes.at(idx).child[nib];</div>
<div class="line">                <span class="keywordflow">if</span> (next == invalid) {</div>
<div class="line">                    next = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(vnodes.size());</div>
<div class="line">                    vnodes.at(idx).child[nib] = next;</div>
<div class="line">                    vnodes.emplace_back();</div>
<div class="line">                }</div>
<div class="line">                idx = next;</div>
<div class="line">            }</div>
<div class="line">            vnodes.at(idx).child[key &amp; child_nodes_n_mask] = val;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(vnodes.size());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] <span class="keyword">constexpr</span> T lookup(T key)<span class="keyword"> const </span>{</div>
<div class="line">        T idx = 0;</div>
<div class="line">        <span class="keywordflow">for</span> (T d = 0; d &lt; bitslices; ++d) {</div>
<div class="line">            T nib = (key &gt;&gt; ((bitslices - d) * 4)) &amp; child_nodes_n_mask;</div>
<div class="line">            T next = nodes.at(idx).child[nib];</div>
<div class="line">            <span class="keywordflow">if</span> (next == invalid) {</div>
<div class="line">                <span class="keywordflow">return</span> invalid;</div>
<div class="line">            }</div>
<div class="line">            idx = next;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> nodes.at(idx).child[key &amp; child_nodes_n_mask];</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>char_info {</div>
<div class="line">    int16_t x;</div>
<div class="line">    int16_t y;</div>
<div class="line">    int16_t width;</div>
<div class="line">    int16_t height;</div>
<div class="line">    int16_t xadvance;</div>
<div class="line">    int16_t xoffset;</div>
<div class="line">    int16_t yoffset;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>rect {</div>
<div class="line">    T <a id="a0" name="a0"></a><a class="code hl_variable" href="structconstixel_1_1rect.html#a156f2f03834d55de7c7962a51da78977">x</a> = 0;  </div>
<div class="line">    T <a id="a1" name="a1"></a><a class="code hl_variable" href="structconstixel_1_1rect.html#af254baaf7a70c829f943a262d290314a">y</a> = 0;  </div>
<div class="line">    T <a id="a2" name="a2"></a><a class="code hl_variable" href="structconstixel_1_1rect.html#ae1291bf45c485a7e14fa6e9d1fd5567f">w</a> = 0;  </div>
<div class="line">    T <a id="a3" name="a3"></a><a class="code hl_variable" href="structconstixel_1_1rect.html#a29cbd851b77f1651a9ffe762d6bf183a">h</a> = 0;  </div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> rect <a id="a4" name="a4"></a><a class="code hl_function" href="structconstixel_1_1rect.html#aa8f18249ed87d97bd57312a2c5e2bc50">operator&amp;</a>(<span class="keyword">const</span> rect &amp;other)<span class="keyword"> const </span>{</div>
<div class="line">        T nax = std::max(<a class="code hl_variable" href="structconstixel_1_1rect.html#a156f2f03834d55de7c7962a51da78977">x</a>, other.x);</div>
<div class="line">        T nay = std::max(<a class="code hl_variable" href="structconstixel_1_1rect.html#af254baaf7a70c829f943a262d290314a">y</a>, other.y);</div>
<div class="line">        T nix = std::min(<a class="code hl_variable" href="structconstixel_1_1rect.html#a156f2f03834d55de7c7962a51da78977">x</a> + <a class="code hl_variable" href="structconstixel_1_1rect.html#ae1291bf45c485a7e14fa6e9d1fd5567f">w</a>, other.x + other.w);</div>
<div class="line">        T niy = std::min(<a class="code hl_variable" href="structconstixel_1_1rect.html#a156f2f03834d55de7c7962a51da78977">x</a> + <a class="code hl_variable" href="structconstixel_1_1rect.html#a29cbd851b77f1651a9ffe762d6bf183a">h</a>, other.y + other.h);</div>
<div class="line">        <span class="keywordflow">return</span> {nax, nay, nix - nax, niy - nay};</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> rect &amp;<a id="a5" name="a5"></a><a class="code hl_function" href="structconstixel_1_1rect.html#a5a27f1ea794be5401b2d9bc9cff20e5d">operator&amp;=</a>(<span class="keyword">const</span> rect &amp;other) {</div>
<div class="line">        T nax = std::max(<a class="code hl_variable" href="structconstixel_1_1rect.html#a156f2f03834d55de7c7962a51da78977">x</a>, other.x);</div>
<div class="line">        T nay = std::max(<a class="code hl_variable" href="structconstixel_1_1rect.html#af254baaf7a70c829f943a262d290314a">y</a>, other.y);</div>
<div class="line">        T nix = std::min(<a class="code hl_variable" href="structconstixel_1_1rect.html#a156f2f03834d55de7c7962a51da78977">x</a> + <a class="code hl_variable" href="structconstixel_1_1rect.html#ae1291bf45c485a7e14fa6e9d1fd5567f">w</a>, other.x + other.w);</div>
<div class="line">        T niy = std::min(<a class="code hl_variable" href="structconstixel_1_1rect.html#a156f2f03834d55de7c7962a51da78977">x</a> + <a class="code hl_variable" href="structconstixel_1_1rect.html#a29cbd851b77f1651a9ffe762d6bf183a">h</a>, other.y + other.h);</div>
<div class="line">        <a class="code hl_variable" href="structconstixel_1_1rect.html#a156f2f03834d55de7c7962a51da78977">x</a> = nax;</div>
<div class="line">        <a class="code hl_variable" href="structconstixel_1_1rect.html#af254baaf7a70c829f943a262d290314a">y</a> = nay;</div>
<div class="line">        <a class="code hl_variable" href="structconstixel_1_1rect.html#ae1291bf45c485a7e14fa6e9d1fd5567f">w</a> = nix - nax;</div>
<div class="line">        <a class="code hl_variable" href="structconstixel_1_1rect.html#a29cbd851b77f1651a9ffe762d6bf183a">h</a> = niy - nay;</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>format {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t adler32(<span class="keyword">const</span> uint8_t *data, std::size_t len, uint32_t adler32_sum) {</div>
<div class="line">        uint32_t adler32_s1 = adler32_sum &amp; 0xFFFF;</div>
<div class="line">        uint32_t adler32_s2 = adler32_sum &gt;&gt; 16;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = 0; c &lt; len; c++) {</div>
<div class="line">            adler32_s1 = (adler32_s1 + data[c]) % 65521;</div>
<div class="line">            adler32_s2 = (adler32_s2 + adler32_s1) % 65521;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> ((adler32_s2 &lt;&lt; 16) | adler32_s1);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//@private</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> png_write_be(F &amp;&amp;char_out, uint32_t value) {</div>
<div class="line">        char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((value &gt;&gt; 24) &amp; 0xFF));</div>
<div class="line">        char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((value &gt;&gt; 16) &amp; 0xFF));</div>
<div class="line">        char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((value &gt;&gt; 8) &amp; 0xFF));</div>
<div class="line">        char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((value &gt;&gt; 0) &amp; 0xFF));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> A&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> png_write_crc32(F &amp;&amp;char_out, <span class="keyword">const</span> A &amp;array, <span class="keywordtype">size_t</span> bytes) {</div>
<div class="line">        <span class="keywordtype">size_t</span> idx = 0;</div>
<div class="line">        uint32_t crc = 0xFFFFFFFF;</div>
<div class="line">        <span class="keywordtype">size_t</span> len = bytes;</div>
<div class="line">        <span class="keywordflow">while</span> (len--) {</div>
<div class="line">            uint8_t d = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(array.at(idx++));</div>
<div class="line">            crc ^= d;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 8; ++i) {</div>
<div class="line">                crc = (crc &amp; 1) ? (crc &gt;&gt; 1) ^ 0xEDB88320u : crc &gt;&gt; 1;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        png_write_be(char_out, crc ^ 0xFFFFFFFF);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> A&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> png_write_array(F &amp;&amp;char_out, <span class="keyword">const</span> A &amp;array, <span class="keywordtype">size_t</span> bytes) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = 0; c &lt; bytes; c++) {</div>
<div class="line">            char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(array.at(c)));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> png_marker(F &amp;&amp;char_out) {</div>
<div class="line">        char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(0x89));</div>
<div class="line">        char_out(0x50);</div>
<div class="line">        char_out(0x4E);</div>
<div class="line">        char_out(0x47);</div>
<div class="line">        char_out(0x0D);</div>
<div class="line">        char_out(0x0A);</div>
<div class="line">        char_out(0x1A);</div>
<div class="line">        char_out(0x0A);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> png_header(F &amp;&amp;char_out, <span class="keywordtype">size_t</span> w, <span class="keywordtype">size_t</span> h, <span class="keywordtype">size_t</span> depth) {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">size_t</span> chunkLength = 17;</div>
<div class="line">        std::array&lt;char, chunkLength&gt; header;</div>
<div class="line">        uint32_t i = 0;</div>
<div class="line">        header.at(i++) = <span class="charliteral">&#39;I&#39;</span>;</div>
<div class="line">        header.at(i++) = <span class="charliteral">&#39;H&#39;</span>;</div>
<div class="line">        header.at(i++) = <span class="charliteral">&#39;D&#39;</span>;</div>
<div class="line">        header.at(i++) = <span class="charliteral">&#39;R&#39;</span>;</div>
<div class="line">        header.at(i++) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((w &gt;&gt; 24) &amp; 0xFF);</div>
<div class="line">        header.at(i++) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((w &gt;&gt; 16) &amp; 0xFF);</div>
<div class="line">        header.at(i++) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((w &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line">        header.at(i++) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((w &gt;&gt; 0) &amp; 0xFF);</div>
<div class="line">        header.at(i++) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((h &gt;&gt; 24) &amp; 0xFF);</div>
<div class="line">        header.at(i++) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((h &gt;&gt; 16) &amp; 0xFF);</div>
<div class="line">        header.at(i++) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((h &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line">        header.at(i++) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((h &gt;&gt; 0) &amp; 0xFF);</div>
<div class="line">        header.at(i++) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(depth);</div>
<div class="line">        header.at(i++) = 3;</div>
<div class="line">        header.at(i++) = 0;</div>
<div class="line">        header.at(i++) = 0;</div>
<div class="line">        header.at(i++) = 0;</div>
<div class="line">        png_write_be(char_out, i - 4);</div>
<div class="line">        png_write_array(char_out, header, i);</div>
<div class="line">        png_write_crc32(char_out, header, i);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> P&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> png_palette(F &amp;&amp;char_out, <span class="keyword">const</span> P &amp;palette) {</div>
<div class="line">        std::array&lt;char, 256 * 3 + 4&gt; header;</div>
<div class="line">        uint32_t i = 0;</div>
<div class="line">        header.at(i++) = <span class="charliteral">&#39;P&#39;</span>;</div>
<div class="line">        header.at(i++) = <span class="charliteral">&#39;L&#39;</span>;</div>
<div class="line">        header.at(i++) = <span class="charliteral">&#39;T&#39;</span>;</div>
<div class="line">        header.at(i++) = <span class="charliteral">&#39;E&#39;</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = 0; c &lt; palette.size(); c++) {</div>
<div class="line">            header.at(i++) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((palette[c] &gt;&gt; 16) &amp; 0xFF);</div>
<div class="line">            header.at(i++) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((palette[c] &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line">            header.at(i++) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((palette[c] &gt;&gt; 0) &amp; 0xFF);</div>
<div class="line">        }</div>
<div class="line">        png_write_be(char_out, i - 4);</div>
<div class="line">        png_write_array(char_out, header, i);</div>
<div class="line">        png_write_crc32(char_out, header, i);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> png_end(F &amp;&amp;char_out) {</div>
<div class="line">        std::array&lt;char, 4&gt; header;</div>
<div class="line">        uint32_t i = 0;</div>
<div class="line">        header.at(i++) = <span class="charliteral">&#39;I&#39;</span>;</div>
<div class="line">        header.at(i++) = <span class="charliteral">&#39;E&#39;</span>;</div>
<div class="line">        header.at(i++) = <span class="charliteral">&#39;N&#39;</span>;</div>
<div class="line">        header.at(i++) = <span class="charliteral">&#39;D&#39;</span>;</div>
<div class="line">        png_write_be(char_out, i - 4);</div>
<div class="line">        png_write_array(char_out, header, i);</div>
<div class="line">        png_write_crc32(char_out, header, i);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> png_idat_zlib_header(F &amp;&amp;char_out) {</div>
<div class="line">        std::array&lt;char, 6&gt; header;</div>
<div class="line">        uint32_t i = 0;</div>
<div class="line">        header.at(i++) = <span class="charliteral">&#39;I&#39;</span>;</div>
<div class="line">        header.at(i++) = <span class="charliteral">&#39;D&#39;</span>;</div>
<div class="line">        header.at(i++) = <span class="charliteral">&#39;A&#39;</span>;</div>
<div class="line">        header.at(i++) = <span class="charliteral">&#39;T&#39;</span>;</div>
<div class="line">        header.at(i++) = 0x78;</div>
<div class="line">        header.at(i++) = 0x01;</div>
<div class="line">        png_write_be(char_out, i - 4);</div>
<div class="line">        png_write_array(char_out, header, i);</div>
<div class="line">        png_write_crc32(char_out, header, i);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> uint32_t png_idat_zlib_stream(F &amp;&amp;char_out, <span class="keyword">const</span> uint8_t *line, <span class="keywordtype">size_t</span> bytes, uint32_t adler32_sum) {</div>
<div class="line">        <span class="keywordflow">while</span> (bytes &gt; 0) {</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">size_t</span> max_data_use = 1024;</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">size_t</span> extra_data = 24;</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">size_t</span> max_stack_use = max_data_use + extra_data;</div>
<div class="line">            std::array&lt;uint8_t, max_stack_use&gt; header;</div>
<div class="line"> </div>
<div class="line">            uint32_t i = 0;</div>
<div class="line">            header.at(i++) = <span class="charliteral">&#39;I&#39;</span>;</div>
<div class="line">            header.at(i++) = <span class="charliteral">&#39;D&#39;</span>;</div>
<div class="line">            header.at(i++) = <span class="charliteral">&#39;A&#39;</span>;</div>
<div class="line">            header.at(i++) = <span class="charliteral">&#39;T&#39;</span>;</div>
<div class="line">            header.at(i++) = 0x00;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordtype">size_t</span> bytes_to_copy = std::min(<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(max_data_use), bytes);</div>
<div class="line">            header.at(i++) = (((bytes_to_copy + 1) &gt;&gt; 0) &amp; 0xFF);</div>
<div class="line">            header.at(i++) = (((bytes_to_copy + 1) &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line">            header.at(i++) = ((((bytes_to_copy + 1) ^ 0xffff) &gt;&gt; 0) &amp; 0xFF);</div>
<div class="line">            header.at(i++) = ((((bytes_to_copy + 1) ^ 0xffff) &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line"> </div>
<div class="line">            uint32_t adlersum32_start_pos = i;</div>
<div class="line">            header.at(i++) = 0;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = 0; c &lt; bytes_to_copy; c++) {</div>
<div class="line">                header.at(i++) = line[c];</div>
<div class="line">            }</div>
<div class="line">            adler32_sum = adler32(&amp;header[adlersum32_start_pos], i - adlersum32_start_pos, adler32_sum);</div>
<div class="line"> </div>
<div class="line">            png_write_be(char_out, i - 4);</div>
<div class="line">            png_write_array(char_out, header, i);</div>
<div class="line">            png_write_crc32(char_out, header, i);</div>
<div class="line"> </div>
<div class="line">            bytes -= bytes_to_copy;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> adler32_sum;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> png_idat_zlib_trailer(F &amp;&amp;char_out, uint32_t adler32_sum) {</div>
<div class="line">        std::array&lt;char, 8&gt; header;</div>
<div class="line">        uint32_t i = 0;</div>
<div class="line">        header.at(i++) = <span class="charliteral">&#39;I&#39;</span>;</div>
<div class="line">        header.at(i++) = <span class="charliteral">&#39;D&#39;</span>;</div>
<div class="line">        header.at(i++) = <span class="charliteral">&#39;A&#39;</span>;</div>
<div class="line">        header.at(i++) = <span class="charliteral">&#39;T&#39;</span>;</div>
<div class="line">        header.at(i++) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((adler32_sum &gt;&gt; 24) &amp; 0xFF);</div>
<div class="line">        header.at(i++) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((adler32_sum &gt;&gt; 16) &amp; 0xFF);</div>
<div class="line">        header.at(i++) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((adler32_sum &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line">        header.at(i++) = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>((adler32_sum &gt;&gt; 0) &amp; 0xFF);</div>
<div class="line">        png_write_be(char_out, i - 4);</div>
<div class="line">        png_write_array(char_out, header, i);</div>
<div class="line">        png_write_crc32(char_out, header, i);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> sixel_header(F &amp;&amp;char_out) {</div>
<div class="line">        char_out(0x1b);</div>
<div class="line">        char_out(<span class="charliteral">&#39;P&#39;</span>);</div>
<div class="line">        char_out(<span class="charliteral">&#39;0&#39;</span>);</div>
<div class="line">        char_out(<span class="charliteral">&#39;;&#39;</span>);</div>
<div class="line">        char_out(<span class="charliteral">&#39;1&#39;</span>);</div>
<div class="line">        char_out(<span class="charliteral">&#39;;&#39;</span>);</div>
<div class="line">        char_out(<span class="charliteral">&#39;0&#39;</span>);</div>
<div class="line">        char_out(<span class="charliteral">&#39;q&#39;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> W, <span class="keywordtype">size_t</span> H, <span class="keywordtype">size_t</span> S, <span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> sixel_raster_attributes(F &amp;&amp;char_out) {</div>
<div class="line">        char_out(<span class="charliteral">&#39;\&quot;&#39;</span>);</div>
<div class="line">        sixel_number(char_out, 2);</div>
<div class="line">        char_out(<span class="charliteral">&#39;;&#39;</span>);</div>
<div class="line">        sixel_number(char_out, 2);</div>
<div class="line">        char_out(<span class="charliteral">&#39;;&#39;</span>);</div>
<div class="line">        sixel_number(char_out, W * S);</div>
<div class="line">        char_out(<span class="charliteral">&#39;;&#39;</span>);</div>
<div class="line">        sixel_number(char_out, H * S);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> sixel_number(F &amp;&amp;char_out, uint16_t u) {</div>
<div class="line">        <span class="keywordflow">if</span> (u &lt; 10) {</div>
<div class="line">            char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(<span class="charliteral">&#39;0&#39;</span> + u));</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (u &lt; 100) {</div>
<div class="line">            char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(<span class="charliteral">&#39;0&#39;</span> + (((u / 10) % 10))));</div>
<div class="line">            char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(<span class="charliteral">&#39;0&#39;</span> + (u % 10)));</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (u &lt; 1000) {</div>
<div class="line">            char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(<span class="charliteral">&#39;0&#39;</span> + ((u / 100) % 10)));</div>
<div class="line">            char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(<span class="charliteral">&#39;0&#39;</span> + ((u / 10) % 10)));</div>
<div class="line">            char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(<span class="charliteral">&#39;0&#39;</span> + (u % 10)));</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (u &lt; 10000) {</div>
<div class="line">            char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(<span class="charliteral">&#39;0&#39;</span> + ((u / 1000) % 10)));</div>
<div class="line">            char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(<span class="charliteral">&#39;0&#39;</span> + ((u / 100) % 10)));</div>
<div class="line">            char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(<span class="charliteral">&#39;0&#39;</span> + ((u / 10) % 10)));</div>
<div class="line">            char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(<span class="charliteral">&#39;0&#39;</span> + (u % 10)));</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(<span class="charliteral">&#39;0&#39;</span> + ((u / 10000) % 10)));</div>
<div class="line">            char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(<span class="charliteral">&#39;0&#39;</span> + ((u / 1000) % 10)));</div>
<div class="line">            char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(<span class="charliteral">&#39;0&#39;</span> + ((u / 100) % 10)));</div>
<div class="line">            char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(<span class="charliteral">&#39;0&#39;</span> + ((u / 10) % 10)));</div>
<div class="line">            char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(<span class="charliteral">&#39;0&#39;</span> + (u % 10)));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> sixel_color(F &amp;&amp;char_out, uint16_t i, uint32_t col) {</div>
<div class="line">        char_out(<span class="charliteral">&#39;#&#39;</span>);</div>
<div class="line">        sixel_number(char_out, i);</div>
<div class="line">        char_out(<span class="charliteral">&#39;;&#39;</span>);</div>
<div class="line">        char_out(<span class="charliteral">&#39;2&#39;</span>);</div>
<div class="line">        char_out(<span class="charliteral">&#39;;&#39;</span>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = 0; c &lt; 3; c++) {</div>
<div class="line">            sixel_number(char_out, <span class="keyword">static_cast&lt;</span>uint16_t<span class="keyword">&gt;</span>((((col &gt;&gt; (8 * (2 - c))) &amp; 0xFF) * 100) / 255));</div>
<div class="line">            char_out(<span class="charliteral">&#39;;&#39;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> sixel_end(F &amp;&amp;char_out) {</div>
<div class="line">        char_out(0x1b);</div>
<div class="line">        char_out(<span class="charliteral">&#39;\\&#39;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PBT, <span class="keywordtype">size_t</span> PBS&gt;</div>
<div class="line">    <span class="keyword">struct </span>palette_bitset {</div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keywordtype">void</span> mark(PBT col) {</div>
<div class="line">            PBT idx = (col &gt;&gt; 5) &amp; set_idx_mask;</div>
<div class="line">            set[idx] |= 1UL &lt;&lt; (col &amp; 0x1F);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">constexpr</span> <span class="keywordtype">void</span> clear() {</div>
<div class="line">            set.fill(0);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        [[nodiscard]] <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> genstack(std::array&lt;PBT, PBS&gt; &amp;stack)<span class="keyword"> const </span>{</div>
<div class="line">            <span class="keywordtype">size_t</span> count = 0;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = 0; c &lt; PBS / 32; c++) {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; 32; d++) {</div>
<div class="line">                    <span class="keywordflow">if</span> ((set[c] &gt;&gt; d) &amp; 1) {</div>
<div class="line">                        stack.at(count++) = <span class="keyword">static_cast&lt;</span>PBT<span class="keyword">&gt;</span>(c * 32 + d);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> count;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        std::array&lt;uint32_t, PBS / 32&gt; set{};</div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> set_idx_mask = (1UL &lt;&lt; <span class="keyword">sizeof</span>(set) / 4) - 1;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> W, <span class="keywordtype">size_t</span> H, <span class="keywordtype">int</span>32_t S, <span class="keyword">typename</span> PBT, <span class="keywordtype">size_t</span> PBS, <span class="keyword">typename</span> P, <span class="keyword">typename</span> F, <span class="keyword">typename</span> L&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> png_image(<span class="keyword">const</span> uint8_t *data, <span class="keyword">const</span> P &amp;palette, F &amp;&amp;char_out, <span class="keyword">const</span> L &amp;line_ptr) {</div>
<div class="line">        png_marker(char_out);</div>
<div class="line">        png_header(char_out, W, H, PBS);</div>
<div class="line">        png_palette(char_out, palette);</div>
<div class="line">        png_idat_zlib_header(char_out);</div>
<div class="line">        uint32_t adler32_sum = 1;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; H; y++) {</div>
<div class="line">            <span class="keywordtype">size_t</span> bpl = 0;</div>
<div class="line">            <span class="keyword">const</span> uint8_t *ptr = line_ptr(data, y, bpl);</div>
<div class="line">            adler32_sum = png_idat_zlib_stream(char_out, ptr, bpl, adler32_sum);</div>
<div class="line">        }</div>
<div class="line">        png_idat_zlib_trailer(char_out, adler32_sum);</div>
<div class="line">        png_end(char_out);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> W, <span class="keywordtype">size_t</span> H, <span class="keywordtype">int</span>32_t S, <span class="keyword">typename</span> PBT, <span class="keywordtype">size_t</span> PBS, <span class="keyword">typename</span> P, <span class="keyword">typename</span> F, <span class="keyword">typename</span> C, <span class="keyword">typename</span> D&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> sixel_image(<span class="keyword">const</span> uint8_t *data, <span class="keyword">const</span> P &amp;palette, F &amp;&amp;char_out, <span class="keyword">const</span> rect&lt;int32_t&gt; &amp;_r, <span class="keyword">const</span> C &amp;collect6, <span class="keyword">const</span> D &amp;set6) {</div>
<div class="line">        sixel_header(char_out);</div>
<div class="line">        sixel_raster_attributes&lt;W, H, S&gt;(char_out);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = 0; c &lt; palette.size(); c++) {</div>
<div class="line">            sixel_color(char_out, <span class="keyword">static_cast&lt;</span>uint16_t<span class="keyword">&gt;</span>(c), palette[c]);</div>
<div class="line">        }</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> r = rect&lt;int32_t&gt;{_r.x * S, _r.y * S, _r.w * S, _r.h * S} &amp; rect&lt;int32_t&gt;{0, 0, W * S, H * S};</div>
<div class="line">        std::array&lt;PBT, std::max(32UL, 1UL &lt;&lt; PBS)&gt; stack{};</div>
<div class="line">        palette_bitset&lt;PBT, std::max(32UL, 1UL &lt;&lt; PBS)&gt; pset{};</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.y); y &lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.y + r.h); y += 6) {</div>
<div class="line">            pset.clear();</div>
<div class="line">            set6(data, <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.x), <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.w), y, pset);</div>
<div class="line">            <span class="keywordtype">size_t</span> stack_count = pset.genstack(stack);</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> s = 0; s &lt; stack_count; s++) {</div>
<div class="line">                PBT col = stack[s];</div>
<div class="line">                <span class="keywordflow">if</span> (col != 0) {</div>
<div class="line">                    char_out(<span class="charliteral">&#39;$&#39;</span>);</div>
<div class="line">                }</div>
<div class="line">                char_out(<span class="charliteral">&#39;#&#39;</span>);</div>
<div class="line">                sixel_number(char_out, <span class="keyword">static_cast&lt;</span>uint16_t<span class="keyword">&gt;</span>(col));</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.x); x &lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.x + r.w); x++) {</div>
<div class="line">                    PBT bits6 = collect6(data, x, col, y);</div>
<div class="line">                    uint16_t repeat_count = 0;</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> xr = (x + 1); xr &lt; (std::min(x + <span class="keywordtype">size_t</span>{255}, W * <span class="keywordtype">size_t</span>{S})); xr++) {</div>
<div class="line">                        <span class="keywordflow">if</span> (bits6 == collect6(data, xr, col, y)) {</div>
<div class="line">                            repeat_count++;</div>
<div class="line">                            <span class="keywordflow">continue</span>;</div>
<div class="line">                        }</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">if</span> (repeat_count &gt; 3) {</div>
<div class="line">                        char_out(<span class="charliteral">&#39;!&#39;</span>);</div>
<div class="line">                        sixel_number(char_out, repeat_count + 1);</div>
<div class="line">                        x += repeat_count;</div>
<div class="line">                    }</div>
<div class="line">                    char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(<span class="charliteral">&#39;?&#39;</span> + bits6));</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            char_out(<span class="charliteral">&#39;-&#39;</span>);</div>
<div class="line">        }</div>
<div class="line">        sixel_end(char_out);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> W, <span class="keywordtype">size_t</span> H, <span class="keywordtype">int</span>32_t S, <span class="keywordtype">bool</span> GR&gt;</div>
<div class="line"><span class="keyword">class </span>format_1bit : <span class="keyword">public</span> format {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> grayscale = GR;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> bits_per_pixel = 1;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> bytes_per_line = (W * bits_per_pixel + 7) / 8;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> image_size = H * bytes_per_line;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> std::array&lt;uint32_t, (1UL &lt;&lt; bits_per_pixel)&gt; palette = {0x00000000, 0x00ffffff};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> uint8_t reverse(uint8_t b) {</div>
<div class="line">        b = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>((b &amp; uint8_t{0xF0}) &gt;&gt; 4 | (b &amp; uint8_t{0x0F}) &lt;&lt; 4);</div>
<div class="line">        b = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>((b &amp; uint8_t{0xCC}) &gt;&gt; 2 | (b &amp; uint8_t{0x33}) &lt;&lt; 2);</div>
<div class="line">        b = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>((b &amp; uint8_t{0xAA}) &gt;&gt; 1 | (b &amp; uint8_t{0x55}) &lt;&lt; 1);</div>
<div class="line">        <span class="keywordflow">return</span> b;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> transpose8x8(std::array&lt;uint8_t, 8&gt; &amp;a) {</div>
<div class="line">        uint8_t t;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// clang-format off</span></div>
<div class="line">        t = (a[0] ^ (a[1] &gt;&gt; 1)) &amp; 0x55;  a[0] ^=  t; a[1] ^= t &lt;&lt; 1;</div>
<div class="line">        t = (a[2] ^ (a[3] &gt;&gt; 1)) &amp; 0x55;  a[2] ^=  t; a[3] ^= t &lt;&lt; 1;</div>
<div class="line">        t = (a[4] ^ (a[5] &gt;&gt; 1)) &amp; 0x55;  a[4] ^=  t; a[5] ^= t &lt;&lt; 1;</div>
<div class="line">        t = (a[6] ^ (a[7] &gt;&gt; 1)) &amp; 0x55;  a[6] ^=  t; a[7] ^= t &lt;&lt; 1;</div>
<div class="line"> </div>
<div class="line">        t = (a[0] ^ (a[2] &gt;&gt; 2)) &amp; 0x33;  a[0] ^=  t; a[2] ^= t &lt;&lt; 2;</div>
<div class="line">        t = (a[1] ^ (a[3] &gt;&gt; 2)) &amp; 0x33;  a[1] ^=  t; a[3] ^= t &lt;&lt; 2;</div>
<div class="line">        t = (a[4] ^ (a[6] &gt;&gt; 2)) &amp; 0x33;  a[4] ^=  t; a[6] ^= t &lt;&lt; 2;</div>
<div class="line">        t = (a[5] ^ (a[7] &gt;&gt; 2)) &amp; 0x33;  a[5] ^=  t; a[7] ^= t &lt;&lt; 2;</div>
<div class="line"> </div>
<div class="line">        t = (a[0] ^ (a[4] &gt;&gt; 4)) &amp; 0x0F;  a[0] ^=  t; a[4] ^= t &lt;&lt; 4;</div>
<div class="line">        t = (a[1] ^ (a[5] &gt;&gt; 4)) &amp; 0x0F;  a[1] ^=  t; a[5] ^= t &lt;&lt; 4;</div>
<div class="line">        t = (a[2] ^ (a[6] &gt;&gt; 4)) &amp; 0x0F;  a[2] ^=  t; a[6] ^= t &lt;&lt; 4;</div>
<div class="line">        t = (a[3] ^ (a[7] &gt;&gt; 4)) &amp; 0x0F;  a[3] ^=  t; a[7] ^= t &lt;&lt; 4;</div>
<div class="line">        <span class="comment">// clang-format on</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> transpose(<span class="keyword">const</span> uint8_t *src, uint8_t *dst) {</div>
<div class="line">        std::array&lt;uint8_t, 8&gt; tmp;</div>
<div class="line">        <span class="keywordtype">size_t</span> src_stride = ((W + 7) / 8);</div>
<div class="line">        <span class="keywordtype">size_t</span> dst_stride = ((H + 7) / 8);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; dst_stride; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; src_stride; x++) {</div>
<div class="line">                <span class="keywordtype">size_t</span> xl = std::min(<span class="keywordtype">size_t</span>{8}, H - (y * 8));</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = 0; c &lt; xl; c++) {</div>
<div class="line">                    tmp[c] = src[(y * 8 + c) * src_stride + x];</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = xl; c &lt; 8; c++) {</div>
<div class="line">                    tmp[c] = 0;</div>
<div class="line">                }</div>
<div class="line">                transpose8x8(tmp);</div>
<div class="line">                <span class="keywordtype">size_t</span> yl = std::min(<span class="keywordtype">size_t</span>{8}, W - (x * 8));</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = 0; c &lt; yl; c++) {</div>
<div class="line">                    dst[(x * 8 + c) * dst_stride + y] = tmp[c];</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> compose(std::array&lt;uint8_t, image_size&gt; &amp;, <span class="keywordtype">size_t</span>, <span class="keywordtype">size_t</span>, <span class="keywordtype">float</span>, <span class="keywordtype">float</span>, <span class="keywordtype">float</span>, <span class="keywordtype">float</span>) {</div>
<div class="line">        <span class="keyword">static_assert</span>(<span class="keyword">false</span>, <span class="stringliteral">&quot;composing not supported on 1-bit format, use a mono font.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> plot(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keywordtype">size_t</span> x0, <span class="keywordtype">size_t</span> y, uint8_t col) {</div>
<div class="line">        col &amp;= (1UL &lt;&lt; bits_per_pixel) - 1;</div>
<div class="line">        <span class="keywordtype">size_t</span> x8 = x0 / 8;</div>
<div class="line">        x0 %= 8;</div>
<div class="line">        uint8_t *yptr = &amp;data.data()[y * bytes_per_line];</div>
<div class="line">        yptr[x8] &amp;= ~static_cast&lt;uint8_t&gt;(1UL &lt;&lt; (7 - x0));</div>
<div class="line">        yptr[x8] |= <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(col &lt;&lt; (7 - x0));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> span(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keywordtype">size_t</span> xl0, <span class="keywordtype">size_t</span> xr0, <span class="keywordtype">size_t</span> y, uint8_t col) {</div>
<div class="line">        col &amp;= (1UL &lt;&lt; bits_per_pixel) - 1;</div>
<div class="line">        <span class="keywordtype">size_t</span> xl8 = xl0 / 8;</div>
<div class="line">        xl0 %= 8;</div>
<div class="line">        <span class="keywordtype">size_t</span> xr8 = xr0 / 8;</div>
<div class="line">        xr0 %= 8;</div>
<div class="line">        <span class="keywordtype">size_t</span> xs8 = xr8 - xl8;</div>
<div class="line">        uint8_t c8 = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(col &lt;&lt; 7 | col &lt;&lt; 6 | col &lt;&lt; 5 | col &lt;&lt; 4 | col &lt;&lt; 3 | col &lt;&lt; 2 | col &lt;&lt; 1 | col &lt;&lt; 0);</div>
<div class="line">        <span class="keyword">constexpr</span> uint8_t ml[] = {0b11111111, 0b01111111, 0b00111111, 0b00011111, 0b00001111, 0b00000111, 0b00000011, 0b00000001};</div>
<div class="line">        <span class="keyword">constexpr</span> uint8_t mr[] = {0b00000000, 0b10000000, 0b11000000, 0b11100000, 0b11110000, 0b11111000, 0b11111100, 0b11111110};</div>
<div class="line">        uint8_t *yptr = &amp;data.data()[y * bytes_per_line];</div>
<div class="line">        <span class="keywordflow">if</span> (xs8 &gt; 0) {</div>
<div class="line">            yptr[xl8] &amp;= ~ml[xl0];</div>
<div class="line">            yptr[xl8] |= ml[xl0] &amp; c8;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = xl8 + 1; x &lt; xr8; x++) {</div>
<div class="line">                yptr[x] = c8;</div>
<div class="line">            }</div>
<div class="line">            yptr[xr8] &amp;= ~mr[xr0];</div>
<div class="line">            yptr[xr8] |= mr[xr0] &amp; c8;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            yptr[xl8] &amp;= ~(ml[xl0] &amp; mr[xr0]);</div>
<div class="line">            yptr[xl8] |= (ml[xl0] &amp; mr[xr0] &amp; c8);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> uint8_t get_col(<span class="keyword">const</span> uint8_t *line, <span class="keywordtype">size_t</span> x) {</div>
<div class="line">        <span class="keywordtype">size_t</span> x8 = x / 8;</div>
<div class="line">        <span class="keywordtype">size_t</span> xb = x % 8;</div>
<div class="line">        <span class="keywordflow">return</span> (line[x8] &gt;&gt; (7 - xb)) &amp; 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> RGBA_uint32(<span class="keyword">const</span> std::array&lt;uint8_t, image_size&gt; &amp;data) {</div>
<div class="line">        std::array&lt;uint32_t, W * H&gt; rgba{};</div>
<div class="line">        <span class="keyword">const</span> uint8_t *ptr = data.data();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; H; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; W; x++) {</div>
<div class="line">                uint8_t col = get_col(ptr, x);</div>
<div class="line">                rgba[y * W + x] = palette.at(col) | (col ? 0xFF000000 : 0x00000000);</div>
<div class="line">            }</div>
<div class="line">            ptr += bytes_per_line;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> rgba;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> RGBA_uint8(<span class="keyword">const</span> std::array&lt;uint8_t, image_size&gt; &amp;data) {</div>
<div class="line">        std::array&lt;uint8_t, W * H * 4&gt; rgba{};</div>
<div class="line">        <span class="keyword">const</span> uint8_t *ptr = data.data();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; H; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; W; x++) {</div>
<div class="line">                uint8_t col = get_col(ptr, x);</div>
<div class="line">                rgba[y * W * 4 + x * 4 + 0] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>((palette.at(col) &gt;&gt; 16) &amp; 0xFF);</div>
<div class="line">                rgba[y * W * 4 + x * 4 + 1] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>((palette.at(col) &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line">                rgba[y * W * 4 + x * 4 + 2] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>((palette.at(col) &gt;&gt; 0) &amp; 0xFF);</div>
<div class="line">                rgba[y * W * 4 + x * 4 + 3] = (col ? 0xFF : 0x00);</div>
<div class="line">            }</div>
<div class="line">            ptr += bytes_per_line;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> rgba;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> blit_RGBA(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keyword">const</span> rect&lt;int32_t&gt; &amp;r, <span class="keyword">const</span> uint8_t *ptr, int32_t stride) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; static_cast&lt;size_t&gt;(r.h); y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; static_cast&lt;size_t&gt;(r.w); x++) {</div>
<div class="line">                uint32_t R = ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 0];</div>
<div class="line">                uint32_t G = ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 1];</div>
<div class="line">                uint32_t B = ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 2];</div>
<div class="line">                plot(data, x + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.x), y + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.y), (R * 2 + G * 3 + B * 1) &gt; 768 ? 1 : 0);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> blit_RGBA_diffused(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keyword">const</span> rect&lt;int32_t&gt; &amp;r, <span class="keyword">const</span> uint8_t *ptr, int32_t stride) {</div>
<div class="line">        int32_t err = 0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; static_cast&lt;size_t&gt;(r.h); y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; static_cast&lt;size_t&gt;(r.w); x++) {</div>
<div class="line">                int32_t R = ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 0];</div>
<div class="line">                int32_t G = ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 1];</div>
<div class="line">                int32_t B = ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 2];</div>
<div class="line">                int32_t V = (R * 2 + G * 3 + B * 1) + err;</div>
<div class="line">                uint8_t n = V &gt; 768 ? 1 : 0;</div>
<div class="line">                plot(data, (x + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.x)), (y + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.y)), n);</div>
<div class="line">                err = std::clamp(V - (n ? int32_t{0xFF * 6} : int32_t{0x00}), int32_t{-0xFF * 6}, int32_t{0xFF * 6});</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> blit_RGBA_diffused_linear(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keyword">const</span> rect&lt;int32_t&gt; &amp;r, <span class="keyword">const</span> uint8_t *ptr, int32_t stride) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; static_cast&lt;size_t&gt;(r.h); y++) {</div>
<div class="line">            <span class="keywordtype">float</span> err_r = 0;</div>
<div class="line">            <span class="keywordtype">float</span> err_g = 0;</div>
<div class="line">            <span class="keywordtype">float</span> err_b = 0;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; static_cast&lt;size_t&gt;(r.w); x++) {</div>
<div class="line">                <span class="keywordtype">float</span> R = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 0]) * (1.0f / 255.0f);</div>
<div class="line">                <span class="keywordtype">float</span> G = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 1]) * (1.0f / 255.0f);</div>
<div class="line">                <span class="keywordtype">float</span> B = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 2]) * (1.0f / 255.0f);</div>
<div class="line">                <span class="keywordtype">float</span> Rl = constixel::srgb_to_linear(R);</div>
<div class="line">                <span class="keywordtype">float</span> Gl = constixel::srgb_to_linear(G);</div>
<div class="line">                <span class="keywordtype">float</span> Bl = constixel::srgb_to_linear(B);</div>
<div class="line">                Rl = Rl + err_r;</div>
<div class="line">                Gl = Gl + err_g;</div>
<div class="line">                Bl = Bl + err_b;</div>
<div class="line">                uint8_t n = (Rl * 2 * +Gl * 3 + Bl * 1) &gt; 3.0f ? 1 : 0;</div>
<div class="line">                plot(data, (x + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.x)), (y + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.y)), n);</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span> c = 0.75;</div>
<div class="line">                err_r = std::clamp(Rl - (n ? 1.0f : 0.0f), -c, c);</div>
<div class="line">                err_g = std::clamp(Gl - (n ? 1.0f : 0.0f), -c, c);</div>
<div class="line">                err_b = std::clamp(Bl - (n ? 1.0f : 0.0f), -c, c);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> png(<span class="keyword">const</span> std::array&lt;uint8_t, image_size&gt; &amp;data, F &amp;&amp;char_out) {</div>
<div class="line">        png_image&lt;W, H, S, uint8_t, bits_per_pixel&gt;(data.data(), palette, char_out, [](<span class="keyword">const</span> uint8_t *data_raw, <span class="keywordtype">size_t</span> y, <span class="keywordtype">size_t</span> &amp;bpl) {</div>
<div class="line">            bpl = bytes_per_line;</div>
<div class="line">            return data_raw + y * bytes_per_line;</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> sixel(<span class="keyword">const</span> std::array&lt;uint8_t, image_size&gt; &amp;data, F &amp;&amp;char_out, <span class="keyword">const</span> rect&lt;int32_t&gt; &amp;r) {</div>
<div class="line">        sixel_image&lt;W, H, S, uint8_t, bits_per_pixel&gt;(</div>
<div class="line">            data.data(), palette, char_out, r,</div>
<div class="line">            [](<span class="keyword">const</span> uint8_t *data_raw, <span class="keywordtype">size_t</span> x, <span class="keywordtype">size_t</span> col, <span class="keywordtype">size_t</span> y) {</div>
<div class="line">                const uint8_t *ptr = &amp;data_raw[(y / S) * bytes_per_line + (x / S) / 8];</div>
<div class="line">                size_t x8 = (x / S) % 8;</div>
<div class="line">                uint8_t out = 0;</div>
<div class="line">                size_t inc = y % S;</div>
<div class="line">                for (size_t y6 = 0; y6 &lt; 6; y6++) {</div>
<div class="line">                    out &gt;&gt;= 1;</div>
<div class="line">                    if ((y + y6) &lt; H * S) {</div>
<div class="line">                        out |= ((((*ptr) &gt;&gt; (7 - x8)) &amp; 1) == col) ? (1UL &lt;&lt; 5) : 0;</div>
<div class="line">                        if (y6 != 5) {</div>
<div class="line">                            if (++inc &gt;= S) {</div>
<div class="line">                                inc = 0;</div>
<div class="line">                                ptr += bytes_per_line;</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">return</span> out;</div>
<div class="line">            },</div>
<div class="line">            [](<span class="keyword">const</span> uint8_t *data_raw, <span class="keywordtype">size_t</span> x, <span class="keywordtype">size_t</span> w, <span class="keywordtype">size_t</span> y, palette_bitset&lt;uint8_t, 32&gt; &amp;set) {</div>
<div class="line">                <span class="keywordtype">size_t</span> inc = y % S;</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y6 = 0; y6 &lt; 6; y6++) {</div>
<div class="line">                    <span class="keywordflow">if</span> ((y + y6) &lt; H * S) {</div>
<div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> xx = 0; xx &lt; (w + S - 1) / S; xx++) {</div>
<div class="line">                            <span class="keyword">const</span> uint8_t *ptr = &amp;data_raw[((y + y6) / S) * bytes_per_line + (xx + x) / 8];</div>
<div class="line">                            <span class="keywordtype">size_t</span> x8 = (xx + x) % 8;</div>
<div class="line">                            set.mark((((*ptr) &gt;&gt; (7 - x8)) &amp; 1));</div>
<div class="line">                        }</div>
<div class="line">                        <span class="keywordflow">if</span> (++inc &gt;= S) {</div>
<div class="line">                            inc = 0;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            });</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> W, <span class="keywordtype">size_t</span> H, <span class="keywordtype">int</span>32_t S, <span class="keywordtype">bool</span> GR&gt;</div>
<div class="line"><span class="keyword">class </span>format_2bit : <span class="keyword">public</span> format {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> grayscale = GR;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> bits_per_pixel = 2;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> bytes_per_line = (W * bits_per_pixel + 7) / 8;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> image_size = H * bytes_per_line;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">consteval</span> <span class="keyword">const</span> std::array&lt;uint32_t, (1UL &lt;&lt; bits_per_pixel)&gt; gen_palette() {</div>
<div class="line">        <span class="keywordflow">if</span> (GR) {</div>
<div class="line">            <span class="keywordflow">return</span> {0x000000, 0x444444, 0x888888, 0xffffff};</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">return</span> {0x000000, 0xffffff, 0xff0000, 0x0077ff};</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> std::array&lt;uint32_t, (1UL &lt;&lt; bits_per_pixel)&gt; palette = gen_palette();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> constixel::quantize&lt;1UL &lt;&lt; bits_per_pixel&gt; gen_quant() {</div>
<div class="line">        <span class="keywordflow">return</span> constixel::quantize&lt;1UL &lt;&lt; bits_per_pixel&gt;(palette);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> constixel::quantize&lt;1UL &lt;&lt; bits_per_pixel&gt; quant = gen_quant();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> uint8_t reverse(uint8_t b) {</div>
<div class="line">        b = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>((b &amp; uint8_t{0xF0}) &gt;&gt; 4 | (b &amp; uint8_t{0x0F}) &lt;&lt; 4);</div>
<div class="line">        b = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>((b &amp; uint8_t{0xCC}) &gt;&gt; 2 | (b &amp; uint8_t{0x33}) &lt;&lt; 2);</div>
<div class="line">        <span class="keywordflow">return</span> b;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> transpose(<span class="keyword">const</span> uint8_t *, uint8_t *) {</div>
<div class="line">        <span class="keyword">static_assert</span>(<span class="keyword">false</span>, <span class="stringliteral">&quot;Not implemented yet.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> compose(std::array&lt;uint8_t, image_size&gt; &amp;, <span class="keywordtype">size_t</span>, <span class="keywordtype">size_t</span>, <span class="keywordtype">float</span>, <span class="keywordtype">float</span>, <span class="keywordtype">float</span>, <span class="keywordtype">float</span>) {</div>
<div class="line">        <span class="keyword">static_assert</span>(<span class="keyword">false</span>, <span class="stringliteral">&quot;composing not supported on 2-bit format, use a mono font.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> plot(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keywordtype">size_t</span> x0, <span class="keywordtype">size_t</span> y, uint8_t col) {</div>
<div class="line">        col &amp;= (1UL &lt;&lt; bits_per_pixel) - 1;</div>
<div class="line">        <span class="keywordtype">size_t</span> x4 = x0 / 4;</div>
<div class="line">        x0 %= 4;</div>
<div class="line">        uint8_t *yptr = &amp;data.data()[y * bytes_per_line];</div>
<div class="line">        yptr[x4] &amp;= ~static_cast&lt;uint8_t&gt;(3UL &lt;&lt; (6 - x0 * 2));</div>
<div class="line">        yptr[x4] |= <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(col &lt;&lt; (6 - x0 * 2));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> span(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keywordtype">size_t</span> xl0, <span class="keywordtype">size_t</span> xr0, <span class="keywordtype">size_t</span> y, uint8_t col) {</div>
<div class="line">        col &amp;= (1UL &lt;&lt; bits_per_pixel) - 1;</div>
<div class="line">        <span class="keywordtype">size_t</span> xl4 = xl0 / 4;</div>
<div class="line">        xl0 %= 4;</div>
<div class="line">        <span class="keywordtype">size_t</span> xr4 = xr0 / 4;</div>
<div class="line">        xr0 %= 4;</div>
<div class="line">        <span class="keywordtype">size_t</span> xs4 = xr4 - xl4;</div>
<div class="line">        uint8_t c4 = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(col &lt;&lt; 6 | col &lt;&lt; 4 | col &lt;&lt; 2 | col &lt;&lt; 0);</div>
<div class="line">        <span class="keyword">constexpr</span> uint8_t ml[] = {0b11111111, 0b00111111, 0b00001111, 0b00000011};</div>
<div class="line">        <span class="keyword">constexpr</span> uint8_t mr[] = {0b00000000, 0b11000000, 0b11110000, 0b11111100};</div>
<div class="line">        uint8_t *yptr = &amp;data.data()[y * bytes_per_line];</div>
<div class="line">        <span class="keywordflow">if</span> (xs4 &gt; 0) {</div>
<div class="line">            yptr[xl4] &amp;= ~ml[xl0];</div>
<div class="line">            yptr[xl4] |= ml[xl0] &amp; c4;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = xl4 + 1; x &lt; xr4; x++) {</div>
<div class="line">                yptr[x] = c4;</div>
<div class="line">            }</div>
<div class="line">            yptr[xr4] &amp;= ~mr[xr0];</div>
<div class="line">            yptr[xr4] |= mr[xr0] &amp; c4;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            yptr[xl4] &amp;= ~(ml[xl0] &amp; mr[xr0]);</div>
<div class="line">            yptr[xl4] |= (ml[xl0] &amp; mr[xr0] &amp; c4);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> uint8_t get_col(<span class="keyword">const</span> uint8_t *line, <span class="keywordtype">size_t</span> x) {</div>
<div class="line">        <span class="keywordtype">size_t</span> x4 = x / 4;</div>
<div class="line">        <span class="keywordtype">size_t</span> xb = x % 4;</div>
<div class="line">        <span class="keywordflow">return</span> (line[x4] &gt;&gt; ((3 - xb) * 2)) &amp; 0x3;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> RGBA_uint32(<span class="keyword">const</span> std::array&lt;uint8_t, image_size&gt; &amp;data) {</div>
<div class="line">        std::array&lt;uint32_t, W * H&gt; rgba{};</div>
<div class="line">        <span class="keyword">const</span> uint8_t *ptr = data.data();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; H; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; W; x++) {</div>
<div class="line">                uint8_t col = get_col(ptr, x);</div>
<div class="line">                rgba[y * W + x] = palette.at(col) | (col ? 0xFF000000 : 0x00000000);</div>
<div class="line">            }</div>
<div class="line">            ptr += bytes_per_line;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> rgba;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> RGBA_uint8(<span class="keyword">const</span> std::array&lt;uint8_t, image_size&gt; &amp;data) {</div>
<div class="line">        std::array&lt;uint8_t, W * H * 4&gt; rgba{};</div>
<div class="line">        <span class="keyword">const</span> uint8_t *ptr = data.data();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; H; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; W; x++) {</div>
<div class="line">                uint8_t col = get_col(ptr, x);</div>
<div class="line">                rgba[y * W * 4 + x * 4 + 0] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>((palette.at(col) &gt;&gt; 16) &amp; 0xFF);</div>
<div class="line">                rgba[y * W * 4 + x * 4 + 1] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>((palette.at(col) &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line">                rgba[y * W * 4 + x * 4 + 2] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>((palette.at(col) &gt;&gt; 0) &amp; 0xFF);</div>
<div class="line">                rgba[y * W * 4 + x * 4 + 3] = (col ? 0xFF : 0x00);</div>
<div class="line">            }</div>
<div class="line">            ptr += bytes_per_line;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> rgba;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> blit_RGBA(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keyword">const</span> rect&lt;int32_t&gt; &amp;r, <span class="keyword">const</span> uint8_t *ptr, int32_t stride) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; static_cast&lt;size_t&gt;(r.h); y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; static_cast&lt;size_t&gt;(r.w); x++) {</div>
<div class="line">                plot(data, (x + <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(r.x)), (y + <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(r.y)),</div>
<div class="line">                     quant.nearest(ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 0], ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 1],</div>
<div class="line">                                   ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 2]));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> blit_RGBA_diffused(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keyword">const</span> rect&lt;int32_t&gt; &amp;r, <span class="keyword">const</span> uint8_t *ptr, int32_t stride) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; static_cast&lt;size_t&gt;(r.h); y++) {</div>
<div class="line">            int32_t err_r = 0;</div>
<div class="line">            int32_t err_g = 0;</div>
<div class="line">            int32_t err_b = 0;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; static_cast&lt;size_t&gt;(r.w); x++) {</div>
<div class="line">                int32_t R = ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 0];</div>
<div class="line">                int32_t G = ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 1];</div>
<div class="line">                int32_t B = ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 2];</div>
<div class="line">                R = R + err_r;</div>
<div class="line">                G = G + err_g;</div>
<div class="line">                B = B + err_b;</div>
<div class="line">                uint8_t n = quant.nearest(R, G, B);</div>
<div class="line">                plot(data, (x + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.x)), (y + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.y)), n);</div>
<div class="line">                err_r = std::clamp(R - <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>((palette.at(n) &gt;&gt; 16) &amp; 0xFF), int32_t{-255}, int32_t{255});</div>
<div class="line">                err_g = std::clamp(G - <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>((palette.at(n) &gt;&gt; 8) &amp; 0xFF), int32_t{-255}, int32_t{255});</div>
<div class="line">                err_b = std::clamp(B - <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>((palette.at(n) &gt;&gt; 0) &amp; 0xFF), int32_t{-255}, int32_t{255});</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> blit_RGBA_diffused_linear(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keyword">const</span> rect&lt;int32_t&gt; &amp;r, <span class="keyword">const</span> uint8_t *ptr, int32_t stride) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; static_cast&lt;size_t&gt;(r.h); y++) {</div>
<div class="line">            <span class="keywordtype">float</span> err_r = 0;</div>
<div class="line">            <span class="keywordtype">float</span> err_g = 0;</div>
<div class="line">            <span class="keywordtype">float</span> err_b = 0;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; static_cast&lt;size_t&gt;(r.w); x++) {</div>
<div class="line">                <span class="keywordtype">float</span> R = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 0]) * (1.0f / 255.0f);</div>
<div class="line">                <span class="keywordtype">float</span> G = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 1]) * (1.0f / 255.0f);</div>
<div class="line">                <span class="keywordtype">float</span> B = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 2]) * (1.0f / 255.0f);</div>
<div class="line">                <span class="keywordtype">float</span> Rl = constixel::srgb_to_linear(R);</div>
<div class="line">                <span class="keywordtype">float</span> Gl = constixel::srgb_to_linear(G);</div>
<div class="line">                <span class="keywordtype">float</span> Bl = constixel::srgb_to_linear(B);</div>
<div class="line">                Rl = Rl + err_r;</div>
<div class="line">                Gl = Gl + err_g;</div>
<div class="line">                Bl = Bl + err_b;</div>
<div class="line">                uint8_t n = quant.nearest_linear(Rl, Gl, Bl);</div>
<div class="line">                plot(data, (x + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.x)), (y + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.y)), n);</div>
<div class="line">                err_r = std::clamp(Rl - quant.linearpal.at(n * 3 + 0), -1.0f, 1.0f);</div>
<div class="line">                err_g = std::clamp(Gl - quant.linearpal.at(n * 3 + 1), -1.0f, 1.0f);</div>
<div class="line">                err_b = std::clamp(Bl - quant.linearpal.at(n * 3 + 2), -1.0f, 1.0f);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> png(<span class="keyword">const</span> std::array&lt;uint8_t, image_size&gt; &amp;data, F &amp;&amp;char_out) {</div>
<div class="line">        png_image&lt;W, H, S, uint8_t, bits_per_pixel&gt;(data.data(), palette, char_out, [](<span class="keyword">const</span> uint8_t *data_raw, <span class="keywordtype">size_t</span> y, <span class="keywordtype">size_t</span> &amp;bpl) {</div>
<div class="line">            bpl = bytes_per_line;</div>
<div class="line">            return data_raw + y * bytes_per_line;</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> sixel(<span class="keyword">const</span> std::array&lt;uint8_t, image_size&gt; &amp;data, F &amp;&amp;char_out, <span class="keyword">const</span> rect&lt;int32_t&gt; &amp;r) {</div>
<div class="line">        sixel_image&lt;W, H, S, uint8_t, bits_per_pixel&gt;(</div>
<div class="line">            data.data(), palette, char_out, r,</div>
<div class="line">            [](<span class="keyword">const</span> uint8_t *data_raw, <span class="keywordtype">size_t</span> x, <span class="keywordtype">size_t</span> col, <span class="keywordtype">size_t</span> y) {</div>
<div class="line">                const uint8_t *ptr = &amp;data_raw[(y / S) * bytes_per_line + (x / S) / 4];</div>
<div class="line">                size_t x4 = (x / S) % 4;</div>
<div class="line">                uint8_t out = 0;</div>
<div class="line">                size_t inc = y % S;</div>
<div class="line">                for (size_t y6 = 0; y6 &lt; 6; y6++) {</div>
<div class="line">                    out &gt;&gt;= 1;</div>
<div class="line">                    if ((y + y6) &lt; H * S) {</div>
<div class="line">                        out |= ((((*ptr) &gt;&gt; (6 - x4 * 2)) &amp; 3) == col) ? (1UL &lt;&lt; 5) : 0;</div>
<div class="line">                        if (y6 != 5) {</div>
<div class="line">                            if (++inc &gt;= S) {</div>
<div class="line">                                inc = 0;</div>
<div class="line">                                ptr += bytes_per_line;</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">return</span> out;</div>
<div class="line">            },</div>
<div class="line">            [](<span class="keyword">const</span> uint8_t *data_raw, <span class="keywordtype">size_t</span> x, <span class="keywordtype">size_t</span> w, <span class="keywordtype">size_t</span> y, palette_bitset&lt;uint8_t, 32&gt; &amp;set) {</div>
<div class="line">                <span class="keywordtype">size_t</span> inc = y % S;</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y6 = 0; y6 &lt; 6; y6++) {</div>
<div class="line">                    <span class="keywordflow">if</span> ((y + y6) &lt; H * S) {</div>
<div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> xx = 0; xx &lt; (w + S - 1) / S; xx++) {</div>
<div class="line">                            <span class="keyword">const</span> uint8_t *ptr = &amp;data_raw[((y + y6) / S) * bytes_per_line + (xx + x) / 4];</div>
<div class="line">                            <span class="keywordtype">size_t</span> x4 = (xx + x) % 4;</div>
<div class="line">                            set.mark((((*ptr) &gt;&gt; (6 - x4 * 2)) &amp; 3));</div>
<div class="line">                        }</div>
<div class="line">                        <span class="keywordflow">if</span> (++inc &gt;= S) {</div>
<div class="line">                            inc = 0;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            });</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> W, <span class="keywordtype">size_t</span> H, <span class="keywordtype">int</span>32_t S, <span class="keywordtype">bool</span> GR&gt;</div>
<div class="line"><span class="keyword">class </span>format_4bit : <span class="keyword">public</span> format {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> grayscale = GR;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> bits_per_pixel = 4;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> bytes_per_line = (W * bits_per_pixel + 7) / 8;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> image_size = H * bytes_per_line;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">consteval</span> <span class="keyword">const</span> std::array&lt;uint32_t, (1UL &lt;&lt; bits_per_pixel)&gt; gen_palette() {</div>
<div class="line">        <span class="keywordflow">if</span> (GR) {</div>
<div class="line">            <span class="keywordflow">return</span> {0x000000, 0x111111, 0x222222, 0x333333, 0x444444, 0x555555, 0x666666, 0x777777,</div>
<div class="line">                    0x888888, 0x999999, 0xaaaaaa, 0xbbbbbb, 0xcccccc, 0xdddddd, 0xeeeeee, 0xffffff};</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="keywordflow">return</span> {0x000000, 0xffffff, 0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0x00ffff, 0xff00ff,</div>
<div class="line">                    0x333333, 0x666666, 0x999999, 0xcccccc, 0x7f0000, 0x007f00, 0x00007f, 0x7f7f00};</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> std::array&lt;uint32_t, (1UL &lt;&lt; bits_per_pixel)&gt; palette = gen_palette();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> constixel::quantize&lt;1UL &lt;&lt; bits_per_pixel&gt; gen_quant() {</div>
<div class="line">        <span class="keywordflow">return</span> constixel::quantize&lt;1UL &lt;&lt; bits_per_pixel&gt;(palette);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> constixel::quantize&lt;1UL &lt;&lt; bits_per_pixel&gt; quant = gen_quant();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> uint8_t reverse(uint8_t b) {</div>
<div class="line">        b = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>((b &amp; uint8_t{0xF0}) &gt;&gt; 4 | (b &amp; uint8_t{0x0F}) &lt;&lt; 4);</div>
<div class="line">        <span class="keywordflow">return</span> b;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> transpose(<span class="keyword">const</span> uint8_t *, uint8_t *) {</div>
<div class="line">        <span class="keyword">static_assert</span>(<span class="keyword">false</span>, <span class="stringliteral">&quot;Not implemented yet.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> compose(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keywordtype">size_t</span> x, <span class="keywordtype">size_t</span> y, <span class="keywordtype">float</span> cola, <span class="keywordtype">float</span> colr, <span class="keywordtype">float</span> colg, <span class="keywordtype">float</span> colb) {</div>
<div class="line">        <span class="keywordtype">size_t</span> bg = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(get_col(data, x, y));</div>
<div class="line">        <span class="keywordtype">float</span> Rl = colr + quant.linearpal.at(bg * 3 + 0) * (1.0f - cola);</div>
<div class="line">        <span class="keywordtype">float</span> Gl = colg + quant.linearpal.at(bg * 3 + 1) * (1.0f - cola);</div>
<div class="line">        <span class="keywordtype">float</span> Bl = colb + quant.linearpal.at(bg * 3 + 2) * (1.0f - cola);</div>
<div class="line">        plot(data, x, y, quant.nearest_linear(Rl, Gl, Bl));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> plot(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keywordtype">size_t</span> x0, <span class="keywordtype">size_t</span> y, uint8_t col) {</div>
<div class="line">        col &amp;= (1UL &lt;&lt; bits_per_pixel) - 1;</div>
<div class="line">        <span class="keywordtype">size_t</span> x2 = x0 / 2;</div>
<div class="line">        x0 %= 2;</div>
<div class="line">        uint8_t *yptr = &amp;data.data()[y * bytes_per_line];</div>
<div class="line">        yptr[x2] &amp;= ~static_cast&lt;uint8_t&gt;(0xFUL &lt;&lt; (4 - x0 * 4));</div>
<div class="line">        yptr[x2] |= <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(col &lt;&lt; (4 - x0 * 4));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> span(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keywordtype">size_t</span> xl0, <span class="keywordtype">size_t</span> xr0, <span class="keywordtype">size_t</span> y, uint8_t col) {</div>
<div class="line">        col &amp;= (1UL &lt;&lt; bits_per_pixel) - 1;</div>
<div class="line">        <span class="keywordtype">size_t</span> xl2 = xl0 / 2;</div>
<div class="line">        xl0 %= 2;</div>
<div class="line">        <span class="keywordtype">size_t</span> xr2 = xr0 / 2;</div>
<div class="line">        xr0 %= 2;</div>
<div class="line">        <span class="keywordtype">size_t</span> xs2 = xr2 - xl2;</div>
<div class="line">        uint8_t c2 = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(col &lt;&lt; 4 | col &lt;&lt; 0);</div>
<div class="line">        <span class="keyword">constexpr</span> uint8_t ml[] = {0b11111111, 0b00001111};</div>
<div class="line">        <span class="keyword">constexpr</span> uint8_t mr[] = {0b00000000, 0b11110000};</div>
<div class="line">        uint8_t *yptr = &amp;data.data()[y * bytes_per_line];</div>
<div class="line">        <span class="keywordflow">if</span> (xs2 &gt; 0) {</div>
<div class="line">            yptr[xl2] &amp;= ~ml[xl0];</div>
<div class="line">            yptr[xl2] |= ml[xl0] &amp; c2;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = xl2 + 1; x &lt; xr2; x++) {</div>
<div class="line">                yptr[x] = c2;</div>
<div class="line">            }</div>
<div class="line">            yptr[xr2] &amp;= ~mr[xr0];</div>
<div class="line">            yptr[xr2] |= mr[xr0] &amp; c2;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            yptr[xl2] &amp;= ~(ml[xl0] &amp; mr[xr0]);</div>
<div class="line">            yptr[xl2] |= (ml[xl0] &amp; mr[xr0] &amp; c2);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> uint8_t get_col(<span class="keyword">const</span> uint8_t *line, <span class="keywordtype">size_t</span> x) {</div>
<div class="line">        <span class="keywordtype">size_t</span> x2 = x / 2;</div>
<div class="line">        <span class="keywordtype">size_t</span> xb = x % 2;</div>
<div class="line">        <span class="keywordflow">return</span> (line[x2] &gt;&gt; ((1 - xb) * 4)) &amp; 0xF;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> uint8_t get_col(<span class="keyword">const</span> std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keywordtype">size_t</span> x, <span class="keywordtype">size_t</span> y) {</div>
<div class="line">        <span class="keyword">const</span> uint8_t *ptr = data.data() + y * bytes_per_line;</div>
<div class="line">        <span class="keywordtype">size_t</span> x2 = x / 2;</div>
<div class="line">        <span class="keywordtype">size_t</span> xb = x % 2;</div>
<div class="line">        <span class="keywordflow">return</span> (ptr[x2] &gt;&gt; ((1 - xb) * 4)) &amp; 0xF;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> RGBA_uint32(<span class="keyword">const</span> std::array&lt;uint8_t, image_size&gt; &amp;data) {</div>
<div class="line">        std::array&lt;uint32_t, W * H&gt; rgba{};</div>
<div class="line">        <span class="keyword">const</span> uint8_t *ptr = data.data();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; H; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; W; x++) {</div>
<div class="line">                uint8_t col = get_col(ptr, x);</div>
<div class="line">                rgba[y * W + x] = palette.at(col) | (col ? 0xFF000000 : 0x00000000);</div>
<div class="line">            }</div>
<div class="line">            ptr += bytes_per_line;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> rgba;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> RGBA_uint8(<span class="keyword">const</span> std::array&lt;uint8_t, image_size&gt; &amp;data) {</div>
<div class="line">        std::array&lt;uint8_t, W * H * 4&gt; rgba{};</div>
<div class="line">        <span class="keyword">const</span> uint8_t *ptr = data.data();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; H; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; W; x++) {</div>
<div class="line">                uint8_t col = get_col(ptr, x);</div>
<div class="line">                rgba[y * W * 4 + x * 4 + 0] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>((palette.at(col) &gt;&gt; 16) &amp; 0xFF);</div>
<div class="line">                rgba[y * W * 4 + x * 4 + 1] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>((palette.at(col) &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line">                rgba[y * W * 4 + x * 4 + 2] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>((palette.at(col) &gt;&gt; 0) &amp; 0xFF);</div>
<div class="line">                rgba[y * W * 4 + x * 4 + 3] = (col ? 0xFF : 0x00);</div>
<div class="line">            }</div>
<div class="line">            ptr += bytes_per_line;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> rgba;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> blit_RGBA(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keyword">const</span> rect&lt;int32_t&gt; &amp;r, <span class="keyword">const</span> uint8_t *ptr, int32_t stride) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; static_cast&lt;size_t&gt;(r.h); y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; static_cast&lt;size_t&gt;(r.w); x++) {</div>
<div class="line">                plot(data, (x + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.x)), (y + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.y)),</div>
<div class="line">                     quant.nearest(ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 0], ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 1],</div>
<div class="line">                                   ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 2]));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> blit_RGBA_diffused(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keyword">const</span> rect&lt;int32_t&gt; &amp;r, <span class="keyword">const</span> uint8_t *ptr, int32_t stride) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; static_cast&lt;size_t&gt;(r.h); y++) {</div>
<div class="line">            int32_t err_r = 0;</div>
<div class="line">            int32_t err_g = 0;</div>
<div class="line">            int32_t err_b = 0;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; static_cast&lt;size_t&gt;(r.w); x++) {</div>
<div class="line">                int32_t R = ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 0];</div>
<div class="line">                int32_t G = ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 1];</div>
<div class="line">                int32_t B = ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 2];</div>
<div class="line">                R = R + err_r;</div>
<div class="line">                G = G + err_g;</div>
<div class="line">                B = B + err_b;</div>
<div class="line">                uint8_t n = quant.nearest(R, G, B);</div>
<div class="line">                plot(data, (x + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.x)), (y + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.y)), n);</div>
<div class="line">                err_r = std::clamp(R - <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>((palette.at(n) &gt;&gt; 16) &amp; 0xFF), int32_t{-255}, int32_t{255});</div>
<div class="line">                err_g = std::clamp(G - <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>((palette.at(n) &gt;&gt; 8) &amp; 0xFF), int32_t{-255}, int32_t{255});</div>
<div class="line">                err_b = std::clamp(B - <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>((palette.at(n) &gt;&gt; 0) &amp; 0xFF), int32_t{-255}, int32_t{255});</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> blit_RGBA_diffused_linear(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keyword">const</span> rect&lt;int32_t&gt; &amp;r, <span class="keyword">const</span> uint8_t *ptr, int32_t stride) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; static_cast&lt;size_t&gt;(r.h); y++) {</div>
<div class="line">            <span class="keywordtype">float</span> err_r = 0;</div>
<div class="line">            <span class="keywordtype">float</span> err_g = 0;</div>
<div class="line">            <span class="keywordtype">float</span> err_b = 0;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; static_cast&lt;size_t&gt;(r.w); x++) {</div>
<div class="line">                <span class="keywordtype">float</span> R = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 0]) * (1.0f / 255.0f);</div>
<div class="line">                <span class="keywordtype">float</span> G = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 1]) * (1.0f / 255.0f);</div>
<div class="line">                <span class="keywordtype">float</span> B = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 2]) * (1.0f / 255.0f);</div>
<div class="line">                <span class="keywordtype">float</span> Rl = constixel::srgb_to_linear(R);</div>
<div class="line">                <span class="keywordtype">float</span> Gl = constixel::srgb_to_linear(G);</div>
<div class="line">                <span class="keywordtype">float</span> Bl = constixel::srgb_to_linear(B);</div>
<div class="line">                Rl = Rl + err_r;</div>
<div class="line">                Gl = Gl + err_g;</div>
<div class="line">                Bl = Bl + err_b;</div>
<div class="line">                uint8_t n = quant.nearest_linear(Rl, Gl, Bl);</div>
<div class="line">                plot(data, (x + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.x)), (y + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.y)), n);</div>
<div class="line">                err_r = std::clamp(Rl - quant.linearpal.at(n * 3 + 0), -1.0f, 1.0f);</div>
<div class="line">                err_g = std::clamp(Gl - quant.linearpal.at(n * 3 + 1), -1.0f, 1.0f);</div>
<div class="line">                err_b = std::clamp(Bl - quant.linearpal.at(n * 3 + 2), -1.0f, 1.0f);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> png(<span class="keyword">const</span> std::array&lt;uint8_t, image_size&gt; &amp;data, F &amp;&amp;char_out) {</div>
<div class="line">        png_image&lt;W, H, S, uint8_t, bits_per_pixel&gt;(data.data(), palette, char_out, [](<span class="keyword">const</span> uint8_t *data_raw, <span class="keywordtype">size_t</span> y, <span class="keywordtype">size_t</span> &amp;bpl) {</div>
<div class="line">            bpl = bytes_per_line;</div>
<div class="line">            return data_raw + y * bytes_per_line;</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> sixel(<span class="keyword">const</span> std::array&lt;uint8_t, image_size&gt; &amp;data, F &amp;&amp;char_out, <span class="keyword">const</span> rect&lt;int32_t&gt; &amp;r) {</div>
<div class="line">        sixel_image&lt;W, H, S, uint8_t, bits_per_pixel&gt;(</div>
<div class="line">            data.data(), palette, char_out, r,</div>
<div class="line">            [](<span class="keyword">const</span> uint8_t *data_raw, <span class="keywordtype">size_t</span> x, <span class="keywordtype">size_t</span> col, <span class="keywordtype">size_t</span> y) {</div>
<div class="line">                const uint8_t *ptr = &amp;data_raw[(y / S) * bytes_per_line + (x / S) / 2];</div>
<div class="line">                size_t x2 = (x / S) % 2;</div>
<div class="line">                uint8_t out = 0;</div>
<div class="line">                size_t inc = y % S;</div>
<div class="line">                for (size_t y6 = 0; y6 &lt; 6; y6++) {</div>
<div class="line">                    out &gt;&gt;= 1;</div>
<div class="line">                    if ((y + y6) &lt; H * S) {</div>
<div class="line">                        out |= ((((*ptr) &gt;&gt; (4 - x2 * 4)) &amp; 0xF) == col) ? (1UL &lt;&lt; 5) : 0;</div>
<div class="line">                        if (y6 != 5) {</div>
<div class="line">                            if (++inc &gt;= S) {</div>
<div class="line">                                inc = 0;</div>
<div class="line">                                ptr += bytes_per_line;</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">return</span> out;</div>
<div class="line">            },</div>
<div class="line">            [](<span class="keyword">const</span> uint8_t *data_raw, <span class="keywordtype">size_t</span> x, <span class="keywordtype">size_t</span> w, <span class="keywordtype">size_t</span> y, palette_bitset&lt;uint8_t, 32&gt; &amp;set) {</div>
<div class="line">                <span class="keywordtype">size_t</span> inc = y % S;</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y6 = 0; y6 &lt; 6; y6++) {</div>
<div class="line">                    <span class="keywordflow">if</span> ((y + y6) &lt; H * S) {</div>
<div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> xx = 0; xx &lt; (w + S - 1) / S; xx++) {</div>
<div class="line">                            <span class="keyword">const</span> uint8_t *ptr = &amp;data_raw[((y + y6) / S) * bytes_per_line + (xx + x) / 2];</div>
<div class="line">                            <span class="keywordtype">size_t</span> x2 = (xx + x) % 2;</div>
<div class="line">                            set.mark((((*ptr) &gt;&gt; (4 - x2 * 4)) &amp; 0xF));</div>
<div class="line">                        }</div>
<div class="line">                        <span class="keywordflow">if</span> (++inc &gt;= S) {</div>
<div class="line">                            inc = 0;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            });</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> W, <span class="keywordtype">size_t</span> H, <span class="keywordtype">int</span>32_t S, <span class="keywordtype">bool</span> GR&gt;</div>
<div class="line"><span class="keyword">class </span>format_8bit : <span class="keyword">public</span> format {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> grayscale = GR;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> bits_per_pixel = 8;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> bytes_per_line = W;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> image_size = H * bytes_per_line;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">consteval</span> <span class="keyword">const</span> std::array&lt;uint32_t, (1UL &lt;&lt; bits_per_pixel)&gt; gen_palette() {</div>
<div class="line">        std::array&lt;uint32_t, (1UL &lt;&lt; bits_per_pixel)&gt; pal{};</div>
<div class="line">        <span class="keywordflow">if</span> (GR) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = 0; c &lt; 256; c++) {</div>
<div class="line">                pal[c] = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>((c &lt;&lt; 16) | (c &lt;&lt; 8) | c);</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            pal[0] = 0x000000;</div>
<div class="line">            pal[1] = 0xffffff;</div>
<div class="line">            pal[2] = 0xff0000;</div>
<div class="line">            pal[3] = 0x00ff00;</div>
<div class="line">            pal[4] = 0x0000ff;</div>
<div class="line">            pal[5] = 0xffff00;</div>
<div class="line">            pal[6] = 0x00ffff;</div>
<div class="line">            pal[7] = 0xff00ff;</div>
<div class="line">            pal[8] = 0x333333;</div>
<div class="line">            pal[9] = 0x666666;</div>
<div class="line">            pal[10] = 0x999999;</div>
<div class="line">            pal[11] = 0xcccccc;</div>
<div class="line">            pal[12] = 0x7f0000;</div>
<div class="line">            pal[13] = 0x007f00;</div>
<div class="line">            pal[14] = 0x00007f;</div>
<div class="line">            pal[15] = 0x7f7f00;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = 0; c &lt; 16; c++) {</div>
<div class="line">                uint32_t y = (0xff * <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(c)) / 15;</div>
<div class="line">                pal[0x10 + c] = (y &lt;&lt; 16) | (y &lt;&lt; 8) | (y &lt;&lt; 0);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = 0; c &lt; 8; c++) {</div>
<div class="line">                uint32_t y = (0xff * <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(c)) / 7;</div>
<div class="line">                uint32_t x = (0xff * (<span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(c) + 1)) / 8;</div>
<div class="line">                pal[0x20 + c + 0] = (y &lt;&lt; 16) | (0 &lt;&lt; 8) | (0 &lt;&lt; 0);</div>
<div class="line">                pal[0x20 + c + 8] = (255 &lt;&lt; 16) | (x &lt;&lt; 8) | (x &lt;&lt; 0);</div>
<div class="line">                pal[0x30 + c + 0] = (0 &lt;&lt; 16) | (y &lt;&lt; 8) | (0 &lt;&lt; 0);</div>
<div class="line">                pal[0x30 + c + 8] = (x &lt;&lt; 16) | (255 &lt;&lt; 8) | (x &lt;&lt; 0);</div>
<div class="line">                pal[0x40 + c + 0] = (0 &lt;&lt; 16) | (0 &lt;&lt; 8) | (y &lt;&lt; 0);</div>
<div class="line">                pal[0x40 + c + 8] = (x &lt;&lt; 16) | (x &lt;&lt; 8) | (255 &lt;&lt; 0);</div>
<div class="line">                pal[0x50 + c + 0] = (y &lt;&lt; 16) | (y &lt;&lt; 8) | (0 &lt;&lt; 0);</div>
<div class="line">                pal[0x50 + c + 8] = (255 &lt;&lt; 16) | (255 &lt;&lt; 8) | (x &lt;&lt; 0);</div>
<div class="line">                pal[0x60 + c + 0] = (0 &lt;&lt; 16) | (y &lt;&lt; 8) | (y &lt;&lt; 0);</div>
<div class="line">                pal[0x60 + c + 8] = (x &lt;&lt; 16) | (255 &lt;&lt; 8) | (255 &lt;&lt; 0);</div>
<div class="line">                pal[0x70 + c + 0] = (y &lt;&lt; 16) | (0 &lt;&lt; 8) | (y &lt;&lt; 0);</div>
<div class="line">                pal[0x70 + c + 8] = (255 &lt;&lt; 16) | (x &lt;&lt; 8) | (255 &lt;&lt; 0);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = 0; c &lt; 8; c++) {</div>
<div class="line">                constixel::oklab lft{<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(c) / 7 - 0.2, 0.2, 0.0};</div>
<div class="line">                constixel::oklab rgh{<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(c) / 7 - 0.2, 0.2, 337.5};</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> d = 0; d &lt; 16; d++) {</div>
<div class="line">                    <span class="keyword">auto</span> res = constixel::oklab_to_srgb(constixel::oklch_to_oklab(constixel::oklch{</div>
<div class="line">                        std::lerp(lft.l, rgh.l, <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(d) / 15.0),</div>
<div class="line">                        std::lerp(lft.a, rgh.a, <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(d) / 15.0),</div>
<div class="line">                        std::lerp(lft.b, rgh.b, <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(d) / 15.0),</div>
<div class="line">                    }));</div>
<div class="line">                    pal[0x80 + c * 16 + d] = (<span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(std::max(0.0, std::min(1.0, res.r)) * 255.0) &lt;&lt; 16) |</div>
<div class="line">                                             (<span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(std::max(0.0, std::min(1.0, res.g)) * 255.0) &lt;&lt; 8) |</div>
<div class="line">                                             (<span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(std::max(0.0, std::min(1.0, res.b)) * 255.0) &lt;&lt; 0);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> pal;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> std::array&lt;uint32_t, 1UL &lt;&lt; bits_per_pixel&gt; palette = gen_palette();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> constixel::quantize&lt;1UL &lt;&lt; bits_per_pixel&gt; gen_quant() {</div>
<div class="line">        <span class="keywordflow">return</span> constixel::quantize&lt;1UL &lt;&lt; bits_per_pixel&gt;(palette);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> constixel::quantize&lt;1UL &lt;&lt; bits_per_pixel&gt; quant = gen_quant();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> uint8_t reverse(uint8_t b) {</div>
<div class="line">        <span class="keywordflow">return</span> b;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> transpose(<span class="keyword">const</span> uint8_t *, uint8_t *) {</div>
<div class="line">        <span class="keyword">static_assert</span>(<span class="keyword">false</span>, <span class="stringliteral">&quot;Not implemented yet.&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> plot(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keywordtype">size_t</span> x, <span class="keywordtype">size_t</span> y, uint8_t col) {</div>
<div class="line">        data.data()[y * bytes_per_line + x] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(col);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> span(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keywordtype">size_t</span> xl0, <span class="keywordtype">size_t</span> xr0, <span class="keywordtype">size_t</span> y, uint8_t col) {</div>
<div class="line">        uint8_t *yptr = &amp;data.data()[y * bytes_per_line];</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = xl0; x &lt; xr0; x++) {</div>
<div class="line">            yptr[x] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(col);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> compose(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keywordtype">size_t</span> x, <span class="keywordtype">size_t</span> y, <span class="keywordtype">float</span> cola, <span class="keywordtype">float</span> colr, <span class="keywordtype">float</span> colg, <span class="keywordtype">float</span> colb) {</div>
<div class="line">        <span class="keywordtype">size_t</span> bg = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(data.data()[y * bytes_per_line + x]);</div>
<div class="line">        <span class="keywordtype">float</span> Rl = colr + quant.linearpal.at(bg * 3 + 0) * (1.0f - cola);</div>
<div class="line">        <span class="keywordtype">float</span> Gl = colg + quant.linearpal.at(bg * 3 + 1) * (1.0f - cola);</div>
<div class="line">        <span class="keywordtype">float</span> Bl = colb + quant.linearpal.at(bg * 3 + 2) * (1.0f - cola);</div>
<div class="line">        plot(data, x, y, quant.nearest_linear(Rl, Gl, Bl));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> RGBA_uint32(<span class="keyword">const</span> std::array&lt;uint8_t, image_size&gt; &amp;data) {</div>
<div class="line">        std::array&lt;uint32_t, W * H&gt; rgba{};</div>
<div class="line">        <span class="keyword">const</span> uint8_t *ptr = data.data();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; H; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; W; x++) {</div>
<div class="line">                uint8_t col = ptr[x];</div>
<div class="line">                rgba[y * W + x] = palette.at(col) | (col ? 0xFF000000 : 0x00000000);</div>
<div class="line">            }</div>
<div class="line">            ptr += bytes_per_line;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> rgba;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> RGBA_uint8(<span class="keyword">const</span> std::array&lt;uint8_t, image_size&gt; &amp;data) {</div>
<div class="line">        std::array&lt;uint8_t, W * H * 4&gt; rgba{};</div>
<div class="line">        <span class="keyword">const</span> uint8_t *ptr = data.data();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; H; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; W; x++) {</div>
<div class="line">                uint8_t col = ptr[x];</div>
<div class="line">                rgba[y * W * 4 + x * 4 + 0] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>((palette.at(col) &gt;&gt; 16) &amp; 0xFF);</div>
<div class="line">                rgba[y * W * 4 + x * 4 + 1] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>((palette.at(col) &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line">                rgba[y * W * 4 + x * 4 + 2] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>((palette.at(col) &gt;&gt; 0) &amp; 0xFF);</div>
<div class="line">                rgba[y * W * 4 + x * 4 + 3] = (col ? 0xFF : 0x00);</div>
<div class="line">            }</div>
<div class="line">            ptr += bytes_per_line;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> rgba;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> blit_RGBA(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keyword">const</span> rect&lt;int32_t&gt; &amp;r, <span class="keyword">const</span> uint8_t *ptr, int32_t stride) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; static_cast&lt;size_t&gt;(r.h); y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; static_cast&lt;size_t&gt;(r.w); x++) {</div>
<div class="line">                data.data()[(y + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.y)) * bytes_per_line + (x + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.x))] =</div>
<div class="line">                    quant.nearest(ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 0], ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 1],</div>
<div class="line">                                  ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 2]);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> blit_RGBA_diffused(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keyword">const</span> rect&lt;int32_t&gt; &amp;r, <span class="keyword">const</span> uint8_t *ptr, int32_t stride) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; static_cast&lt;size_t&gt;(r.h); y++) {</div>
<div class="line">            int32_t err_r = 0;</div>
<div class="line">            int32_t err_g = 0;</div>
<div class="line">            int32_t err_b = 0;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; static_cast&lt;size_t&gt;(r.w); x++) {</div>
<div class="line">                int32_t R = ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 0];</div>
<div class="line">                int32_t G = ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 1];</div>
<div class="line">                int32_t B = ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 2];</div>
<div class="line">                R = R + err_r;</div>
<div class="line">                G = G + err_g;</div>
<div class="line">                B = B + err_b;</div>
<div class="line">                uint8_t n = quant.nearest(R, G, B);</div>
<div class="line">                data.data()[(y + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.y)) * bytes_per_line + (x + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.x))] = n;</div>
<div class="line">                err_r = std::clamp(R - <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>((palette.at(n) &gt;&gt; 16) &amp; 0xFF), int32_t{-255}, int32_t{255});</div>
<div class="line">                err_g = std::clamp(G - <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>((palette.at(n) &gt;&gt; 8) &amp; 0xFF), int32_t{-255}, int32_t{255});</div>
<div class="line">                err_b = std::clamp(B - <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>((palette.at(n) &gt;&gt; 0) &amp; 0xFF), int32_t{-255}, int32_t{255});</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> blit_RGBA_diffused_linear(std::array&lt;uint8_t, image_size&gt; &amp;data, <span class="keyword">const</span> rect&lt;int32_t&gt; &amp;r, <span class="keyword">const</span> uint8_t *ptr, int32_t stride) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; static_cast&lt;size_t&gt;(r.h); y++) {</div>
<div class="line">            <span class="keywordtype">float</span> err_r = 0;</div>
<div class="line">            <span class="keywordtype">float</span> err_g = 0;</div>
<div class="line">            <span class="keywordtype">float</span> err_b = 0;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; static_cast&lt;size_t&gt;(r.w); x++) {</div>
<div class="line">                <span class="keywordtype">float</span> R = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 0]) * (1.0f / 255.0f);</div>
<div class="line">                <span class="keywordtype">float</span> G = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 1]) * (1.0f / 255.0f);</div>
<div class="line">                <span class="keywordtype">float</span> B = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(ptr[y * <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(stride) + x * 4 + 2]) * (1.0f / 255.0f);</div>
<div class="line">                <span class="keywordtype">float</span> Rl = constixel::srgb_to_linear(R);</div>
<div class="line">                <span class="keywordtype">float</span> Gl = constixel::srgb_to_linear(G);</div>
<div class="line">                <span class="keywordtype">float</span> Bl = constixel::srgb_to_linear(B);</div>
<div class="line">                Rl = Rl + err_r;</div>
<div class="line">                Gl = Gl + err_g;</div>
<div class="line">                Bl = Bl + err_b;</div>
<div class="line">                uint8_t n = quant.nearest_linear(Rl, Gl, Bl);</div>
<div class="line">                data.data()[(y + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.y)) * bytes_per_line + (x + <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(r.x))] = n;</div>
<div class="line">                err_r = std::clamp(Rl - quant.linearpal.at(n * 3 + 0), -1.0f, 1.0f);</div>
<div class="line">                err_g = std::clamp(Gl - quant.linearpal.at(n * 3 + 1), -1.0f, 1.0f);</div>
<div class="line">                err_b = std::clamp(Bl - quant.linearpal.at(n * 3 + 2), -1.0f, 1.0f);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> png(<span class="keyword">const</span> std::array&lt;uint8_t, image_size&gt; &amp;data, F &amp;&amp;char_out) {</div>
<div class="line">        png_image&lt;W, H, S, uint8_t, bits_per_pixel&gt;(data.data(), palette, char_out, [](<span class="keyword">const</span> uint8_t *data_raw, <span class="keywordtype">size_t</span> y, <span class="keywordtype">size_t</span> &amp;bpl) {</div>
<div class="line">            bpl = bytes_per_line;</div>
<div class="line">            return data_raw + y * bytes_per_line;</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">void</span> sixel(<span class="keyword">const</span> std::array&lt;uint8_t, image_size&gt; &amp;data, F &amp;&amp;char_out, <span class="keyword">const</span> rect&lt;int32_t&gt; &amp;r) {</div>
<div class="line">        sixel_image&lt;W, H, S, uint8_t, bits_per_pixel&gt;(</div>
<div class="line">            data.data(), palette, char_out, r,</div>
<div class="line">            [](<span class="keyword">const</span> uint8_t *data_raw, <span class="keywordtype">size_t</span> x, <span class="keywordtype">size_t</span> col, <span class="keywordtype">size_t</span> y) {</div>
<div class="line">                const uint8_t *ptr = &amp;data_raw[(y / S) * bytes_per_line + x / S];</div>
<div class="line">                uint8_t out = 0;</div>
<div class="line">                size_t inc = y % S;</div>
<div class="line">                for (size_t y6 = 0; y6 &lt; 6; y6++) {</div>
<div class="line">                    out &gt;&gt;= 1;</div>
<div class="line">                    if ((y + y6) &lt; H * S) {</div>
<div class="line">                        out |= (*ptr == col) ? (1UL &lt;&lt; 5) : 0;</div>
<div class="line">                        if (y6 != 5) {</div>
<div class="line">                            if (++inc &gt;= S) {</div>
<div class="line">                                inc = 0;</div>
<div class="line">                                ptr += bytes_per_line;</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">return</span> out;</div>
<div class="line">            },</div>
<div class="line">            [](<span class="keyword">const</span> uint8_t *data_raw, <span class="keywordtype">size_t</span> x, <span class="keywordtype">size_t</span> w, <span class="keywordtype">size_t</span> y, palette_bitset&lt;uint8_t, 1UL &lt;&lt; bits_per_pixel&gt; &amp;set) {</div>
<div class="line">                <span class="keyword">const</span> uint8_t *ptr = &amp;data_raw[(y / S) * bytes_per_line + x / S];</div>
<div class="line">                <span class="keywordtype">size_t</span> inc = y % S;</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y6 = 0; y6 &lt; 6; y6++) {</div>
<div class="line">                    <span class="keywordflow">if</span> ((y + y6) &lt; H * S) {</div>
<div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> xx = 0; xx &lt; (w + S - 1) / S; xx++) {</div>
<div class="line">                            set.mark(ptr[xx + x]);</div>
<div class="line">                        }</div>
<div class="line">                        <span class="keywordflow">if</span> (y6 != 5) {</div>
<div class="line">                            <span class="keywordflow">if</span> (++inc &gt;= S) {</div>
<div class="line">                                inc = 0;</div>
<div class="line">                                ptr += bytes_per_line;</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            });</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">enum</span> color : uint8_t {</div>
<div class="line">    BLACK = 0,         </div>
<div class="line">    TRANSPARENT = 0,   </div>
<div class="line">    BLACK_OPAQUE = 16, </div>
<div class="line">    WHITE = 1,         </div>
<div class="line">    RED = 2,           </div>
<div class="line">    GREEN = 3,         </div>
<div class="line">    BLUE = 4,          </div>
<div class="line">    YELLOW = 5,        </div>
<div class="line">    CYAN = 6,          </div>
<div class="line">    MAGENTA = 7,       </div>
<div class="line">    GREY_80 = 8,       </div>
<div class="line">    GREY_60 = 9,       </div>
<div class="line">    GREY_40 = 10,      </div>
<div class="line">    GREY_20 = 11,      </div>
<div class="line">    DARK_RED = 12,     </div>
<div class="line">    DARK_GREEN = 13,   </div>
<div class="line">    DARK_BLUE = 14,    </div>
<div class="line">    DARK_YELLOW = 15,  </div>
<div class="line"> </div>
<div class="line">    GREY_RAMP_START = 16,</div>
<div class="line">    GREY_RAMP_COUNT = 16,</div>
<div class="line">    GREY_RAMP_STOP = GREY_RAMP_START + 15,</div>
<div class="line"> </div>
<div class="line">    RED_LUMA_RAMP_START = 32,</div>
<div class="line">    RED_LUMA_RAMP_COUNT = 16,</div>
<div class="line">    RED_LUMA_RAMP_STOP = RED_LUMA_RAMP_START + 15,</div>
<div class="line"> </div>
<div class="line">    GREEN_LUMA_RAMP_START = 48,</div>
<div class="line">    GREEN_LUMA_RAMP_COUNT = 16,</div>
<div class="line">    GREEN_LUMA_RAMP_STOP = GREEN_LUMA_RAMP_START + 15,</div>
<div class="line"> </div>
<div class="line">    BLUE_LUMA_RAMP_START = 64,</div>
<div class="line">    BLUE_LUMA_RAMP_COUNT = 16,</div>
<div class="line">    BLUE_LUMA_RAMP_STOP = BLUE_LUMA_RAMP_START + 15,</div>
<div class="line"> </div>
<div class="line">    YELLOW_LUMA_RAMP_START = 80,</div>
<div class="line">    YELLOW_LUMA_RAMP_COUNT = 16,</div>
<div class="line">    YELLOW_LUMA_RAMP_STOP = YELLOW_LUMA_RAMP_START + 15,</div>
<div class="line"> </div>
<div class="line">    CYAN_LUMA_RAMP_START = 96,</div>
<div class="line">    CYAN_LUMA_RAMP_COUNT = 16,</div>
<div class="line">    CYAN_LUMA_RAMP_STOP = CYAN_LUMA_RAMP_START + 15,</div>
<div class="line"> </div>
<div class="line">    MAGENTA_LUMA_RAMP_START = 112,</div>
<div class="line">    MAGENTA_LUMA_RAMP_COUNT = 16,</div>
<div class="line">    MAGENTA_LUMA_RAMP_STOP = MAGENTA_LUMA_RAMP_START + 15</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">enum</span> text_rotation {</div>
<div class="line">    DEGREE_0,</div>
<div class="line">    DEGREE_90,</div>
<div class="line">    DEGREE_180,</div>
<div class="line">    DEGREE_270</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span>, <span class="keywordtype">size_t</span>, <span class="keywordtype">int</span>32_t, <span class="keywordtype">bool</span>&gt; <span class="keyword">class </span>T, <span class="keywordtype">size_t</span> W, <span class="keywordtype">size_t</span> H, int32_t S = 1, <span class="keywordtype">bool</span> GR = <span class="keyword">false</span>&gt;</div>
<div class="line"><span class="keyword">class </span>image {</div>
<div class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(W) &gt;= <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(H) &gt;= <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static_assert</span>(W &gt; 0 &amp;&amp; H &gt; 0);</div>
<div class="line">    <span class="keyword">static_assert</span>((W * S) &lt;= 16384 &amp;&amp; (H * S) &lt;= 16384);</div>
<div class="line">    <span class="keyword">static_assert</span>(S &gt;= 1 &amp;&amp; S &lt;= 256);</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> grayscale() {</div>
<div class="line">        <span class="keywordflow">return</span> T&lt;W, H, S, GR&gt;::grayscale;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> bit_depth() {</div>
<div class="line">        <span class="keywordflow">return</span> T&lt;W, H, S, GR&gt;::bits_per_pixel;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> size() {</div>
<div class="line">        <span class="keywordflow">return</span> T&lt;W, H, S, GR&gt;::image_size;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> bytes_per_line() {</div>
<div class="line">        <span class="keywordflow">return</span> T&lt;W, H, S, GR&gt;::bytes_per_line;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> int32_t width() {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(W);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> int32_t height() {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(H);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> clear() {</div>
<div class="line">        data.fill(0);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    [[nodiscard]] <span class="keyword">constexpr</span> std::array&lt;uint8_t, T&lt;W, H, S, GR&gt;::image_size&gt; &amp;data_ref() {</div>
<div class="line">        <span class="keywordflow">return</span> data;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    [[nodiscard]] <span class="keyword">constexpr</span> image&lt;T, W, H, S, GR&gt; clone()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> copy(<span class="keyword">const</span> image&lt;T, W, H, S, GR&gt; &amp;src) {</div>
<div class="line">        data = src.data;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> BYTE_SIZE&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> copy(<span class="keyword">const</span> uint8_t *src) {</div>
<div class="line">        <span class="keyword">static_assert</span>(size() == BYTE_SIZE, <span class="stringliteral">&quot;Copied length much match the image size&quot;</span>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = 0; c &lt; BYTE_SIZE; c++) {</div>
<div class="line">            data.data()[c] = src[c];</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> draw_line(int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint8_t col, uint32_t stroke_width = 1) {</div>
<div class="line">        int32_t steep = abs(y1 - y0) &gt; abs(x1 - x0);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (steep) {</div>
<div class="line">            std::swap(x0, y0);</div>
<div class="line">            std::swap(x1, y1);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (x0 &gt; x1) {</div>
<div class="line">            std::swap(x0, x1);</div>
<div class="line">            std::swap(y0, y1);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        int32_t dx, dy;</div>
<div class="line">        dx = x1 - x0;</div>
<div class="line">        dy = abs(y1 - y0);</div>
<div class="line"> </div>
<div class="line">        int32_t err = dx / 2;</div>
<div class="line">        int32_t ystep;</div>
<div class="line">        <span class="keywordflow">if</span> (y0 &lt; y1) {</div>
<div class="line">            ystep = 1;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            ystep = -1;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (stroke_width == 1) {</div>
<div class="line">            <span class="keywordflow">for</span> (; x0 &lt;= x1; x0++) {</div>
<div class="line">                <span class="keywordflow">if</span> (steep) {</div>
<div class="line">                    plot(y0, x0, col);</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    plot(x0, y0, col);</div>
<div class="line">                }</div>
<div class="line">                err -= dy;</div>
<div class="line">                <span class="keywordflow">if</span> (err &lt; 0) {</div>
<div class="line">                    y0 += ystep;</div>
<div class="line">                    err += dx;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (stroke_width &gt; 1) {</div>
<div class="line">            <span class="keywordflow">for</span> (; x0 &lt;= x1; x0++) {</div>
<div class="line">                <span class="keywordflow">if</span> (steep) {</div>
<div class="line">                    fill_circle(y0, x0, (stroke_width + 1) / 2, col);</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    fill_circle(x0, y0, (stroke_width + 1) / 2, col);</div>
<div class="line">                }</div>
<div class="line">                err -= dy;</div>
<div class="line">                <span class="keywordflow">if</span> (err &lt; 0) {</div>
<div class="line">                    y0 += ystep;</div>
<div class="line">                    err += dx;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> draw_line(<span class="keyword">const</span> rect&lt;int32_t&gt; &amp;rect, uint8_t col, uint32_t stroke_width = 1) {</div>
<div class="line">        draw_line(rect.x, rect.y, rect.x + rect.w, rect.y + rect.h, col, stroke_width);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> draw_line_aa(int32_t x0, int32_t y0, int32_t x1, int32_t y1, uint8_t col) {</div>
<div class="line">        <span class="keyword">auto</span> ipart = [](<span class="keywordtype">float</span> x) {</div>
<div class="line">            <span class="keywordflow">return</span> std::floor(x);</div>
<div class="line">        };</div>
<div class="line">        <span class="keyword">auto</span> fpart = [](<span class="keywordtype">float</span> x) {</div>
<div class="line">            <span class="keywordflow">return</span> x - std::floor(x);</div>
<div class="line">        };</div>
<div class="line">        <span class="keyword">auto</span> rfpart = [&amp;](<span class="keywordtype">float</span> x) {</div>
<div class="line">            <span class="keywordflow">return</span> 1.0f - fpart(x);</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">bool</span> steep = std::fabs(y1 - y0) &gt; std::fabs(x1 - x0);</div>
<div class="line">        <span class="keywordflow">if</span> (steep) {</div>
<div class="line">            std::swap(x0, y0);</div>
<div class="line">            std::swap(x1, y1);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (x0 &gt; x1) {</div>
<div class="line">            std::swap(x0, x1);</div>
<div class="line">            std::swap(y0, y1);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">float</span> Rl = format.quant.linearpal.at((col &amp; ((1UL &lt;&lt; format.bits_per_pixel) - 1)) * 3 + 0);</div>
<div class="line">        <span class="keywordtype">float</span> Gl = format.quant.linearpal.at((col &amp; ((1UL &lt;&lt; format.bits_per_pixel) - 1)) * 3 + 1);</div>
<div class="line">        <span class="keywordtype">float</span> Bl = format.quant.linearpal.at((col &amp; ((1UL &lt;&lt; format.bits_per_pixel) - 1)) * 3 + 2);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">float</span> dx = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(x1 - x0);</div>
<div class="line">        <span class="keywordtype">float</span> dy = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(y1 - y0);</div>
<div class="line">        <span class="keywordtype">float</span> gradient = dx == 0.0f ? 1.0f : dy / dx;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">auto</span> color_compose = [&amp;](int32_t x, int32_t y, <span class="keywordtype">float</span> a) {</div>
<div class="line">            <span class="keywordflow">if</span> (a &lt; epsilon_low) {</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (a &gt;= epsilon_high) {</div>
<div class="line">                plot(x, y, col);</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                compose(x, y, a, Rl * a, Gl * a, Bl * a);</div>
<div class="line">            }</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// first endpoint</span></div>
<div class="line">        <span class="keywordtype">float</span> xend = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(x0);</div>
<div class="line">        <span class="keywordtype">float</span> yend = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(y0) + gradient * (xend - <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(x0));</div>
<div class="line">        <span class="keywordtype">float</span> xgap = rfpart(<span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(x0) + 0.5f);</div>
<div class="line">        int32_t xpxl1 = <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(xend);</div>
<div class="line">        int32_t ypxl1 = <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ipart(yend));</div>
<div class="line">        <span class="keywordflow">if</span> (steep) {</div>
<div class="line">            color_compose(ypxl1, xpxl1, rfpart(yend) * xgap);</div>
<div class="line">            color_compose(ypxl1 + 1, xpxl1, fpart(yend) * xgap);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            color_compose(xpxl1, ypxl1, rfpart(yend) * xgap);</div>
<div class="line">            color_compose(xpxl1, ypxl1 + 1, fpart(yend) * xgap);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordtype">float</span> intery = yend + gradient;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// second endpoint</span></div>
<div class="line">        xend = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(x1);</div>
<div class="line">        yend = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(y1) + gradient * (xend - <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(x1));</div>
<div class="line">        xgap = fpart(<span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(x1) + 0.5f);</div>
<div class="line">        int32_t xpxl2 = <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(xend);</div>
<div class="line">        int32_t ypxl2 = <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ipart(yend));</div>
<div class="line">        <span class="keywordflow">if</span> (steep) {</div>
<div class="line">            color_compose(ypxl2, xpxl2, rfpart(yend) * xgap);</div>
<div class="line">            color_compose(ypxl2 + 1, xpxl2, fpart(yend) * xgap);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            color_compose(xpxl2, ypxl2, rfpart(yend) * xgap);</div>
<div class="line">            color_compose(xpxl2, ypxl2 + 1, fpart(yend) * xgap);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// main loop</span></div>
<div class="line">        <span class="keywordflow">for</span> (int32_t x = xpxl1 + 1; x &lt; xpxl2; ++x) {</div>
<div class="line">            int32_t y = <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ipart(intery));</div>
<div class="line">            <span class="keywordflow">if</span> (steep) {</div>
<div class="line">                color_compose(y, x, rfpart(intery));</div>
<div class="line">                color_compose(y + 1, x, fpart(intery));</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                color_compose(x, y, rfpart(intery));</div>
<div class="line">                color_compose(x, y + 1, fpart(intery));</div>
<div class="line">            }</div>
<div class="line">            intery += gradient;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> draw_line_aa(<span class="keyword">const</span> rect&lt;int32_t&gt; &amp;rect, uint8_t col) {</div>
<div class="line">        draw_line_aa(rect.x, rect.y, rect.x + rect.w, rect.y + rect.h, col);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> plot(int32_t x, int32_t y, uint8_t col) {</div>
<div class="line">        <span class="keywordflow">if</span> (x &lt; 0 || x &gt;= <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(W) || y &lt; 0 || y &gt;= <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(H)) {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">        T&lt;W, H, S, GR&gt;::plot(data, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(x), <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(y), col);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    [[nodiscard]] <span class="keyword">constexpr</span> uint8_t get_nearest_color(uint8_t r, uint8_t g, uint8_t b)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> format.quant.nearest(r, g, b);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FONT, <span class="keywordtype">bool</span> KERNING = false&gt;</div>
<div class="line">    [[nodiscard]] <span class="keyword">constexpr</span> int32_t string_width(<span class="keyword">const</span> <span class="keywordtype">char</span> *str) {</div>
<div class="line">        int32_t x = 0;</div>
<div class="line">        <span class="keywordflow">while</span> (*str != 0) {</div>
<div class="line">            uint32_t utf32 = 0;</div>
<div class="line">            str = get_next_utf32(str, &amp;utf32);</div>
<div class="line">            uint32_t index = 0;</div>
<div class="line">            <span class="keywordflow">if</span> (lookup_glyph&lt;FONT&gt;(utf32, &amp;index)) {</div>
<div class="line">                <span class="keyword">const</span> char_info &amp;ch_info = FONT::char_table.at(index);</div>
<div class="line">                <span class="keywordflow">if</span> (*str == 0) {</div>
<div class="line">                    x += ch_info.width;</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    x += ch_info.xadvance;</div>
<div class="line">                    <span class="keywordflow">if</span> (KERNING) {</div>
<div class="line">                        x += get_kerning&lt;FONT&gt;(utf32, str);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> x;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FONT, <span class="keywordtype">bool</span> KERNING = false, text_rotation ROTATION = DEGREE_0&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> int32_t draw_string_mono(int32_t x, int32_t y, <span class="keyword">const</span> <span class="keywordtype">char</span> *str, uint8_t col) {</div>
<div class="line">        <span class="keyword">static_assert</span>(FONT::mono == <span class="keyword">true</span>, <span class="stringliteral">&quot;Can&#39;t use an antialiased font to draw mono/pixelized text.&quot;</span>);</div>
<div class="line">        <span class="keywordflow">while</span> (*str != 0) {</div>
<div class="line">            uint32_t utf32 = 0;</div>
<div class="line">            str = get_next_utf32(str, &amp;utf32);</div>
<div class="line">            uint32_t index = 0;</div>
<div class="line">            <span class="keywordflow">if</span> (lookup_glyph&lt;FONT&gt;(utf32, &amp;index)) {</div>
<div class="line">                <span class="keyword">const</span> char_info &amp;ch_info = FONT::char_table.at(index);</div>
<div class="line">                draw_char_mono&lt;FONT, ROTATION&gt;(x, y, ch_info, col);</div>
<div class="line">                <span class="keywordflow">if</span> (ROTATION == DEGREE_0) {</div>
<div class="line">                    x += ch_info.xadvance;</div>
<div class="line">                    <span class="keywordflow">if</span> (KERNING) {</div>
<div class="line">                        x += get_kerning&lt;FONT&gt;(utf32, str);</div>
<div class="line">                    }</div>
<div class="line">                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ROTATION == DEGREE_90) {</div>
<div class="line">                    y += ch_info.xadvance;</div>
<div class="line">                    <span class="keywordflow">if</span> (KERNING) {</div>
<div class="line">                        y += get_kerning&lt;FONT&gt;(utf32, str);</div>
<div class="line">                    }</div>
<div class="line">                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ROTATION == DEGREE_180) {</div>
<div class="line">                    x -= ch_info.xadvance;</div>
<div class="line">                    <span class="keywordflow">if</span> (KERNING) {</div>
<div class="line">                        x -= get_kerning&lt;FONT&gt;(utf32, str);</div>
<div class="line">                    }</div>
<div class="line">                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ROTATION == DEGREE_270) {</div>
<div class="line">                    y -= ch_info.xadvance;</div>
<div class="line">                    <span class="keywordflow">if</span> (KERNING) {</div>
<div class="line">                        y -= get_kerning&lt;FONT&gt;(utf32, str);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (ROTATION == DEGREE_90 || ROTATION == DEGREE_270) {</div>
<div class="line">            <span class="keywordflow">return</span> y;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> x;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FONT, <span class="keywordtype">bool</span> KERNING = false, text_rotation ROTATION = DEGREE_0&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> draw_string_centered_mono(int32_t cx, int32_t y, <span class="keyword">const</span> <span class="keywordtype">char</span> *str, uint8_t col) {</div>
<div class="line">        <span class="keywordflow">if</span> (ROTATION == DEGREE_0) {</div>
<div class="line">            draw_string_mono&lt;FONT, KERNING, ROTATION&gt;(cx - string_width&lt;FONT, KERNING&gt;(str) / 2, y, str, col);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ROTATION == DEGREE_180) {</div>
<div class="line">            draw_string_mono&lt;FONT, KERNING, ROTATION&gt;(cx + string_width&lt;FONT, KERNING&gt;(str) / 2, y, str, col);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ROTATION == DEGREE_90) {</div>
<div class="line">            draw_string_mono&lt;FONT, KERNING, ROTATION&gt;(cx, y + string_width&lt;FONT, KERNING&gt;(str) / 2, str, col);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ROTATION == DEGREE_270) {</div>
<div class="line">            draw_string_mono&lt;FONT, KERNING, ROTATION&gt;(cx, y - string_width&lt;FONT, KERNING&gt;(str) / 2, str, col);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FONT, <span class="keywordtype">bool</span> KERNING = false, text_rotation ROTATION = DEGREE_0&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> int32_t draw_string_aa(int32_t x, int32_t y, <span class="keyword">const</span> <span class="keywordtype">char</span> *str, uint8_t col) {</div>
<div class="line">        <span class="keyword">static_assert</span>(FONT::mono == <span class="keyword">false</span>, <span class="stringliteral">&quot;Can&#39;t use a mono font to draw antialiased text.&quot;</span>);</div>
<div class="line">        <span class="keywordflow">while</span> (*str != 0) {</div>
<div class="line">            uint32_t utf32 = 0;</div>
<div class="line">            str = get_next_utf32(str, &amp;utf32);</div>
<div class="line">            uint32_t index = 0;</div>
<div class="line">            <span class="keywordflow">if</span> (lookup_glyph&lt;FONT&gt;(utf32, &amp;index)) {</div>
<div class="line">                <span class="keyword">const</span> char_info &amp;ch_info = FONT::char_table.at(index);</div>
<div class="line">                draw_char_aa&lt;FONT, ROTATION&gt;(x, y, ch_info, col);</div>
<div class="line">                <span class="keywordflow">if</span> (ROTATION == DEGREE_0) {</div>
<div class="line">                    x += ch_info.xadvance;</div>
<div class="line">                    <span class="keywordflow">if</span> (KERNING) {</div>
<div class="line">                        x += get_kerning&lt;FONT&gt;(utf32, str);</div>
<div class="line">                    }</div>
<div class="line">                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ROTATION == DEGREE_90) {</div>
<div class="line">                    y += ch_info.xadvance;</div>
<div class="line">                    <span class="keywordflow">if</span> (KERNING) {</div>
<div class="line">                        y += get_kerning&lt;FONT&gt;(utf32, str);</div>
<div class="line">                    }</div>
<div class="line">                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ROTATION == DEGREE_180) {</div>
<div class="line">                    x -= ch_info.xadvance;</div>
<div class="line">                    <span class="keywordflow">if</span> (KERNING) {</div>
<div class="line">                        x -= get_kerning&lt;FONT&gt;(utf32, str);</div>
<div class="line">                    }</div>
<div class="line">                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ROTATION == DEGREE_270) {</div>
<div class="line">                    y -= ch_info.xadvance;</div>
<div class="line">                    <span class="keywordflow">if</span> (KERNING) {</div>
<div class="line">                        y -= get_kerning&lt;FONT&gt;(utf32, str);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (ROTATION == DEGREE_90 || ROTATION == DEGREE_270) {</div>
<div class="line">            <span class="keywordflow">return</span> y;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> x;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FONT, <span class="keywordtype">bool</span> KERNING = false, text_rotation ROTATION = DEGREE_0&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> draw_string_centered_aa(int32_t cx, int32_t y, <span class="keyword">const</span> <span class="keywordtype">char</span> *str, uint8_t col) {</div>
<div class="line">        <span class="keywordflow">if</span> (ROTATION == DEGREE_0) {</div>
<div class="line">            draw_string_aa&lt;FONT, KERNING, ROTATION&gt;(cx - string_width&lt;FONT, KERNING&gt;(str) / 2, y, str, col);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ROTATION == DEGREE_180) {</div>
<div class="line">            draw_string_aa&lt;FONT, KERNING, ROTATION&gt;(cx + string_width&lt;FONT, KERNING&gt;(str) / 2, y, str, col);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ROTATION == DEGREE_90) {</div>
<div class="line">            draw_string_aa&lt;FONT, KERNING, ROTATION&gt;(cx, y + string_width&lt;FONT, KERNING&gt;(str) / 2, str, col);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ROTATION == DEGREE_270) {</div>
<div class="line">            draw_string_aa&lt;FONT, KERNING, ROTATION&gt;(cx, y - string_width&lt;FONT, KERNING&gt;(str) / 2, str, col);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> fill_rect(int32_t x, int32_t y, int32_t w, int32_t h, uint8_t col) {</div>
<div class="line">        <span class="keywordflow">if</span> (y &lt; 0) {</div>
<div class="line">            h += y;</div>
<div class="line">            y = 0;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (y + h &gt;= <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(H)) {</div>
<div class="line">            h = <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(H) - y;</div>
<div class="line">        }</div>
<div class="line">        h += y;</div>
<div class="line">        <span class="keywordflow">for</span> (; y &lt; h; y++) {</div>
<div class="line">            span(x, w, y, col);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> fill_rect(<span class="keyword">const</span> rect&lt;int32_t&gt; &amp;rect, uint8_t col) {</div>
<div class="line">        fill_rect(rect.x, rect.y, rect.w, rect.h, col);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> stroke_rect(int32_t x, int32_t y, int32_t w, int32_t h, uint8_t col, uint32_t stroke_width = 1) {</div>
<div class="line">        draw_line(x, y, x + w, y, col, stroke_width);</div>
<div class="line">        draw_line(x + w, y, x + w, y + h, col, stroke_width);</div>
<div class="line">        draw_line(x + w, y + h, x, y + h, col, stroke_width);</div>
<div class="line">        draw_line(x, y + h, x, y, col, stroke_width);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> stroke_rect(<span class="keyword">const</span> rect&lt;int32_t&gt; &amp;rect, uint8_t col, uint32_t stroke_width = 1) {</div>
<div class="line">        stroke_rect(rect.x, rect.y, rect.w, rect.h, col, stroke_width);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> fill_circle(int32_t cx, int32_t cy, int32_t radius, uint8_t col) {</div>
<div class="line">        <span class="keywordflow">if</span> (radius == 1) {</div>
<div class="line">            fill_rect(cx - 1, cy - 1, 2, 2, col);</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">        fill_arc(cx, cy - 1, radius, 9, 0, col);</div>
<div class="line">        fill_arc(cx, cy, radius, 10, 0, col);</div>
<div class="line">        fill_arc(cx, cy - 1, radius, 1, -1, col);</div>
<div class="line">        fill_arc(cx, cy, radius, 2, -1, col);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> fill_circle_aa(int32_t cx, int32_t cy, int32_t radius, uint8_t col) {</div>
<div class="line">        fill_circle_aa_int(cx, cy, radius, 0, 0, col);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> fill_round_rect(int32_t x, int32_t y, int32_t w, int32_t h, int32_t radius, uint8_t col) {</div>
<div class="line">        int32_t cr = std::min((w) / 2, std::min((w) / 2, radius));</div>
<div class="line">        int32_t dx = w - cr * 2;</div>
<div class="line">        int32_t dy = h - cr * 2;</div>
<div class="line">        fill_arc(x + cr, y + h - cr - 1, cr, 9, 0, col);</div>
<div class="line">        fill_arc(x + cr, y + cr, cr, 10, 0, col);</div>
<div class="line">        fill_arc(x + w - cr, y + h - cr - 1, cr, 1, -1, col);</div>
<div class="line">        fill_arc(x + w - cr, y + cr, cr, 2, -1, col);</div>
<div class="line">        fill_rect(x, y + cr, cr, dy, col);</div>
<div class="line">        fill_rect(x + w - cr, y + cr, cr, dy, col);</div>
<div class="line">        fill_rect(x + cr, y, dx, h, col);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> fill_round_rect(<span class="keyword">const</span> rect&lt;int32_t&gt; &amp;rect, int32_t radius, uint8_t col) {</div>
<div class="line">        stroke_rect(rect.x, rect.y, rect.w, rect.h, radius, col);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> fill_round_rect_aa(int32_t x, int32_t y, int32_t w, int32_t h, int32_t radius, uint8_t col) {</div>
<div class="line">        int32_t cr = std::min((w) / 2, std::min((w) / 2, radius));</div>
<div class="line">        int32_t dx = w - cr * 2;</div>
<div class="line">        int32_t dy = h - cr * 2;</div>
<div class="line">        fill_circle_aa_int(x + cr, y + cr, cr, dx, dy, col);</div>
<div class="line">        fill_rect(x, y + cr, cr, dy, col);</div>
<div class="line">        fill_rect(x + w - cr, y + cr, cr, dy, col);</div>
<div class="line">        fill_rect(x + cr, y, dx, h, col);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> fill_round_rect_aa(<span class="keyword">const</span> rect&lt;int32_t&gt; &amp;rect, int32_t radius, uint8_t col) {</div>
<div class="line">        fill_round_rect_aa(rect.x, rect.y, rect.w, rect.h, radius, col);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    [[nodiscard]] <span class="keyword">constexpr</span> std::array&lt;uint32_t, W * H&gt; RGBA_uint32()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> T&lt;W, H, S, GR&gt;::RGBA_uint32(data);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    [[nodiscard]] <span class="keyword">constexpr</span> std::array&lt;uint8_t, W * H * 4&gt; RGBA_uint8()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> T&lt;W, H, S, GR&gt;::RGBA_uint8(data);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> flip_h() {</div>
<div class="line">        uint8_t *ptr = data.data();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; H; y++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; bytes_per_line() / 2; x++) {</div>
<div class="line">                uint8_t a = T&lt;W, H, S, GR&gt;::reverse(ptr[x]);</div>
<div class="line">                uint8_t b = T&lt;W, H, S, GR&gt;::reverse(ptr[bytes_per_line() - x - 1]);</div>
<div class="line">                ptr[x] = b;</div>
<div class="line">                ptr[bytes_per_line() - x - 1] = a;</div>
<div class="line">            }</div>
<div class="line">            ptr += bytes_per_line();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> flip_v() {</div>
<div class="line">        uint8_t *ptr = data.data();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; bytes_per_line(); x++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; H / 2; y++) {</div>
<div class="line">                uint8_t *ptr_a = ptr + y * bytes_per_line();</div>
<div class="line">                uint8_t *ptr_b = ptr + (H - y - 1) * bytes_per_line();</div>
<div class="line">                uint8_t a = ptr_a[x];</div>
<div class="line">                uint8_t b = ptr_b[x];</div>
<div class="line">                ptr_a[x] = b;</div>
<div class="line">                ptr_b[x] = a;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> flip_hv() {</div>
<div class="line">        uint8_t *ptr = data.data();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; bytes_per_line(); x++) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; H / 2; y++) {</div>
<div class="line">                uint8_t *ptr_a = ptr + y * bytes_per_line();</div>
<div class="line">                uint8_t *ptr_b = ptr + (H - y - 1) * bytes_per_line();</div>
<div class="line">                uint8_t a = T&lt;W, H, S, GR&gt;::reverse(ptr_a[x]);</div>
<div class="line">                uint8_t b = T&lt;W, H, S, GR&gt;::reverse(ptr_b[bytes_per_line() - x - 1]);</div>
<div class="line">                ptr_a[x] = b;</div>
<div class="line">                ptr_b[bytes_per_line() - x - 1] = a;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> image&lt;T, H, W, S, GR&gt; transpose()<span class="keyword"> const </span>{</div>
<div class="line">        image&lt;T, H, W, S, GR&gt; transposed;</div>
<div class="line">        <span class="keyword">static_assert</span>(T&lt;W, H, S, GR&gt;::bits_per_pixel != 1 || ((H + 7) / 8) == transposed.bytes_per_line());</div>
<div class="line">        <span class="keyword">static_assert</span>(T&lt;W, H, S, GR&gt;::bits_per_pixel != 1 || ((W + 7) / 8) == bytes_per_line());</div>
<div class="line">        T&lt;W, H, S, GR&gt;::transpose(data.data(), transposed.data_ref().data());</div>
<div class="line">        <span class="keywordflow">return</span> transposed;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> transpose(image&lt;T, H, W, S, GR&gt; &amp;dst)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keyword">static_assert</span>(T&lt;W, H, S, GR&gt;::bits_per_pixel != 1 || ((H + 7) / 8) == dst.bytes_per_line());</div>
<div class="line">        <span class="keyword">static_assert</span>(T&lt;W, H, S, GR&gt;::bits_per_pixel != 1 || ((W + 7) / 8) == bytes_per_line());</div>
<div class="line">        T&lt;W, H, S, GR&gt;::transpose(data, dst.data);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> blit_RGBA(int32_t x, int32_t y, int32_t w, int32_t h, <span class="keyword">const</span> uint8_t *ptr, int32_t iw, int32_t ih, int32_t stride) {</div>
<div class="line">        rect&lt;int32_t&gt; blitrect{x, y, w, h};</div>
<div class="line">        blitrect &amp;= {0, 0, W, H};</div>
<div class="line">        blitrect &amp;= {x, y, iw, ih};</div>
<div class="line">        T&lt;W, H, S, GR&gt;::blit_RGBA(data, blitrect, ptr, stride);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> blit_RGBA(<span class="keyword">const</span> rect&lt;int32_t&gt; &amp;dstrect, <span class="keyword">const</span> uint8_t *ptr, int32_t iw, int32_t ih, int32_t stride) {</div>
<div class="line">        rect&lt;int32_t&gt; blitrect{dstrect};</div>
<div class="line">        blitrect &amp;= {0, 0, W, H};</div>
<div class="line">        blitrect &amp;= {dstrect.x, dstrect.y, iw, ih};</div>
<div class="line">        T&lt;W, H, S, GR&gt;::blit_RGBA(data, blitrect, ptr, stride);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> blit_RGBA_diffused(int32_t x, int32_t y, int32_t w, int32_t h, <span class="keyword">const</span> uint8_t *ptr, int32_t iw, int32_t ih, int32_t stride) {</div>
<div class="line">        rect&lt;int32_t&gt; blitrect{x, y, w, h};</div>
<div class="line">        blitrect &amp;= {0, 0, W, H};</div>
<div class="line">        blitrect &amp;= {x, y, iw, ih};</div>
<div class="line">        T&lt;W, H, S, GR&gt;::blit_RGBA_diffused(data, blitrect, ptr, stride);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> blit_RGBA_diffused(<span class="keyword">const</span> rect&lt;int32_t&gt; &amp;dstrect, <span class="keyword">const</span> uint8_t *ptr, int32_t iw, int32_t ih, int32_t stride) {</div>
<div class="line">        rect&lt;int32_t&gt; blitrect{dstrect};</div>
<div class="line">        blitrect &amp;= {0, 0, W, H};</div>
<div class="line">        blitrect &amp;= {dstrect.x, dstrect.y, iw, ih};</div>
<div class="line">        T&lt;W, H, S, GR&gt;::blit_RGBA_diffused(data, blitrect, ptr, stride);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> blit_RGBA_diffused_linear(int32_t x, int32_t y, int32_t w, int32_t h, <span class="keyword">const</span> uint8_t *ptr, int32_t iw, int32_t ih, int32_t stride) {</div>
<div class="line">        rect&lt;int32_t&gt; blitrect{x, y, w, h};</div>
<div class="line">        blitrect &amp;= {0, 0, W, H};</div>
<div class="line">        blitrect &amp;= {x, y, iw, ih};</div>
<div class="line">        T&lt;W, H, S, GR&gt;::blit_RGBA_diffused_linear(data, blitrect, ptr, stride);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> blit_RGBA_diffused_linear(<span class="keyword">const</span> rect&lt;int32_t&gt; &amp;dstrect, <span class="keyword">const</span> uint8_t *ptr, int32_t iw, int32_t ih, int32_t stride) {</div>
<div class="line">        rect&lt;int32_t&gt; blitrect{dstrect};</div>
<div class="line">        blitrect &amp;= {0, 0, W, H};</div>
<div class="line">        blitrect &amp;= {dstrect.x, dstrect.y, iw, ih};</div>
<div class="line">        T&lt;W, H, S, GR&gt;::blit_RGBA_diffused_linear(data, blitrect, ptr, stride);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> png(F &amp;&amp;char_out)<span class="keyword"> const </span>{</div>
<div class="line">        T&lt;W, H, S, GR&gt;::png(data, char_out);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> sixel(F &amp;&amp;char_out)<span class="keyword"> const </span>{</div>
<div class="line">        T&lt;W, H, S, GR&gt;::sixel(data, char_out, {0, 0, W, H});</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> sixel(F &amp;&amp;char_out, <span class="keyword">const</span> rect&lt;int32_t&gt; &amp;rect)<span class="keyword"> const </span>{</div>
<div class="line">        T&lt;W, H, S, GR&gt;::sixel(data, char_out, rect);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> sixel_to_cout()<span class="keyword"> const </span>{</div>
<div class="line">        std::string out;</div>
<div class="line">        T&lt;W, H, S, GR&gt;::sixel(data,</div>
<div class="line">                              [&amp;out](<span class="keywordtype">char</span> ch) <span class="keyword">mutable</span> {</div>
<div class="line">                                  out.push_back(ch);</div>
<div class="line">                              },</div>
<div class="line">                              {0, 0, W, H});</div>
<div class="line">        std::cout &lt;&lt; out &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> vt100_clear()<span class="keyword"> const </span>{</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;\033[2J\033[H&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> vt100_home()<span class="keyword"> const </span>{</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;\033[H&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> png_to_iterm()<span class="keyword"> const </span>{</div>
<div class="line">        std::string output;</div>
<div class="line">        output.append(<span class="stringliteral">&quot;\033]1337;File=inline=1:&quot;</span>);</div>
<div class="line">        append_png_as_base64(output);</div>
<div class="line">        output.append(<span class="stringliteral">&quot;\07&quot;</span>);</div>
<div class="line">        std::cout &lt;&lt; output &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> png_to_kitty()<span class="keyword"> const </span>{</div>
<div class="line">        std::string base64{};</div>
<div class="line">        std::string output{};</div>
<div class="line">        append_png_as_base64(base64);</div>
<div class="line">        <span class="keywordtype">bool</span> first = <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (; base64.length();) {</div>
<div class="line">            <span class="keywordflow">if</span> (first) {</div>
<div class="line">                first = <span class="keyword">false</span>;</div>
<div class="line">                output.append(<span class="stringliteral">&quot;\033_Ga=T,f=100,&quot;</span>);</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                output.append(<span class="stringliteral">&quot;\033_G&quot;</span>);</div>
<div class="line">            }</div>
<div class="line">            output.append(base64.length() &lt;= 4096 ? <span class="stringliteral">&quot;m=0;&quot;</span> : <span class="stringliteral">&quot;m=1;&quot;</span>);</div>
<div class="line">            <span class="keywordtype">size_t</span> bytes_to_append = std::min(base64.length(), <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(4096));</div>
<div class="line">            output.append(base64.substr(0, bytes_to_append));</div>
<div class="line">            base64.erase(0, bytes_to_append);</div>
<div class="line">            output.append(<span class="stringliteral">&quot;\033\\&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; output &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">enum</span> device_format {</div>
<div class="line">        STRAIGHT_THROUGH,      </div>
<div class="line">        X_LEFT_TO_RIGHT_1BIT,  </div>
<div class="line">        Y_TOP_TO_BOTTOM_1BIT,  </div>
<div class="line">        RGB565_8BIT_SERIAL,    </div>
<div class="line">                               <span class="comment">//   Byte encoding: 0xRRRRRGGG 0xGGGBBBBB</span></div>
<div class="line">        RGB666_8BIT_SERIAL_1,  </div>
<div class="line">                               <span class="comment">//   Byte encoding: 0x00RRRRRR 0x00GGGGGG 0x00BBBBBB</span></div>
<div class="line">        RGB666_8BIT_SERIAL_2   </div>
<div class="line">                               <span class="comment">//   Byte encoding: 0xRRRRRR00 0xGGGGGG00 0xBBBBBB00</span></div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;device_format dst_format&gt;</div>
<div class="line">    <span class="keywordtype">bool</span> convert_chunk(<span class="keywordtype">char</span> *dst, <span class="keywordtype">size_t</span> chunk_size, <span class="keywordtype">size_t</span> &amp;chunk_actual, <span class="keywordtype">size_t</span> &amp;chunk_index) {</div>
<div class="line">        (void)dst;</div>
<div class="line">        (void)chunk_size;</div>
<div class="line">        (void)chunk_actual;</div>
<div class="line">        (void)chunk_index;</div>
<div class="line">        (void)dst_format;</div>
<div class="line">        <span class="keywordflow">switch</span> (dst_format) {</div>
<div class="line">            <span class="keywordflow">default</span>: {</div>
<div class="line">            } <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> STRAIGHT_THROUGH: {</div>
<div class="line">            } <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> X_LEFT_TO_RIGHT_1BIT: {</div>
<div class="line">            } <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> Y_TOP_TO_BOTTOM_1BIT: {</div>
<div class="line">            } <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> RGB565_8BIT_SERIAL: {</div>
<div class="line">            } <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> RGB666_8BIT_SERIAL_1: {</div>
<div class="line">            } <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> RGB666_8BIT_SERIAL_2: {</div>
<div class="line">            } <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, device_format dst_format&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> convert(F &amp;&amp;char_out) {</div>
<div class="line">        <span class="keywordflow">switch</span> (dst_format) {</div>
<div class="line">            <span class="keywordflow">default</span>: {</div>
<div class="line">            } <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> STRAIGHT_THROUGH: {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keyword">auto</span> c : data) {</div>
<div class="line">                    char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(c));</div>
<div class="line">                }</div>
<div class="line">            } <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> X_LEFT_TO_RIGHT_1BIT: {</div>
<div class="line">                <span class="keyword">static_assert</span>(std::is_same_v&lt;T&lt;W, H, S, GR&gt;, format_1bit&lt;W, H, S, GR&gt;&gt;, <span class="stringliteral">&quot;T must be format_1bit&quot;</span>);</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keyword">auto</span> c : data) {</div>
<div class="line">                    char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(c));</div>
<div class="line">                }</div>
<div class="line">            } <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> Y_TOP_TO_BOTTOM_1BIT: {</div>
<div class="line">                <span class="keyword">static_assert</span>(std::is_same_v&lt;T&lt;W, H, S, GR&gt;, format_1bit&lt;W, H, S, GR&gt;&gt;, <span class="stringliteral">&quot;T must be format_1bit&quot;</span>);</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; W; x++) {</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; H; y += 8) {</div>
<div class="line">                        uint8_t b = (data[(y + 0) * format.bytes_per_line + x] &lt;&lt; 7) | (data[(y + 1) * format.bytes_per_line + x] &lt;&lt; 6) |</div>
<div class="line">                                    (data[(y + 2) * format.bytes_per_line + x] &lt;&lt; 5) | (data[(y + 3) * format.bytes_per_line + x] &lt;&lt; 4) |</div>
<div class="line">                                    (data[(y + 4) * format.bytes_per_line + x] &lt;&lt; 3) | (data[(y + 5) * format.bytes_per_line + x] &lt;&lt; 2) |</div>
<div class="line">                                    (data[(y + 6) * format.bytes_per_line + x] &lt;&lt; 1) | (data[(y + 7) * format.bytes_per_line + x] &lt;&lt; 0);</div>
<div class="line">                        char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(b));</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            } <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> RGB565_8BIT_SERIAL: {</div>
<div class="line">                <span class="keyword">const</span> uint8_t *ptr = data.data();</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; H; y++) {</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; W; x++) {</div>
<div class="line">                        uint32_t col = format.get_col(ptr, x);</div>
<div class="line">                        uint32_t a = ((((col &gt;&gt; 16) &amp; 0xff) &gt;&gt; 3) &lt;&lt; 3) | ((((col &gt;&gt; 8) &amp; 0xff) &gt;&gt; 2) &gt;&gt; 3);</div>
<div class="line">                        uint32_t b = (((((col &gt;&gt; 8) &amp; 0xff) &gt;&gt; 2) &amp; 0x7) &lt;&lt; 5) | ((col &amp; 0xff) &gt;&gt; 3);</div>
<div class="line">                        char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(a));</div>
<div class="line">                        char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(b));</div>
<div class="line">                    }</div>
<div class="line">                    ptr += format.bytes_per_line;</div>
<div class="line">                }</div>
<div class="line">            } <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> RGB666_8BIT_SERIAL_1: {</div>
<div class="line">                <span class="keyword">const</span> uint8_t *ptr = data.data();</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; H; y++) {</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; W; x++) {</div>
<div class="line">                        uint32_t col = format.get_col(ptr, x);</div>
<div class="line">                        char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(((col &gt;&gt; 16) &amp; 0xff) &gt;&gt; 2));</div>
<div class="line">                        char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(((col &gt;&gt; 8) &amp; 0xff) &gt;&gt; 2));</div>
<div class="line">                        char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(((col &gt;&gt; 0) &amp; 0xff) &gt;&gt; 2));</div>
<div class="line">                    }</div>
<div class="line">                    ptr += format.bytes_per_line;</div>
<div class="line">                }</div>
<div class="line">            } <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> RGB666_8BIT_SERIAL_2: {</div>
<div class="line">                <span class="keyword">const</span> uint8_t *ptr = data.data();</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> y = 0; y &lt; H; y++) {</div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; W; x++) {</div>
<div class="line">                        uint32_t col = format.get_col(ptr, x);</div>
<div class="line">                        char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(((col &gt;&gt; 16) &amp; 0xff) &gt;&gt; 2) &lt;&lt; 2);</div>
<div class="line">                        char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(((col &gt;&gt; 8) &amp; 0xff) &gt;&gt; 2) &lt;&lt; 2);</div>
<div class="line">                        char_out(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(((col &gt;&gt; 0) &amp; 0xff) &gt;&gt; 2) &lt;&lt; 2);</div>
<div class="line">                    }</div>
<div class="line">                    ptr += format.bytes_per_line;</div>
<div class="line">                }</div>
<div class="line">            } <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> abs_T&gt;</div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">constexpr</span> abs_T abs(abs_T v) {</div>
<div class="line">        <span class="keywordflow">return</span> v &lt; 0 ? -v : v;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FONT&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> lookup_glyph(uint32_t utf32, uint32_t *glyph_index) {</div>
<div class="line">        <span class="keyword">auto</span> index = FONT::glyph_tree.lookup(<span class="keyword">static_cast&lt;</span>FONT::lookup_type<span class="keyword">&gt;</span>(utf32));</div>
<div class="line">        <span class="keywordflow">if</span> (index == FONT::glyph_tree.invalid) {</div>
<div class="line">            index = FONT::glyph_tree.lookup(<span class="keyword">static_cast&lt;</span>FONT::lookup_type<span class="keyword">&gt;</span>(0xFFFD));</div>
<div class="line">            <span class="keywordflow">if</span> (index == FONT::glyph_tree.invalid) {</div>
<div class="line">                index = FONT::glyph_tree.lookup(<span class="keyword">static_cast&lt;</span>FONT::lookup_type<span class="keyword">&gt;</span>(0x0000));</div>
<div class="line">                <span class="keywordflow">if</span> (index == FONT::glyph_tree.invalid) {</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        *glyph_index = index;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FONT&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> int32_t get_kerning(uint32_t utf32, <span class="keyword">const</span> <span class="keywordtype">char</span> *str)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (FONT::kerning_tree.byte_size()) {</div>
<div class="line">            uint32_t utf_l = utf32;</div>
<div class="line">            uint32_t utf_r = 0;</div>
<div class="line">            get_next_utf32(str, &amp;utf_r);</div>
<div class="line">            <span class="keyword">auto</span> amount = FONT::kerning_tree.lookup(<span class="keyword">static_cast&lt;</span>FONT::kerning_lookup_type<span class="keyword">&gt;</span>(utf_l &lt;&lt; FONT::kerning_code_shift | utf_r));</div>
<div class="line">            <span class="keywordflow">if</span> (amount != FONT::kerning_tree.invalid) {</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(<span class="keyword">static_cast&lt;</span>FONT::kerning_amount_type<span class="keyword">&gt;</span>(amount) -</div>
<div class="line">                                            <span class="keyword">static_cast&lt;</span>FONT::kerning_amount_type<span class="keyword">&gt;</span>(FONT::kerning_amount_offset));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *get_next_utf32(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, uint32_t *utf32)<span class="keyword"> const </span>{</div>
<div class="line">        *utf32 = 0;</div>
<div class="line">        uint32_t lead = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(*str) &amp; 0xFF;</div>
<div class="line">        <span class="keywordflow">if</span> (lead &lt; 0x80) {</div>
<div class="line">            *utf32 = lead;</div>
<div class="line">            str += 1;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((lead &gt;&gt; 5) == 0x06 &amp;&amp; str[1] != 0) {</div>
<div class="line">            *utf32 = ((lead &amp; 0x1F) &lt;&lt; 6) | (<span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(str[1]) &amp; 0x3F);</div>
<div class="line">            str += 2;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((lead &gt;&gt; 4) == 0x0E &amp;&amp; str[1] != 0 &amp;&amp; str[2] != 0) {</div>
<div class="line">            *utf32 = ((lead &amp; 0x0F) &lt;&lt; 12) | ((<span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(str[1]) &amp; 0x3F) &lt;&lt; 6) | (<span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(str[2]) &amp; 0x3F);</div>
<div class="line">            str += 3;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((lead &gt;&gt; 3) == 0x1E &amp;&amp; str[1] != 0 &amp;&amp; str[2] != 0 &amp;&amp; str[3] != 0) {</div>
<div class="line">            *utf32 = ((lead &amp; 0x07) &lt;&lt; 18) | ((<span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(str[1]) &amp; 0x3F) &lt;&lt; 12) | ((<span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(str[2]) &amp; 0x3F) &lt;&lt; 6) |</div>
<div class="line">                     (<span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(str[3]) &amp; 0x3F);</div>
<div class="line">            str += 4;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            str += 1;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> str;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> compose(int32_t x, int32_t y, <span class="keywordtype">float</span> cola, <span class="keywordtype">float</span> colr, <span class="keywordtype">float</span> colg, <span class="keywordtype">float</span> colb) {</div>
<div class="line">        <span class="keywordflow">if</span> (x &lt; 0 || x &gt;= <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(W) || y &lt; 0 || y &gt;= <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(H)) {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">        T&lt;W, H, S, GR&gt;::compose(data, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(x), <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(y), cola, colr, colg, colb);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> append_png_as_base64(std::string &amp;output)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordtype">size_t</span> buffer = 0;</div>
<div class="line">        <span class="keywordtype">size_t</span> bits_collected = 0;</div>
<div class="line">        T&lt;W, H, S, GR&gt;::png(data, [&amp;buffer, &amp;bits_collected, &amp;output](<span class="keywordtype">char</span> <span class="keywordtype">byte</span>) <span class="keyword">mutable</span> {</div>
<div class="line">            <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">char</span> base64_chars[] = <span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</div>
<div class="line"> </div>
<div class="line">            buffer = (buffer &lt;&lt; 8) | static_cast&lt;uint8_t&gt;(<span class="keywordtype">byte</span>);</div>
<div class="line">            bits_collected += 8;</div>
<div class="line">            <span class="keywordflow">while</span> (bits_collected &gt;= 6) {</div>
<div class="line">                bits_collected -= 6;</div>
<div class="line">                output.push_back(base64_chars[(buffer &gt;&gt; bits_collected) &amp; 0x3F]);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> [&amp;output]() <span class="keyword">mutable</span> {</div>
<div class="line">                <span class="keywordflow">if</span> (output.capacity() == 0)</div>
<div class="line">                    <span class="keywordflow">return</span>;</div>
<div class="line">                <span class="keywordflow">if</span> (output.size() % 4) {</div>
<div class="line">                    <span class="keywordtype">size_t</span> padding = 4 - output.size() % 4;</div>
<div class="line">                    <span class="keywordflow">while</span> (padding--) output.push_back(<span class="charliteral">&#39;=&#39;</span>);</div>
<div class="line">                }</div>
<div class="line">            };</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> fill_circle_aa_int(int32_t cx, int32_t cy, int32_t r, int32_t ox, int32_t oy, uint8_t col) {</div>
<div class="line">        int32_t x0 = cx - r - 1;</div>
<div class="line">        int32_t y0 = cy - r - 1;</div>
<div class="line">        <span class="keywordtype">float</span> Rl = format.quant.linearpal.at((col &amp; ((1UL &lt;&lt; format.bits_per_pixel) - 1)) * 3 + 0);</div>
<div class="line">        <span class="keywordtype">float</span> Gl = format.quant.linearpal.at((col &amp; ((1UL &lt;&lt; format.bits_per_pixel) - 1)) * 3 + 1);</div>
<div class="line">        <span class="keywordtype">float</span> Bl = format.quant.linearpal.at((col &amp; ((1UL &lt;&lt; format.bits_per_pixel) - 1)) * 3 + 2);</div>
<div class="line">        <span class="keywordflow">for</span> (int32_t y = y0; y &lt;= cy; ++y) {</div>
<div class="line">            <span class="keywordflow">for</span> (int32_t x = x0; x &lt;= cx; ++x) {</div>
<div class="line">                <span class="keywordtype">float</span> dx = (<span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(x) + 0.5f) - <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(cx);</div>
<div class="line">                <span class="keywordtype">float</span> dy = (<span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(y) + 0.5f) - <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(cy);</div>
<div class="line">                <span class="keywordtype">float</span> dist_sq = dx * dx + dy * dy;</div>
<div class="line">                <span class="keywordtype">float</span> a = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(r) - fast_sqrtf(dist_sq);</div>
<div class="line">                a = std::clamp(a + 0.5f, 0.0f, 1.0f);</div>
<div class="line">                <span class="keywordflow">if</span> (a &gt;= epsilon_low) {</div>
<div class="line">                    int32_t lx = x;</div>
<div class="line">                    int32_t ly = y;</div>
<div class="line">                    int32_t rx = cx + (x0 - x) + r + ox;</div>
<div class="line">                    int32_t ry = cy + (y0 - y) + r + oy;</div>
<div class="line">                    <span class="keywordflow">if</span> (a &gt;= epsilon_high) {</div>
<div class="line">                        plot(lx, ly, col);</div>
<div class="line">                        plot(rx, ly, col);</div>
<div class="line">                        plot(rx, ry, col);</div>
<div class="line">                        plot(lx, ry, col);</div>
<div class="line">                    } <span class="keywordflow">else</span> {</div>
<div class="line">                        compose(lx, ly, a, Rl * a, Gl * a, Bl * a);</div>
<div class="line">                        compose(rx, ly, a, Rl * a, Gl * a, Bl * a);</div>
<div class="line">                        compose(rx, ry, a, Rl * a, Gl * a, Bl * a);</div>
<div class="line">                        compose(lx, ry, a, Rl * a, Gl * a, Bl * a);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FONT, text_rotation ROTATION&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> draw_char_mono(int32_t x, int32_t y, <span class="keyword">const</span> char_info &amp;ch, uint8_t col) {</div>
<div class="line">        <span class="keyword">static_assert</span>(FONT::mono == <span class="keyword">true</span>, <span class="stringliteral">&quot;Can&#39;t use an antialiased font to draw mono/pixelized text.&quot;</span>);</div>
<div class="line">        int32_t ch_data_off = <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ch.y) * <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(FONT::glyph_bitmap_stride) + <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ch.x) / 8;</div>
<div class="line">        <span class="keywordflow">if</span> (ROTATION == DEGREE_0) {</div>
<div class="line">            x += ch.xoffset;</div>
<div class="line">            y += ch.yoffset;</div>
<div class="line">            <span class="keyword">const</span> int32_t x2 = x + <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ch.width);</div>
<div class="line">            <span class="keyword">const</span> int32_t y2 = y + <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ch.height);</div>
<div class="line">            <span class="keywordflow">for</span> (int32_t yy = y; yy &lt; y2; yy++) {</div>
<div class="line">                <span class="keywordflow">for</span> (int32_t xx = x; xx &lt; x2; xx++) {</div>
<div class="line">                    <span class="keyword">const</span> int32_t x_off = (xx - x) + ch.x % 8;</div>
<div class="line">                    <span class="keyword">const</span> int32_t bit_index = 7 - (x_off % 8);</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">size_t</span> byte_index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(ch_data_off + x_off / 8);</div>
<div class="line">                    <span class="keywordflow">if</span> (byte_index &lt; (FONT::glyph_bitmap_stride * FONT::glyph_bitmap_height)) {</div>
<div class="line">                        <span class="keyword">const</span> uint8_t a = (FONT::glyph_bitmap[byte_index] &gt;&gt; bit_index) &amp; 1;</div>
<div class="line">                        <span class="keywordflow">if</span> (a) {</div>
<div class="line">                            plot(xx, yy, col);</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                ch_data_off += FONT::glyph_bitmap_stride;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ROTATION == DEGREE_180) {</div>
<div class="line">            x -= ch.xoffset;</div>
<div class="line">            y -= FONT::ascent;</div>
<div class="line">            <span class="keyword">const</span> int32_t x2 = x - <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ch.width);</div>
<div class="line">            <span class="keyword">const</span> int32_t y2 = y + <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ch.height);</div>
<div class="line">            <span class="keywordflow">for</span> (int32_t yy = y2 - 1; yy &gt;= y; yy--) {</div>
<div class="line">                <span class="keywordflow">for</span> (int32_t xx = x2; xx &lt; x; xx++) {</div>
<div class="line">                    <span class="keyword">const</span> int32_t x_off = (ch.width - (xx - x2) - 1) + ch.x % 8;</div>
<div class="line">                    <span class="keyword">const</span> int32_t bit_index = 7 - (x_off % 8);</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">size_t</span> byte_index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(ch_data_off + x_off / 8);</div>
<div class="line">                    <span class="keywordflow">if</span> (byte_index &lt; (FONT::glyph_bitmap_stride * FONT::glyph_bitmap_height)) {</div>
<div class="line">                        <span class="keyword">const</span> uint8_t a = (FONT::glyph_bitmap[byte_index] &gt;&gt; bit_index) &amp; 1;</div>
<div class="line">                        <span class="keywordflow">if</span> (a) {</div>
<div class="line">                            plot(xx, yy, col);</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                ch_data_off += FONT::glyph_bitmap_stride;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ROTATION == DEGREE_90) {</div>
<div class="line">            x -= FONT::ascent;</div>
<div class="line">            y += ch.xoffset;</div>
<div class="line">            <span class="keyword">const</span> int32_t x2 = x + <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ch.height);</div>
<div class="line">            <span class="keyword">const</span> int32_t y2 = y + <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ch.width);</div>
<div class="line">            <span class="keywordflow">for</span> (int32_t xx = x2 - 1; xx &gt;= x; xx--) {</div>
<div class="line">                <span class="keywordflow">for</span> (int32_t yy = y; yy &lt; y2; yy++) {</div>
<div class="line">                    <span class="keyword">const</span> int32_t x_off = (yy - y) + ch.x % 8;</div>
<div class="line">                    <span class="keyword">const</span> int32_t bit_index = 7 - (x_off % 8);</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">size_t</span> byte_index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(ch_data_off + x_off / 8);</div>
<div class="line">                    <span class="keywordflow">if</span> (byte_index &lt; (FONT::glyph_bitmap_stride * FONT::glyph_bitmap_height)) {</div>
<div class="line">                        <span class="keyword">const</span> uint8_t a = (FONT::glyph_bitmap[byte_index] &gt;&gt; bit_index) &amp; 1;</div>
<div class="line">                        <span class="keywordflow">if</span> (a) {</div>
<div class="line">                            plot(xx, yy, col);</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                ch_data_off += FONT::glyph_bitmap_stride;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ROTATION == DEGREE_270) {</div>
<div class="line">            x += ch.yoffset;</div>
<div class="line">            y -= ch.xoffset;</div>
<div class="line">            <span class="keyword">const</span> int32_t x2 = x + <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ch.height);</div>
<div class="line">            <span class="keyword">const</span> int32_t y2 = y - <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ch.width);</div>
<div class="line">            <span class="keywordflow">for</span> (int32_t xx = x; xx &lt; x2; xx++) {</div>
<div class="line">                <span class="keywordflow">for</span> (int32_t yy = y2; yy &lt; y; yy++) {</div>
<div class="line">                    <span class="keyword">const</span> int32_t x_off = (ch.width - (yy - y2) - 1) + ch.x % 8;</div>
<div class="line">                    <span class="keyword">const</span> int32_t bit_index = 7 - (x_off % 8);</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">size_t</span> byte_index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(ch_data_off + x_off / 8);</div>
<div class="line">                    <span class="keywordflow">if</span> (byte_index &lt; (FONT::glyph_bitmap_stride * FONT::glyph_bitmap_height)) {</div>
<div class="line">                        <span class="keyword">const</span> uint8_t a = (FONT::glyph_bitmap[byte_index] &gt;&gt; bit_index) &amp; 1;</div>
<div class="line">                        <span class="keywordflow">if</span> (a) {</div>
<div class="line">                            plot(xx, yy, col);</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                ch_data_off += FONT::glyph_bitmap_stride;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">consteval</span> <span class="keyword">auto</span> gen_a2al() {</div>
<div class="line">        std::array&lt;float, 16&gt; a2alg{};</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c = 0; c &lt; 16; c++) {</div>
<div class="line">            a2alg[c] = constixel::srgb_to_linear(<span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(c) * (1.0f / 15.0f));</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> a2alg;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> std::array&lt;float, 16&gt; a2al = gen_a2al();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FONT, text_rotation ROTATION&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> draw_char_aa(int32_t x, int32_t y, <span class="keyword">const</span> char_info &amp;ch, uint8_t col) {</div>
<div class="line">        <span class="keyword">static_assert</span>(FONT::mono == <span class="keyword">false</span>, <span class="stringliteral">&quot;Can&#39;t use a mono font to draw antialiased text.&quot;</span>);</div>
<div class="line">        int32_t ch_data_off = <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ch.y) * <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(FONT::glyph_bitmap_stride) + <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ch.x) / 2;</div>
<div class="line">        <span class="keywordtype">float</span> Rl = format.quant.linearpal.at((col &amp; ((1UL &lt;&lt; format.bits_per_pixel) - 1)) * 3 + 0);</div>
<div class="line">        <span class="keywordtype">float</span> Gl = format.quant.linearpal.at((col &amp; ((1UL &lt;&lt; format.bits_per_pixel) - 1)) * 3 + 1);</div>
<div class="line">        <span class="keywordtype">float</span> Bl = format.quant.linearpal.at((col &amp; ((1UL &lt;&lt; format.bits_per_pixel) - 1)) * 3 + 2);</div>
<div class="line">        <span class="keywordflow">if</span> (ROTATION == DEGREE_0) {</div>
<div class="line">            x += ch.xoffset;</div>
<div class="line">            y += ch.yoffset;</div>
<div class="line">            <span class="keyword">const</span> int32_t x2 = x + <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ch.width);</div>
<div class="line">            <span class="keyword">const</span> int32_t y2 = y + <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ch.height);</div>
<div class="line">            <span class="keywordflow">for</span> (int32_t yy = y; yy &lt; y2; yy++) {</div>
<div class="line">                <span class="keywordflow">for</span> (int32_t xx = x; xx &lt; x2; xx++) {</div>
<div class="line">                    <span class="keyword">const</span> int32_t x_off = (xx - x) + ch.x % 2;</div>
<div class="line">                    <span class="keyword">const</span> int32_t bit_index = (1 - (x_off % 2)) * 4;</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">size_t</span> byte_index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(ch_data_off + x_off / 2);</div>
<div class="line">                    <span class="keywordflow">if</span> (byte_index &lt; (FONT::glyph_bitmap_stride * FONT::glyph_bitmap_height)) {</div>
<div class="line">                        <span class="keyword">const</span> uint8_t a = (FONT::glyph_bitmap[byte_index] &gt;&gt; bit_index) &amp; 0xF;</div>
<div class="line">                        <span class="keywordflow">if</span> (a != 0) {</div>
<div class="line">                            <span class="keywordflow">if</span> (a == 0xF) {</div>
<div class="line">                                plot(xx, yy, col);</div>
<div class="line">                            } <span class="keywordflow">else</span> {</div>
<div class="line">                                <span class="keywordtype">float</span> Al = a2al[a];</div>
<div class="line">                                compose(xx, yy, Al, Rl * Al, Gl * Al, Bl * Al);</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                ch_data_off += FONT::glyph_bitmap_stride;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ROTATION == DEGREE_180) {</div>
<div class="line">            x -= ch.xoffset;</div>
<div class="line">            y -= FONT::ascent;</div>
<div class="line">            <span class="keyword">const</span> int32_t x2 = x - <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ch.width);</div>
<div class="line">            <span class="keyword">const</span> int32_t y2 = y + <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ch.height);</div>
<div class="line">            <span class="keywordflow">for</span> (int32_t yy = y2 - 1; yy &gt;= y; yy--) {</div>
<div class="line">                <span class="keywordflow">for</span> (int32_t xx = x2; xx &lt; x; xx++) {</div>
<div class="line">                    <span class="keyword">const</span> int32_t x_off = (ch.width - (xx - x2) - 1) + ch.x % 2;</div>
<div class="line">                    <span class="keyword">const</span> int32_t bit_index = (1 - (x_off % 2)) * 4;</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">size_t</span> byte_index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(ch_data_off + x_off / 2);</div>
<div class="line">                    <span class="keywordflow">if</span> (byte_index &lt; (FONT::glyph_bitmap_stride * FONT::glyph_bitmap_height)) {</div>
<div class="line">                        <span class="keyword">const</span> uint8_t a = (FONT::glyph_bitmap[byte_index] &gt;&gt; bit_index) &amp; 0xF;</div>
<div class="line">                        <span class="keywordflow">if</span> (a != 0) {</div>
<div class="line">                            <span class="keywordflow">if</span> (a == 0xF) {</div>
<div class="line">                                plot(xx, yy, col);</div>
<div class="line">                            } <span class="keywordflow">else</span> {</div>
<div class="line">                                <span class="keywordtype">float</span> Al = a2al[a];</div>
<div class="line">                                compose(xx, yy, Al, Rl * Al, Gl * Al, Bl * Al);</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                ch_data_off += FONT::glyph_bitmap_stride;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ROTATION == DEGREE_90) {</div>
<div class="line">            x -= FONT::ascent;</div>
<div class="line">            y += ch.xoffset;</div>
<div class="line">            <span class="keyword">const</span> int32_t x2 = x + <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ch.height);</div>
<div class="line">            <span class="keyword">const</span> int32_t y2 = y + <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ch.width);</div>
<div class="line">            <span class="keywordflow">for</span> (int32_t xx = x2 - 1; xx &gt;= x; xx--) {</div>
<div class="line">                <span class="keywordflow">for</span> (int32_t yy = y; yy &lt; y2; yy++) {</div>
<div class="line">                    <span class="keyword">const</span> int32_t x_off = (yy - y) + ch.x % 2;</div>
<div class="line">                    <span class="keyword">const</span> int32_t bit_index = (1 - (x_off % 2)) * 4;</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">size_t</span> byte_index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(ch_data_off + x_off / 2);</div>
<div class="line">                    <span class="keywordflow">if</span> (byte_index &lt; (FONT::glyph_bitmap_stride * FONT::glyph_bitmap_height)) {</div>
<div class="line">                        <span class="keyword">const</span> uint8_t a = (FONT::glyph_bitmap[byte_index] &gt;&gt; bit_index) &amp; 0xF;</div>
<div class="line">                        <span class="keywordflow">if</span> (a != 0) {</div>
<div class="line">                            <span class="keywordflow">if</span> (a == 0xF) {</div>
<div class="line">                                plot(xx, yy, col);</div>
<div class="line">                            } <span class="keywordflow">else</span> {</div>
<div class="line">                                <span class="keywordtype">float</span> Al = a2al[a];</div>
<div class="line">                                compose(xx, yy, Al, Rl * Al, Gl * Al, Bl * Al);</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                ch_data_off += FONT::glyph_bitmap_stride;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ROTATION == DEGREE_270) {</div>
<div class="line">            x += ch.yoffset;</div>
<div class="line">            y -= ch.xoffset;</div>
<div class="line">            <span class="keyword">const</span> int32_t x2 = x + <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ch.height);</div>
<div class="line">            <span class="keyword">const</span> int32_t y2 = y - <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(ch.width);</div>
<div class="line">            <span class="keywordflow">for</span> (int32_t xx = x; xx &lt; x2; xx++) {</div>
<div class="line">                <span class="keywordflow">for</span> (int32_t yy = y2; yy &lt; y; yy++) {</div>
<div class="line">                    <span class="keyword">const</span> int32_t x_off = (ch.width - (yy - y2) - 1) + ch.x % 2;</div>
<div class="line">                    <span class="keyword">const</span> int32_t bit_index = (1 - (x_off % 2)) * 4;</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">size_t</span> byte_index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(ch_data_off + x_off / 2);</div>
<div class="line">                    <span class="keywordflow">if</span> (byte_index &lt; (FONT::glyph_bitmap_stride * FONT::glyph_bitmap_height)) {</div>
<div class="line">                        <span class="keyword">const</span> uint8_t a = (FONT::glyph_bitmap[byte_index] &gt;&gt; bit_index) &amp; 0xF;</div>
<div class="line">                        <span class="keywordflow">if</span> (a != 0) {</div>
<div class="line">                            <span class="keywordflow">if</span> (a == 0xF) {</div>
<div class="line">                                plot(xx, yy, col);</div>
<div class="line">                            } <span class="keywordflow">else</span> {</div>
<div class="line">                                <span class="keywordtype">float</span> Al = a2al[a];</div>
<div class="line">                                compose(xx, yy, Al, Rl * Al, Gl * Al, Bl * Al);</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                ch_data_off += FONT::glyph_bitmap_stride;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> span(int32_t x, int32_t w, int32_t y, uint8_t col) {</div>
<div class="line">        <span class="keywordflow">if</span> (x &lt; 0) {</div>
<div class="line">            w += x;</div>
<div class="line">            x = 0;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> ((x &gt;= <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(W)) || (x + w &lt; 0) || (y &gt;= <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(H)) || (y &lt; 0)) {</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (x + w &gt;= <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(W)) {</div>
<div class="line">            w = <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(W) - x;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordtype">size_t</span> _xl = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(x);</div>
<div class="line">        <span class="keywordtype">size_t</span> _xr = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(x + w);</div>
<div class="line">        <span class="keywordtype">size_t</span> _y = <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(y);</div>
<div class="line">        T&lt;W, H, S, GR&gt;::span(data, _xl, _xr, _y, col);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">void</span> fill_arc(int32_t x0, int32_t y0, int32_t r, uint8_t corners, int32_t delta, uint8_t col) {</div>
<div class="line">        int32_t f = 1 - r;</div>
<div class="line">        int32_t ddx = -2 * r;</div>
<div class="line">        int32_t ddy = 1;</div>
<div class="line">        int32_t x = r;</div>
<div class="line">        int32_t y = 0;</div>
<div class="line">        int32_t px = x;</div>
<div class="line">        int32_t py = y;</div>
<div class="line">        delta++;</div>
<div class="line">        int32_t hl = corners &amp; 4 ? 2 : 1;</div>
<div class="line">        int32_t hr = corners &amp; 8 ? 1 : 0;</div>
<div class="line">        <span class="keywordflow">while</span> (y &lt; x) {</div>
<div class="line">            <span class="keywordflow">if</span> (f &gt;= 0) {</div>
<div class="line">                x--;</div>
<div class="line">                ddx += 2;</div>
<div class="line">                f += ddx;</div>
<div class="line">            }</div>
<div class="line">            ddy += 2;</div>
<div class="line">            f += ddy;</div>
<div class="line">            <span class="keywordflow">if</span> (++y &lt; (x + 1)) {</div>
<div class="line">                <span class="keywordflow">if</span> (corners &amp; 1)</div>
<div class="line">                    span(x0 - hr * x, hl * x + delta, y0 + y, col);</div>
<div class="line">                <span class="keywordflow">if</span> (corners &amp; 2)</div>
<div class="line">                    span(x0 - hr * x, hl * x + delta, y0 - y, col);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (x != px) {</div>
<div class="line">                <span class="keywordflow">if</span> (corners &amp; 1)</div>
<div class="line">                    span(x0 - hr * py, hl * py + delta, y0 + px, col);</div>
<div class="line">                <span class="keywordflow">if</span> (corners &amp; 2)</div>
<div class="line">                    span(x0 - hr * py, hl * py + delta, y0 - px, col);</div>
<div class="line">                px = x;</div>
<div class="line">            }</div>
<div class="line">            py = y;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::array&lt;uint8_t, T&lt;W, H, S, GR&gt;::image_size&gt; data{};</div>
<div class="line">    T&lt;W, H, S, GR&gt; format{};</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace constixel</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif  </span><span class="comment">// CONSTIXEL_H_</span></div>
<div class="ttc" id="astructconstixel_1_1rect_html_a156f2f03834d55de7c7962a51da78977"><div class="ttname"><a href="structconstixel_1_1rect.html#a156f2f03834d55de7c7962a51da78977">constixel::rect::x</a></div><div class="ttdeci">T x</div><div class="ttdoc">x coordinate</div><div class="ttdef"><b>Definition</b> constixel.h:343</div></div>
<div class="ttc" id="astructconstixel_1_1rect_html_a29cbd851b77f1651a9ffe762d6bf183a"><div class="ttname"><a href="structconstixel_1_1rect.html#a29cbd851b77f1651a9ffe762d6bf183a">constixel::rect::h</a></div><div class="ttdeci">T h</div><div class="ttdoc">height</div><div class="ttdef"><b>Definition</b> constixel.h:346</div></div>
<div class="ttc" id="astructconstixel_1_1rect_html_a5a27f1ea794be5401b2d9bc9cff20e5d"><div class="ttname"><a href="structconstixel_1_1rect.html#a5a27f1ea794be5401b2d9bc9cff20e5d">constixel::rect::operator&amp;=</a></div><div class="ttdeci">constexpr rect &amp; operator&amp;=(const rect &amp;other)</div><div class="ttdoc">intersects one rect with another</div><div class="ttdef"><b>Definition</b> constixel.h:360</div></div>
<div class="ttc" id="astructconstixel_1_1rect_html_aa8f18249ed87d97bd57312a2c5e2bc50"><div class="ttname"><a href="structconstixel_1_1rect.html#aa8f18249ed87d97bd57312a2c5e2bc50">constixel::rect::operator&amp;</a></div><div class="ttdeci">constexpr rect operator&amp;(const rect &amp;other) const</div><div class="ttdoc">intersects one rect with another</div><div class="ttdef"><b>Definition</b> constixel.h:350</div></div>
<div class="ttc" id="astructconstixel_1_1rect_html_ae1291bf45c485a7e14fa6e9d1fd5567f"><div class="ttname"><a href="structconstixel_1_1rect.html#ae1291bf45c485a7e14fa6e9d1fd5567f">constixel::rect::w</a></div><div class="ttdeci">T w</div><div class="ttdoc">width</div><div class="ttdef"><b>Definition</b> constixel.h:345</div></div>
<div class="ttc" id="astructconstixel_1_1rect_html_af254baaf7a70c829f943a262d290314a"><div class="ttname"><a href="structconstixel_1_1rect.html#af254baaf7a70c829f943a262d290314a">constixel::rect::y</a></div><div class="ttdeci">T y</div><div class="ttdoc">y coordinate</div><div class="ttdef"><b>Definition</b> constixel.h:344</div></div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
