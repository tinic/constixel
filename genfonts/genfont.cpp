#include <charconv>
#include <cstdint>
#include <filesystem>
#include <fstream>
#include <sstream>
#include <string>
#include <string_view>
#include <unordered_map>
#include <vector>
#include <algorithm>
#include <stdexcept>
#include <iostream>
#include <iomanip>

#include "../constixel.hpp"
#include "fontbm/src/external/cxxopts.hpp"
#include "fontbm/src/external/lodepng/lodepng.h"

struct Char {
    uint32_t id = 0;
    uint16_t x = 0, y = 0, width = 0, height = 0;
    int16_t xoffset = 0, yoffset = 0, xadvance = 0;
    uint16_t page = 0;
    uint8_t chnl = 0;
};

struct Kerning {
    uint32_t first = 0;
    uint32_t second = 0;
    int32_t amount = 0;
};

struct Font {
    std::string face{};
    std::string style{};
    int size = 0;
    int lineHeight = 0;
    int base = 0;
    int descent = 0;
    int scaleW = 0, scaleH = 0;
    int pages = 0;
    std::string page_file{};
    std::vector<Char> chars{};
    std::vector<Kerning> kernings{};
    int smooth = 0;
    int totalHeight = 0;
};

struct Config {
    std::string font_file;
    std::string out_dir;
};

struct BitmapInfo {
    std::vector<uint8_t> data;
    uint32_t width;
    uint32_t height;
    size_t stride;
    bool is_mono;
};

struct TypeInfo {
    std::string type_name;
    uint32_t max_value;
    size_t bit_width;
};

static std::string_view trim(std::string_view sv) {
    const auto begin = sv.find_first_not_of(' ');
    const auto end = sv.find_last_not_of(' ');
    return begin == sv.npos ? "" : sv.substr(begin, end - begin + 1);
}

static std::unordered_map<std::string_view, std::string_view> split_kv(std::string_view line) {
    std::unordered_map<std::string_view, std::string_view> kv;
    for (std::size_t i = 0; i < line.size();) {
        while (i < line.size() && line[i] == ' ') ++i;  // skip blanks

        const std::size_t key_beg = i;
        while (i < line.size() && line[i] != '=') ++i;
        if (i == line.size())
            break;
        const std::size_t key_len = i++ - key_beg;  // past '='

        std::string_view val;
        if (i < line.size() && line[i] == '"') {  // quoted value
            const std::size_t val_beg = ++i;
            while (i < line.size() && line[i] != '"') ++i;
            val = line.substr(val_beg, i - val_beg);
            if (i < line.size())
                ++i;  // skip closing quote
        } else {      // unquoted value
            const std::size_t val_beg = i;
            while (i < line.size() && line[i] != ' ') ++i;
            val = line.substr(val_beg, i - val_beg);
        }

        kv.emplace(line.substr(key_beg, key_len), val);
    }
    return kv;
}

static int to_int(std::string_view sv) {
    int v = 0;
    std::from_chars(sv.data(), sv.data() + sv.size(), v);
    return v;
}

static Font parse_fnt(const std::filesystem::path& path) {
    std::ifstream in(path);
    Font font{};
    std::string line;
    while (std::getline(in, line)) {
        const auto sv = trim(line);
        const auto sp = sv.find(' ');
        const auto cmd = sv.substr(0, sp);
        const auto args = sp == sv.npos ? "" : sv.substr(sp + 1);
        const auto kv = split_kv(args);

        if (cmd == "info") {
            font.face = std::string(kv.at("face"));
            font.size = to_int(kv.at("size"));
            font.smooth = to_int(kv.at("smooth"));
            font.style = std::string(kv.at("style"));
        } else if (cmd == "common") {
            font.lineHeight = to_int(kv.at("lineHeight"));
            font.base = to_int(kv.at("base"));
            font.scaleW = to_int(kv.at("scaleW"));
            font.scaleH = to_int(kv.at("scaleH"));
            font.pages = to_int(kv.at("pages"));
            font.totalHeight = to_int(kv.at("totalHeight"));
            font.descent = to_int(kv.at("descent"));
        } else if (cmd == "page") {
            font.page_file = std::string(kv.at("file"));
        } else if (cmd == "char") {
            Char c{};
            c.id = to_int(kv.at("id"));
            c.x = to_int(kv.at("x"));
            c.y = to_int(kv.at("y"));
            c.width = to_int(kv.at("width"));
            c.height = to_int(kv.at("height"));
            c.xoffset = to_int(kv.at("xoffset"));
            c.yoffset = to_int(kv.at("yoffset"));
            c.xadvance = to_int(kv.at("xadvance"));
            c.page = to_int(kv.at("page"));
            c.chnl = to_int(kv.at("chnl"));
            font.chars.push_back(c);
        } else if (cmd == "kerning") {
            Kerning k{};
            k.first = to_int(kv.at("first"));
            k.second = to_int(kv.at("second"));
            k.amount = to_int(kv.at("amount"));
            font.kernings.push_back(k);
        }
    }
    return font;
}

static Config parseCommandLine(int argc, char* argv[]) {
    Config config;
    try {
        cxxopts::Options options("genfont", "Command line font generator for constixel, compatible with bmfont");
        options.add_options()("font-file", "path to .fnt file generated by fontbm, required", cxxopts::value<std::string>(config.font_file))(
            "out-dir", "path to output path, required", cxxopts::value<std::string>(config.out_dir));
        auto result = options.parse(argc, argv);

        if (!result.count("font-file")) {
            std::cout << options.help() << std::endl;
            throw std::runtime_error("--font-file required");
        }

        if (!result.count("out-dir")) {
            std::cout << options.help() << std::endl;
            throw std::runtime_error("--out-dir required");
        }
    } catch (const cxxopts::OptionException& e) {
        std::cout << "error parsing options: " << e.what() << std::endl;
        throw std::exception();
    }
    return config;
}

static std::string slugify(std::string s) {
    std::transform(s.begin(), s.end(), s.begin(), [](unsigned char c) {
        return c == '-' ? '_' : (c == ' ' ? '_' : std::tolower(c));
    });
    return s;
}

static TypeInfo determineGlyphTypeInfo(const std::vector<Char>& chars) {
    uint32_t max_id = 0;
    for (const auto& c : chars) {
        max_id = std::max(c.id, max_id);
    }
    
    if (chars.size() < 0xFF && max_id < 0xFF) {
        return {"uint8_t", max_id, 8};
    } else if (chars.size() < 0xFFFF && max_id < 0xFFFF) {
        return {"uint16_t", max_id, 16};
    } else {
        return {"uint32_t", max_id, 32};
    }
}

static std::string determineCharInfoType(const std::vector<Char>& chars) {
    int32_t max_value = 0;
    for (const auto& c : chars) {
        max_value = std::max(std::abs(static_cast<int32_t>(c.x)), max_value);
        max_value = std::max(std::abs(static_cast<int32_t>(c.y)), max_value);
        max_value = std::max(std::abs(static_cast<int32_t>(c.width)), max_value);
        max_value = std::max(std::abs(static_cast<int32_t>(c.height)), max_value);
        max_value = std::max(std::abs(static_cast<int32_t>(c.xadvance)), max_value);
        max_value = std::max(std::abs(static_cast<int32_t>(c.xoffset)), max_value);
        max_value = std::max(std::abs(static_cast<int32_t>(c.yoffset)), max_value);
    }
    return max_value > 127 ? (max_value > 32767 ? "int32_t" : "int16_t") : "int8_t";
}

static BitmapInfo generateMonoBitmap(const std::vector<uint8_t>& rgbaimage, uint32_t w, uint32_t h) {
    size_t bpr = ((w + 7) / 8);
    std::vector<uint8_t> bitmap(h * bpr, 0);
    
    auto plot = [&bitmap, bpr](size_t x, size_t y) {
        uint8_t* ptr = &bitmap[y * bpr + x / 8];
        *ptr |= 1UL << (7 - x % 8);
    };
    
    for (size_t y = 0; y < h; y++) {
        for (size_t x = 0; x < w; x++) {
            if (rgbaimage[y * w * 4 + x * 4 + 3] > 0) {
                plot(x, y);
            }
        }
    }
    
    return {std::move(bitmap), w, h, bpr, true};
}

static BitmapInfo generateAntialiasedBitmap(const std::vector<uint8_t>& rgbaimage, uint32_t w, uint32_t h) {
    size_t bpr = ((w + 1) / 2);
    std::vector<uint8_t> bitmap(h * bpr, 0);
    
    auto plot = [&bitmap, bpr](size_t x, size_t y, uint8_t a) {
        uint8_t* ptr = &bitmap[y * bpr + x / 2];
        *ptr |= (a >> 4) << ((1 - x % 2) * 4);
    };
    
    for (size_t y = 0; y < h; y++) {
        for (size_t x = 0; x < w; x++) {
            plot(x, y, rgbaimage[y * w * 4 + x * 4 + 3]);
        }
    }
    
    return {std::move(bitmap), w, h, bpr, false};
}

static void writeGlyphTable(std::stringstream& ss, const std::vector<Char>& chars, const TypeInfo& type_info) {
    ss << "    using lookup_type = " << type_info.type_name << ";\n";
    ss << "    static constexpr std::array<std::pair<" << type_info.type_name 
       << ", " << type_info.type_name << ">, " << chars.size() << "> glyph_table{{\n";
    
    for (size_t c = 0; c < chars.size(); c++) {
        ss << "        { " << type_info.type_name << "{0x";
        if (type_info.bit_width == 8) {
            ss << std::hex << std::setfill('0') << std::setw(2) << chars[c].id;
        } else if (type_info.bit_width == 16) {
            ss << std::hex << std::setfill('0') << std::setw(4) << chars[c].id;
        } else {
            ss << std::hex << std::setfill('0') << std::setw(8) << chars[c].id;
        }
        ss << "}, " << type_info.type_name << "{0x";
        if (type_info.bit_width == 8) {
            ss << std::hex << std::setfill('0') << std::setw(2) << c;
        } else if (type_info.bit_width == 16) {
            ss << std::hex << std::setfill('0') << std::setw(4) << c;
        } else {
            ss << std::hex << std::setfill('0') << std::setw(8) << c;
        }
        ss << "} }" << (c < chars.size() - 1 ? "," : "") << "\n";
        ss << std::dec;
    }
    ss << "    }};\n\n";
    
    ss << "    static constexpr hextree<hextree<0, " << type_info.type_name 
       << ">::size(glyph_table), " << type_info.type_name << "> glyph_tree{glyph_table};\n\n";
}

static void writeKerningTable(std::stringstream& ss, const std::vector<Kerning>& kernings) {
    if (kernings.empty()) {
        ss << "    using kerning_lookup_type = uint8_t;\n";
        ss << "    using kerning_amount_type = int8_t;\n";
        ss << "    static constexpr size_t kerning_code_shift = 4;\n";
        ss << "    static constexpr size_t kerning_amount_offset = 0x40;\n";
        ss << "    static constexpr hextree<0, uint8_t> kerning_tree{};\n\n";
        return;
    }
    
    uint32_t max_utf32 = 0;
    for (const auto& k : kernings) {
        max_utf32 = std::max(k.first, max_utf32);
        max_utf32 = std::max(k.second, max_utf32);
    }
    
    if (kernings.size() < 0xFFFF && max_utf32 < 0xFF) {
        ss << "    using kerning_lookup_type = uint16_t;\n";
        ss << "    using kerning_amount_type = int16_t;\n";
        ss << "    static constexpr size_t kerning_code_shift = 8;\n";
        ss << "    static constexpr int16_t kerning_amount_offset = 0x4000;\n";
        ss << "    static constexpr std::array<std::pair<uint16_t, uint16_t>, " << kernings.size() << "> kerning_table{{\n";
        
        for (size_t c = 0; c < kernings.size(); c++) {
            ss << "        { uint16_t{0x" << std::hex << std::setfill('0') << std::setw(4)
               << (kernings[c].first << 8 | kernings[c].second) << "}, uint16_t{0x"
               << std::setfill('0') << std::setw(4) << static_cast<uint16_t>(kernings[c].amount + 0x4000)
               << "} }" << (c < kernings.size() - 1 ? "," : "") << "\n";
        }
        ss << std::dec << "    }};\n\n";
        ss << "    static constexpr hextree<hextree<0, uint16_t>::size(kerning_table), uint16_t> kerning_tree{kerning_table};\n\n";
    } else if (max_utf32 < 65535) {
        ss << "    using kerning_lookup_type = uint32_t;\n";
        ss << "    using kerning_amount_type = int32_t;\n";
        ss << "    static constexpr size_t kerning_code_shift = 16;\n";
        ss << "    static constexpr int32_t kerning_amount_offset = 0x40000000;\n";
        ss << "    static constexpr std::array<std::pair<uint32_t, uint32_t>, " << kernings.size() << "> kerning_table{{\n";
        
        for (size_t c = 0; c < kernings.size(); c++) {
            ss << "        { uint32_t{0x" << std::hex << std::setfill('0') << std::setw(8)
               << (kernings[c].first << 16 | kernings[c].second) << "}, uint32_t{0x"
               << std::setfill('0') << std::setw(8) << static_cast<uint32_t>(kernings[c].amount + 0x4000)
               << "} }" << (c < kernings.size() - 1 ? "," : "") << "\n";
        }
        ss << std::dec << "    }};\n\n";
        ss << "    static constexpr hextree<hextree<0, uint32_t>::size(kerning_table), uint32_t> kerning_tree{kerning_table};\n\n";
    }
}

static void writeCharTable(std::stringstream& ss, const std::vector<Char>& chars, const std::string& char_type) {
    ss << "    using char_info_type = " << char_type << ";\n";
    ss << "    static constexpr std::array<char_info<" << char_type << ">, " << chars.size() << "> char_table{{\n";
    
    for (size_t c = 0; c < chars.size(); c++) {
        ss << "        { " << char_type << "{" << std::setw(4) << std::setfill(' ') << chars[c].x
           << "}, " << char_type << "{" << std::setw(4) << std::setfill(' ') << chars[c].y
           << "}, " << char_type << "{" << std::setw(4) << std::setfill(' ') << chars[c].width
           << "}, " << char_type << "{" << std::setw(4) << std::setfill(' ') << chars[c].height
           << "}, " << char_type << "{" << std::setw(4) << std::setfill(' ') << chars[c].xadvance
           << "}, " << char_type << "{" << std::setw(4) << std::setfill(' ') << chars[c].xoffset
           << "}, " << char_type << "{" << std::setw(4) << std::setfill(' ') << chars[c].yoffset
           << "} }" << (c < chars.size() - 1 ? "," : "") << "\n";
    }
    ss << "    }};\n\n";
}

static void writeBitmapData(std::stringstream& ss, const BitmapInfo& bitmap) {
    ss << "    static constexpr bool mono = " << (bitmap.is_mono ? "true" : "false") << ";\n";
    ss << "    static constexpr size_t glyph_bitmap_width = " << bitmap.width << ";\n";
    ss << "    static constexpr size_t glyph_bitmap_height = " << bitmap.height << ";\n";
    ss << "    static constexpr size_t glyph_bitmap_stride = " << bitmap.stride << ";\n\n";
    ss << "    static constexpr std::array<uint8_t, " << bitmap.data.size() << "> glyph_bitmap{{\n";
    ss << "        ";
    
    for (size_t c = 0; c < bitmap.data.size(); c++) {
        ss << "0x" << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(bitmap.data[c]);
        if (c < bitmap.data.size() - 1) ss << ",";
        if ((c + 1) % 16 == 0 && c < bitmap.data.size() - 1) {
            ss << "\n        ";
        }
    }
    ss << std::dec << "\n    }};\n\n";
}

static std::string generateFontStruct(const Font& font, const BitmapInfo& bitmap, const std::string& name) {
    std::stringstream ss;
    
    ss << "namespace constixel {\n\n";
    ss << "struct " << name << " {\n\n";
    
    ss << "    static constexpr const char *name = \"" << font.face << "\";\n";
    ss << "    static constexpr const char *style = \"" << font.style << "\";\n";
    ss << "    static constexpr int32_t size = " << std::abs(font.size) << ";\n";
    ss << "    static constexpr int32_t ascent = " << font.base << ";\n";
    ss << "    static constexpr int32_t descent = " << font.descent << ";\n";
    ss << "    static constexpr int32_t line_height = " << font.lineHeight << ";\n";
    ss << "    static constexpr int32_t total_height = " << font.totalHeight << ";\n\n";
    
    auto type_info = determineGlyphTypeInfo(font.chars);
    writeGlyphTable(ss, font.chars, type_info);
    writeKerningTable(ss, font.kernings);
    
    auto char_type = determineCharInfoType(font.chars);
    writeCharTable(ss, font.chars, char_type);
    
    writeBitmapData(ss, bitmap);
    
    ss << "};\n\n";
    ss << "}\n";
    
    return ss.str();
}

int main(int argc, char* argv[]) {
    Config config = parseCommandLine(argc, argv);
    Font font = parse_fnt(config.font_file);
    std::cout << "Converting font: " << config.font_file << "\n";
    
    if (font.page_file.empty()) {
        throw std::runtime_error("Font file does not contain texture file name.");
    }
    
    if (font.face.empty()) {
        throw std::runtime_error("Font has no name.");
    }
    
    std::vector<uint8_t> rgbaimage;
    uint32_t w = 0;
    uint32_t h = 0;
    auto path = std::filesystem::path{config.font_file}.parent_path() / font.page_file;
    
    if (lodepng::decode(rgbaimage, w, h, path) != 0) {
        throw std::runtime_error("Can not open/decode font texture.");
    }
    
    bool is_mono = font.smooth == 0;
    std::string name = slugify(std::filesystem::path(config.font_file).stem().string()) + "_" + (is_mono ? "mono" : "aa");
    
    BitmapInfo bitmap = is_mono ? generateMonoBitmap(rgbaimage, w, h) : generateAntialiasedBitmap(rgbaimage, w, h);
    
    std::string font_struct = generateFontStruct(font, bitmap, name);
    
    std::filesystem::path output_file = std::filesystem::path(config.out_dir) / (name + ".hpp");
    std::ofstream out(output_file);
    if (!out) {
        throw std::runtime_error("Cannot write output file: " + output_file.string());
    }
    out << font_struct;
    
    return 0;
}